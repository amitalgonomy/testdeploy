{"version":3,"file":"app.js","sources":["../node_modules/@empathyco/x-components/node_modules/tslib/tslib.es6.mjs","../node_modules/vue/dist/vue.runtime.esm.js","../node_modules/vue-class-component/dist/vue-class-component.esm.js","../node_modules/@empathyco/x-components/node_modules/vue-property-decorator/lib/vue-property-decorator.js","../node_modules/@empathyco/src/utils/array.ts","../node_modules/@empathyco/src/components/decorators/injection.decorators.ts","../node_modules/@empathyco/x-storage-service/node_modules/tslib/tslib.es6.mjs","../node_modules/@empathyco/x-logger/src/logger.interfaces.ts","../node_modules/@empathyco/x-logger/node_modules/tslib/tslib.es6.js","../node_modules/@empathyco/x-logger/src/simple-logger.ts","../node_modules/@empathyco/x-logger/src/logger.ts","../node_modules/@empathyco/x-storage-service/src/browser-storage-service.ts","../node_modules/@empathyco/x-storage-service/src/in-memory-storage-service.ts","../node_modules/@empathyco/src/components/no-element.ts","../node_modules/tslib/tslib.es6.js","../node_modules/rxjs/src/internal/util/isFunction.ts","../node_modules/rxjs/src/internal/util/createErrorClass.ts","../node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","../node_modules/rxjs/src/internal/util/arrRemove.ts","../node_modules/rxjs/src/internal/Subscription.ts","../node_modules/rxjs/src/internal/config.ts","../node_modules/rxjs/src/internal/scheduler/timeoutProvider.ts","../node_modules/rxjs/src/internal/util/reportUnhandledError.ts","../node_modules/rxjs/src/internal/util/noop.ts","../node_modules/rxjs/src/internal/NotificationFactories.ts","../node_modules/rxjs/src/internal/util/errorContext.ts","../node_modules/rxjs/src/internal/Subscriber.ts","../node_modules/rxjs/src/internal/symbol/observable.ts","../node_modules/rxjs/src/internal/util/identity.ts","../node_modules/rxjs/src/internal/util/pipe.ts","../node_modules/rxjs/src/internal/Observable.ts","../node_modules/rxjs/src/internal/util/lift.ts","../node_modules/rxjs/src/internal/operators/OperatorSubscriber.ts","../node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","../node_modules/rxjs/src/internal/Subject.ts","../node_modules/rxjs/src/internal/scheduler/dateTimestampProvider.ts","../node_modules/rxjs/src/internal/ReplaySubject.ts","../node_modules/rxjs/src/internal/scheduler/Action.ts","../node_modules/rxjs/src/internal/scheduler/intervalProvider.ts","../node_modules/rxjs/src/internal/scheduler/AsyncAction.ts","../node_modules/rxjs/src/internal/Scheduler.ts","../node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts","../node_modules/rxjs/src/internal/scheduler/async.ts","../node_modules/rxjs/src/internal/symbol/iterator.ts","../node_modules/rxjs/src/internal/observable/innerFrom.ts","../node_modules/rxjs/src/internal/util/isInteropObservable.ts","../node_modules/rxjs/src/internal/util/isArrayLike.ts","../node_modules/rxjs/src/internal/util/isPromise.ts","../node_modules/rxjs/src/internal/util/isAsyncIterable.ts","../node_modules/rxjs/src/internal/util/isIterable.ts","../node_modules/rxjs/src/internal/util/isReadableStreamLike.ts","../node_modules/rxjs/src/internal/util/throwUnobservableError.ts","../node_modules/rxjs/src/internal/operators/map.ts","../node_modules/rxjs/src/internal/observable/timer.ts","../node_modules/rxjs/src/internal/util/isScheduler.ts","../node_modules/rxjs/src/internal/util/isDate.ts","../node_modules/rxjs/src/internal/util/argsOrArgArray.ts","../node_modules/rxjs/src/internal/operators/filter.ts","../node_modules/rxjs/src/internal/observable/race.ts","../node_modules/@empathyco/src/components/decorators/bus.decorators.ts","../node_modules/@empathyco/src/utils/clone.ts","../node_modules/@empathyco/src/plugins/x-plugin.utils.ts","../node_modules/@empathyco/src/components/decorators/store.decorators.ts","../node_modules/@empathyco/x-utils/src/get-safe-property-chain.ts","../node_modules/@empathyco/x-utils/src/typeguards.ts","../node_modules/@empathyco/x-utils/src/object.ts","../node_modules/@empathyco/x-utils/src/services/session.service.ts","../node_modules/nanoid/index.browser.js","../node_modules/@empathyco/x-components/node_modules/@empathyco/x-deep-merge/src/deep-merge.ts","../node_modules/vuex/dist/vuex.esm.js","../node_modules/@empathyco/src/store/utils/getters-proxy.utils.ts","../node_modules/@empathyco/src/store/x.module.ts","../node_modules/@empathyco/src/wiring/wires-operators.utils.ts","../node_modules/rxjs/src/internal/operators/takeUntil.ts","../node_modules/@empathyco/src/wiring/wires.operators.ts","../node_modules/rxjs/src/internal/operators/debounce.ts","../node_modules/@empathyco/x-priority-queue/src/x-priority-queue.ts","../node_modules/@empathyco/src/plugins/devtools/timeline.devtools.ts","../node_modules/@empathyco/src/plugins/x-bus.ts","../node_modules/@empathyco/x-bus/src/x-bus.ts","../node_modules/@empathyco/src/plugins/x-emitters.ts","../node_modules/@empathyco/src/components/x-component.utils.ts","../node_modules/@empathyco/src/plugins/x-plugin.mixin.ts","../node_modules/@empathyco/src/plugins/x-plugin.alias.ts","../node_modules/@empathyco/src/plugins/x-plugin.ts","../node_modules/@empathyco/src/components/x-component.mixin.ts","../node_modules/@empathyco/src/store/utils/store-emitters.utils.ts","../node_modules/@empathyco/src/wiring/wires.factory.ts","../node_modules/@empathyco/src/wiring/wiring.utils.ts","../node_modules/@empathyco/src/wiring/namespaced-wires.factory.ts","../node_modules/@vueuse/shared/index.mjs","../node_modules/vue-demi/lib/index.mjs","../node_modules/@vueuse/core/index.mjs","../node_modules/@empathyco/src/utils/string.ts","../node_modules/@empathyco/src/composables/create-use-device.composable.ts","../node_modules/@empathyco/src/components/global-x-bus.vue?rollup-plugin-vue=script.ts","../node_modules/@empathyco/src/components/global-x-bus.vue","../node_modules/@empathyco/src/components/snippet-callbacks.vue?rollup-plugin-vue=script.ts","../node_modules/@empathyco/src/components/snippet-callbacks.vue","../node_modules/@empathyco/src/utils/origin.ts","../node_modules/@empathyco/src/wiring/namespaced-wires.operators.ts","../node_modules/@empathyco/src/x-installer/api/base-api.ts","../node_modules/vue-i18n/dist/vue-i18n.esm.js","../node_modules/@empathyco/x-deep-merge/src/deep-merge.ts","../node_modules/@empathyco/x-deep-merge/node_modules/tslib/tslib.es6.js","../node_modules/@empathyco/x-archetype-utils/dist/esm/i18n/i18n.plugin.js","../node_modules/@empathyco/src/x-modules/tagging/store/module.ts","../node_modules/@empathyco/src/x-modules/tagging/store/actions/track.action.ts","../node_modules/@empathyco/src/x-modules/tagging/store/emitters.ts","../node_modules/@empathyco/src/x-modules/tagging/service/pdp-add-to-cart.service.ts","../node_modules/@empathyco/src/x-modules/tagging/wiring.ts","../node_modules/@empathyco/src/x-modules/tagging/x-module.ts","../node_modules/@empathyco/src/x-modules/tagging/components/tagging.vue?rollup-plugin-vue=script.ts","../node_modules/@empathyco/src/x-modules/tagging/components/tagging.vue","../node_modules/vue-global-events/dist/vue-global-events.es.js","../node_modules/@empathyco/src/x-modules/url/store/initial-state.ts","../node_modules/@empathyco/src/store/utils/query.utils.ts","../node_modules/@empathyco/src/x-modules/url/store/getters/url-params.getter.ts","../node_modules/@empathyco/src/x-modules/url/store/module.ts","../node_modules/@empathyco/src/x-modules/url/store/mutations/set-params.mutation.ts","../node_modules/@empathyco/src/x-modules/url/store/emitters.ts","../node_modules/@empathyco/src/x-modules/url/wiring.ts","../node_modules/@empathyco/src/x-modules/url/x-module.ts","../node_modules/@empathyco/src/x-modules/url/components/url-handler.vue?rollup-plugin-vue=script.ts","../node_modules/@empathyco/src/x-modules/url/components/url-handler.vue","../node_modules/@empathyco/src/x-modules/extra-params/store/module.ts","../node_modules/@empathyco/src/x-modules/extra-params/store/emitters.ts","../node_modules/@empathyco/src/x-modules/extra-params/wiring.ts","../node_modules/@empathyco/src/x-modules/extra-params/x-module.ts","../node_modules/@empathyco/src/x-modules/extra-params/components/extra-params.vue?rollup-plugin-vue=script.ts","../node_modules/@empathyco/src/x-modules/extra-params/components/extra-params.vue","../node_modules/@empathyco/src/x-modules/extra-params/components/snippet-config-extra-params.vue?rollup-plugin-vue=script.ts","../node_modules/@empathyco/src/x-modules/extra-params/components/snippet-config-extra-params.vue","../node_modules/vue-property-decorator/lib/vue-property-decorator.js","../src/device-breakpoints.ts","../src/composables/use-device.composable.ts","../src/i18n/currencies.ts","../src/App.vue?rollup-plugin-vue=script.ts","../src/App.vue","../src/i18n/messages/index.ts","../src/store/index.ts","../node_modules/@empathyco/x-adapter/node_modules/@empathyco/x-deep-merge/src/deep-merge.ts","../node_modules/@empathyco/x-adapter/node_modules/tslib/tslib.es6.mjs","../node_modules/@empathyco/x-adapter/src/http-clients/errors/request-error.ts","../node_modules/@empathyco/x-adapter/src/http-clients/utils.ts","../node_modules/@empathyco/x-adapter/src/http-clients/fetch.http-client.ts","../node_modules/@empathyco/x-adapter/src/mappers/identity.mapper.ts","../node_modules/@empathyco/x-adapter/src/utils/interpolate.ts","../node_modules/@empathyco/x-adapter/src/endpoint-adapter/endpoint-adapter.factory.ts","../node_modules/@empathyco/x-adapter/src/schemas/utils.ts","../node_modules/@empathyco/x-adapter/src/mappers/schema-mapper.factory.ts","../node_modules/@empathyco/x-types/dist/esm/facet/filter/hierarchical-filter.model.js","../node_modules/@empathyco/x-adapter-platform/src/schemas/requests/search-request.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/requests/search-request.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/url.utils.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/models/banner.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/models/filters/hierarchical-filter.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/models/filters/number-filter.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/models/filters/simple-filter.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/models/filters/editable-number-filter.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/facets/utils.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/models/facet.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/models/result.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/models/partial-results.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/models/promoted.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/models/redirection.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/responses/search-response.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/responses/search-response.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/endpoint-adapters/search.endpoint-adapter.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/requests/popular-searches-request.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/requests/popular-searches-request.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/models/suggestion.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/responses/popular-searches-response.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/responses/popular-searches-response.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/endpoint-adapters/popular-searches.endpoint-adapter.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/requests/recommendations-request.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/requests/recommendations-request.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/responses/recommendations-response.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/responses/recommendations-response.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/endpoint-adapters/recommendations.endpoint-adapter.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/requests/next-queries-request.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/requests/next-queries-request.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/responses/identifier-results-response.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/models/next-query.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/responses/next-queries-response.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/responses/query-suggestions-response.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/models/related-tag.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/responses/related-tags-response.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/models/semantic-query.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/responses/semantic-queries-response.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/responses/next-queries-response.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/endpoint-adapters/next-queries.endpoint-adapter.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/requests/related-tags-request.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/requests/related-tags-request.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/responses/related-tags-response.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/endpoint-adapters/related-tags.endpoint-adapter.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/requests/identifier-results-request.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/requests/identifier-results-request.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/responses/identifier-results-response.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/endpoint-adapters/identifier-results.endpoint-adapter.ts","../node_modules/@empathyco/x-adapter-platform/src/endpoint-adapters/tagging.endpoint-adapter.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/requests/tagging-request.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/requests/query-suggestions-request.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/requests/query-suggestions-request.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/responses/query-suggestions-response.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/endpoint-adapters/query-suggestions.endpoint-adapter.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/requests/semantic-queries-request.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/schemas/requests/semantic-queries-request.schema.ts","../node_modules/@empathyco/x-adapter-platform/src/mappers/responses/semantic-queries-response.mapper.ts","../node_modules/@empathyco/x-adapter-platform/src/platform.adapter.ts","../node_modules/@empathyco/x-adapter-platform/src/endpoint-adapters/semantic-queries.endpoint-adapter.ts","../src/adapter/algonomy/responses/search/result.schema.ts","../src/adapter/algonomy/responses/search/banner.schema.ts","../src/adapter/algonomy/responses/search/promoteds.schema.ts","../src/adapter/algonomy/responses/search/redirection.schema.ts","../src/adapter/algonomy/responses/search/filters/simple-filter.schema.ts","../src/adapter/algonomy/responses/search/facets.schema.ts","../src/adapter/algonomy/responses/search/searchResponse.schema.ts","../src/adapter/algonomy/requests/search.schema.ts","../src/adapter/algonomy/requests/query-suggestion.schema.ts","../src/adapter/algonomy/responses/query-suggestion/suggestion.schema.ts","../src/adapter/algonomy/responses/query-suggestion/query-suggestion.schema.ts","../src/adapter/adapter.ts","../src/x-components/plugin.options.ts","../src/main.ts","../node_modules/@empathyco/src/x-installer/x-installer/x-installer.ts"],"sourcesContent":["/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n};\n","/*!\n * Vue.js v2.7.14\n * (c) 2014-2022 Evan You\n * Released under the MIT License.\n */\nvar emptyObject = Object.freeze({});\nvar isArray = Array.isArray;\n// These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\nfunction isUndef(v) {\n    return v === undefined || v === null;\n}\nfunction isDef(v) {\n    return v !== undefined && v !== null;\n}\nfunction isTrue(v) {\n    return v === true;\n}\nfunction isFalse(v) {\n    return v === false;\n}\n/**\n * Check if value is primitive.\n */\nfunction isPrimitive(value) {\n    return (typeof value === 'string' ||\n        typeof value === 'number' ||\n        // $flow-disable-line\n        typeof value === 'symbol' ||\n        typeof value === 'boolean');\n}\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n/**\n * Quick object check - this is primarily used to tell\n * objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n}\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\nvar _toString = Object.prototype.toString;\nfunction toRawType(value) {\n    return _toString.call(value).slice(8, -1);\n}\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject(obj) {\n    return _toString.call(obj) === '[object Object]';\n}\nfunction isRegExp(v) {\n    return _toString.call(v) === '[object RegExp]';\n}\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex(val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\nfunction isPromise(val) {\n    return (isDef(val) &&\n        typeof val.then === 'function' &&\n        typeof val.catch === 'function');\n}\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString(val) {\n    return val == null\n        ? ''\n        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n            ? JSON.stringify(val, null, 2)\n            : String(val);\n}\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber(val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n;\n}\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap(str, expectsLowerCase) {\n    var map = Object.create(null);\n    var list = str.split(',');\n    for (var i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase ? function (val) { return map[val.toLowerCase()]; } : function (val) { return map[val]; };\n}\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n/**\n * Check if an attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n/**\n * Remove an item from an array.\n */\nfunction remove$2(arr, item) {\n    var len = arr.length;\n    if (len) {\n        // fast path for the only / last item\n        if (item === arr[len - 1]) {\n            arr.length = len - 1;\n            return;\n        }\n        var index = arr.indexOf(item);\n        if (index > -1) {\n            return arr.splice(index, 1);\n        }\n    }\n}\n/**\n * Check whether an object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n}\n/**\n * Create a cached version of a pure function.\n */\nfunction cached(fn) {\n    var cache = Object.create(null);\n    return function cachedFn(str) {\n        var hit = cache[str];\n        return hit || (cache[str] = fn(str));\n    };\n}\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); });\n});\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n});\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\n});\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n/* istanbul ignore next */\nfunction polyfillBind(fn, ctx) {\n    function boundFn(a) {\n        var l = arguments.length;\n        return l\n            ? l > 1\n                ? fn.apply(ctx, arguments)\n                : fn.call(ctx, a)\n            : fn.call(ctx);\n    }\n    boundFn._length = fn.length;\n    return boundFn;\n}\nfunction nativeBind(fn, ctx) {\n    return fn.bind(ctx);\n}\n// @ts-expect-error bind cannot be `undefined`\nvar bind = Function.prototype.bind ? nativeBind : polyfillBind;\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray(list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n    while (i--) {\n        ret[i] = list[i + start];\n    }\n    return ret;\n}\n/**\n * Mix properties into target object.\n */\nfunction extend(to, _from) {\n    for (var key in _from) {\n        to[key] = _from[key];\n    }\n    return to;\n}\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject(arr) {\n    var res = {};\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i]) {\n            extend(res, arr[i]);\n        }\n    }\n    return res;\n}\n/* eslint-disable no-unused-vars */\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\nfunction noop(a, b, c) { }\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n/* eslint-enable no-unused-vars */\n/**\n * Return the same value.\n */\nvar identity = function (_) { return _; };\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual(a, b) {\n    if (a === b)\n        return true;\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n    if (isObjectA && isObjectB) {\n        try {\n            var isArrayA = Array.isArray(a);\n            var isArrayB = Array.isArray(b);\n            if (isArrayA && isArrayB) {\n                return (a.length === b.length &&\n                    a.every(function (e, i) {\n                        return looseEqual(e, b[i]);\n                    }));\n            }\n            else if (a instanceof Date && b instanceof Date) {\n                return a.getTime() === b.getTime();\n            }\n            else if (!isArrayA && !isArrayB) {\n                var keysA = Object.keys(a);\n                var keysB = Object.keys(b);\n                return (keysA.length === keysB.length &&\n                    keysA.every(function (key) {\n                        return looseEqual(a[key], b[key]);\n                    }));\n            }\n            else {\n                /* istanbul ignore next */\n                return false;\n            }\n        }\n        catch (e) {\n            /* istanbul ignore next */\n            return false;\n        }\n    }\n    else if (!isObjectA && !isObjectB) {\n        return String(a) === String(b);\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\nfunction looseIndexOf(arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n        if (looseEqual(arr[i], val))\n            return i;\n    }\n    return -1;\n}\n/**\n * Ensure a function is called only once.\n */\nfunction once(fn) {\n    var called = false;\n    return function () {\n        if (!called) {\n            called = true;\n            fn.apply(this, arguments);\n        }\n    };\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill\nfunction hasChanged(x, y) {\n    if (x === y) {\n        return x === 0 && 1 / x !== 1 / y;\n    }\n    else {\n        return x === x || y === y;\n    }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\nvar ASSET_TYPES = ['component', 'directive', 'filter'];\nvar LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated',\n    'errorCaptured',\n    'serverPrefetch',\n    'renderTracked',\n    'renderTriggered'\n];\n\nvar config = {\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: process.env.NODE_ENV !== 'production',\n    /**\n     * Whether to enable devtools\n     */\n    devtools: process.env.NODE_ENV !== 'production',\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n    /**\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\n     * This will significantly reduce performance if set to false.\n     */\n    async: true,\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n};\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved(str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5f;\n}\n/**\n * Define a property.\n */\nfunction def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n        value: val,\n        enumerable: !!enumerable,\n        writable: true,\n        configurable: true\n    });\n}\n/**\n * Parse simple path.\n */\nvar bailRE = new RegExp(\"[^\".concat(unicodeRegExp.source, \".$_\\\\d]\"));\nfunction parsePath(path) {\n    if (bailRE.test(path)) {\n        return;\n    }\n    var segments = path.split('.');\n    return function (obj) {\n        for (var i = 0; i < segments.length; i++) {\n            if (!obj)\n                return;\n            obj = obj[segments[i]];\n        }\n        return obj;\n    };\n}\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nUA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nUA && /chrome\\/\\d+/.test(UA) && !isEdge;\nUA && /phantomjs/.test(UA);\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/);\n// Firefox has a \"watch\" function on Object.prototype...\n// @ts-expect-error firebox support\nvar nativeWatch = {}.watch;\nvar supportsPassive = false;\nif (inBrowser) {\n    try {\n        var opts = {};\n        Object.defineProperty(opts, 'passive', {\n            get: function () {\n                /* istanbul ignore next */\n                supportsPassive = true;\n            }\n        }); // https://github.com/facebook/flow/issues/285\n        window.addEventListener('test-passive', null, opts);\n    }\n    catch (e) { }\n}\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n    if (_isServer === undefined) {\n        /* istanbul ignore if */\n        if (!inBrowser && typeof global !== 'undefined') {\n            // detect presence of vue-server-renderer and avoid\n            // Webpack shimming the process\n            _isServer =\n                global['process'] && global['process'].env.VUE_ENV === 'server';\n        }\n        else {\n            _isServer = false;\n        }\n    }\n    return _isServer;\n};\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n/* istanbul ignore next */\nfunction isNative(Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n}\nvar hasSymbol = typeof Symbol !== 'undefined' &&\n    isNative(Symbol) &&\n    typeof Reflect !== 'undefined' &&\n    isNative(Reflect.ownKeys);\nvar _Set; // $flow-disable-line\n/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n}\nelse {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = /** @class */ (function () {\n        function Set() {\n            this.set = Object.create(null);\n        }\n        Set.prototype.has = function (key) {\n            return this.set[key] === true;\n        };\n        Set.prototype.add = function (key) {\n            this.set[key] = true;\n        };\n        Set.prototype.clear = function () {\n            this.set = Object.create(null);\n        };\n        return Set;\n    }());\n}\n\nvar currentInstance = null;\n/**\n * This is exposed for compatibility with v3 (e.g. some functions in VueUse\n * relies on it). Do not use this internally, just use `currentInstance`.\n *\n * @internal this function needs manual type declaration because it relies\n * on previously manually authored types from Vue 2\n */\nfunction getCurrentInstance() {\n    return currentInstance && { proxy: currentInstance };\n}\n/**\n * @internal\n */\nfunction setCurrentInstance(vm) {\n    if (vm === void 0) { vm = null; }\n    if (!vm)\n        currentInstance && currentInstance._scope.off();\n    currentInstance = vm;\n    vm && vm._scope.on();\n}\n\n/**\n * @internal\n */\nvar VNode = /** @class */ (function () {\n    function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n        this.tag = tag;\n        this.data = data;\n        this.children = children;\n        this.text = text;\n        this.elm = elm;\n        this.ns = undefined;\n        this.context = context;\n        this.fnContext = undefined;\n        this.fnOptions = undefined;\n        this.fnScopeId = undefined;\n        this.key = data && data.key;\n        this.componentOptions = componentOptions;\n        this.componentInstance = undefined;\n        this.parent = undefined;\n        this.raw = false;\n        this.isStatic = false;\n        this.isRootInsert = true;\n        this.isComment = false;\n        this.isCloned = false;\n        this.isOnce = false;\n        this.asyncFactory = asyncFactory;\n        this.asyncMeta = undefined;\n        this.isAsyncPlaceholder = false;\n    }\n    Object.defineProperty(VNode.prototype, \"child\", {\n        // DEPRECATED: alias for componentInstance for backwards compat.\n        /* istanbul ignore next */\n        get: function () {\n            return this.componentInstance;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return VNode;\n}());\nvar createEmptyVNode = function (text) {\n    if (text === void 0) { text = ''; }\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node;\n};\nfunction createTextVNode(val) {\n    return new VNode(undefined, undefined, undefined, String(val));\n}\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode(vnode) {\n    var cloned = new VNode(vnode.tag, vnode.data, \n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.asyncMeta = vnode.asyncMeta;\n    cloned.isCloned = true;\n    return cloned;\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar uid$2 = 0;\nvar pendingCleanupDeps = [];\nvar cleanupDeps = function () {\n    for (var i = 0; i < pendingCleanupDeps.length; i++) {\n        var dep = pendingCleanupDeps[i];\n        dep.subs = dep.subs.filter(function (s) { return s; });\n        dep._pending = false;\n    }\n    pendingCleanupDeps.length = 0;\n};\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n * @internal\n */\nvar Dep = /** @class */ (function () {\n    function Dep() {\n        // pending subs cleanup\n        this._pending = false;\n        this.id = uid$2++;\n        this.subs = [];\n    }\n    Dep.prototype.addSub = function (sub) {\n        this.subs.push(sub);\n    };\n    Dep.prototype.removeSub = function (sub) {\n        // #12696 deps with massive amount of subscribers are extremely slow to\n        // clean up in Chromium\n        // to workaround this, we unset the sub for now, and clear them on\n        // next scheduler flush.\n        this.subs[this.subs.indexOf(sub)] = null;\n        if (!this._pending) {\n            this._pending = true;\n            pendingCleanupDeps.push(this);\n        }\n    };\n    Dep.prototype.depend = function (info) {\n        if (Dep.target) {\n            Dep.target.addDep(this);\n            if (process.env.NODE_ENV !== 'production' && info && Dep.target.onTrack) {\n                Dep.target.onTrack(__assign({ effect: Dep.target }, info));\n            }\n        }\n    };\n    Dep.prototype.notify = function (info) {\n        // stabilize the subscriber list first\n        var subs = this.subs.filter(function (s) { return s; });\n        if (process.env.NODE_ENV !== 'production' && !config.async) {\n            // subs aren't sorted in scheduler if not running async\n            // we need to sort them now to make sure they fire in correct\n            // order\n            subs.sort(function (a, b) { return a.id - b.id; });\n        }\n        for (var i = 0, l = subs.length; i < l; i++) {\n            var sub = subs[i];\n            if (process.env.NODE_ENV !== 'production' && info) {\n                sub.onTrigger &&\n                    sub.onTrigger(__assign({ effect: subs[i] }, info));\n            }\n            sub.update();\n        }\n    };\n    return Dep;\n}());\n// The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\nDep.target = null;\nvar targetStack = [];\nfunction pushTarget(target) {\n    targetStack.push(target);\n    Dep.target = target;\n}\nfunction popTarget() {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\nvar methodsToPatch = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'splice',\n    'sort',\n    'reverse'\n];\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var result = original.apply(this, args);\n        var ob = this.__ob__;\n        var inserted;\n        switch (method) {\n            case 'push':\n            case 'unshift':\n                inserted = args;\n                break;\n            case 'splice':\n                inserted = args.slice(2);\n                break;\n        }\n        if (inserted)\n            ob.observeArray(inserted);\n        // notify change\n        if (process.env.NODE_ENV !== 'production') {\n            ob.dep.notify({\n                type: \"array mutation\" /* TriggerOpTypes.ARRAY_MUTATION */,\n                target: this,\n                key: method\n            });\n        }\n        else {\n            ob.dep.notify();\n        }\n        return result;\n    });\n});\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\nvar NO_INIITIAL_VALUE = {};\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nvar shouldObserve = true;\nfunction toggleObserving(value) {\n    shouldObserve = value;\n}\n// ssr mock dep\nvar mockDep = {\n    notify: noop,\n    depend: noop,\n    addSub: noop,\n    removeSub: noop\n};\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nvar Observer = /** @class */ (function () {\n    function Observer(value, shallow, mock) {\n        if (shallow === void 0) { shallow = false; }\n        if (mock === void 0) { mock = false; }\n        this.value = value;\n        this.shallow = shallow;\n        this.mock = mock;\n        // this.value = value\n        this.dep = mock ? mockDep : new Dep();\n        this.vmCount = 0;\n        def(value, '__ob__', this);\n        if (isArray(value)) {\n            if (!mock) {\n                if (hasProto) {\n                    value.__proto__ = arrayMethods;\n                    /* eslint-enable no-proto */\n                }\n                else {\n                    for (var i = 0, l = arrayKeys.length; i < l; i++) {\n                        var key = arrayKeys[i];\n                        def(value, key, arrayMethods[key]);\n                    }\n                }\n            }\n            if (!shallow) {\n                this.observeArray(value);\n            }\n        }\n        else {\n            /**\n             * Walk through all properties and convert them into\n             * getter/setters. This method should only be called when\n             * value type is Object.\n             */\n            var keys = Object.keys(value);\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                defineReactive(value, key, NO_INIITIAL_VALUE, undefined, shallow, mock);\n            }\n        }\n    }\n    /**\n     * Observe a list of Array items.\n     */\n    Observer.prototype.observeArray = function (value) {\n        for (var i = 0, l = value.length; i < l; i++) {\n            observe(value[i], false, this.mock);\n        }\n    };\n    return Observer;\n}());\n// helpers\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe(value, shallow, ssrMockReactivity) {\n    if (value && hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n        return value.__ob__;\n    }\n    if (shouldObserve &&\n        (ssrMockReactivity || !isServerRendering()) &&\n        (isArray(value) || isPlainObject(value)) &&\n        Object.isExtensible(value) &&\n        !value.__v_skip /* ReactiveFlags.SKIP */ &&\n        !isRef(value) &&\n        !(value instanceof VNode)) {\n        return new Observer(value, shallow, ssrMockReactivity);\n    }\n}\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive(obj, key, val, customSetter, shallow, mock) {\n    var dep = new Dep();\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n        return;\n    }\n    // cater for pre-defined getter/setters\n    var getter = property && property.get;\n    var setter = property && property.set;\n    if ((!getter || setter) &&\n        (val === NO_INIITIAL_VALUE || arguments.length === 2)) {\n        val = obj[key];\n    }\n    var childOb = !shallow && observe(val, false, mock);\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: function reactiveGetter() {\n            var value = getter ? getter.call(obj) : val;\n            if (Dep.target) {\n                if (process.env.NODE_ENV !== 'production') {\n                    dep.depend({\n                        target: obj,\n                        type: \"get\" /* TrackOpTypes.GET */,\n                        key: key\n                    });\n                }\n                else {\n                    dep.depend();\n                }\n                if (childOb) {\n                    childOb.dep.depend();\n                    if (isArray(value)) {\n                        dependArray(value);\n                    }\n                }\n            }\n            return isRef(value) && !shallow ? value.value : value;\n        },\n        set: function reactiveSetter(newVal) {\n            var value = getter ? getter.call(obj) : val;\n            if (!hasChanged(value, newVal)) {\n                return;\n            }\n            if (process.env.NODE_ENV !== 'production' && customSetter) {\n                customSetter();\n            }\n            if (setter) {\n                setter.call(obj, newVal);\n            }\n            else if (getter) {\n                // #7981: for accessor properties without setter\n                return;\n            }\n            else if (!shallow && isRef(value) && !isRef(newVal)) {\n                value.value = newVal;\n                return;\n            }\n            else {\n                val = newVal;\n            }\n            childOb = !shallow && observe(newVal, false, mock);\n            if (process.env.NODE_ENV !== 'production') {\n                dep.notify({\n                    type: \"set\" /* TriggerOpTypes.SET */,\n                    target: obj,\n                    key: key,\n                    newValue: newVal,\n                    oldValue: value\n                });\n            }\n            else {\n                dep.notify();\n            }\n        }\n    });\n    return dep;\n}\nfunction set(target, key, val) {\n    if (process.env.NODE_ENV !== 'production' && (isUndef(target) || isPrimitive(target))) {\n        warn(\"Cannot set reactive property on undefined, null, or primitive value: \".concat(target));\n    }\n    if (isReadonly(target)) {\n        process.env.NODE_ENV !== 'production' && warn(\"Set operation on key \\\"\".concat(key, \"\\\" failed: target is readonly.\"));\n        return;\n    }\n    var ob = target.__ob__;\n    if (isArray(target) && isValidArrayIndex(key)) {\n        target.length = Math.max(target.length, key);\n        target.splice(key, 1, val);\n        // when mocking for SSR, array methods are not hijacked\n        if (ob && !ob.shallow && ob.mock) {\n            observe(val, false, true);\n        }\n        return val;\n    }\n    if (key in target && !(key in Object.prototype)) {\n        target[key] = val;\n        return val;\n    }\n    if (target._isVue || (ob && ob.vmCount)) {\n        process.env.NODE_ENV !== 'production' &&\n            warn('Avoid adding reactive properties to a Vue instance or its root $data ' +\n                'at runtime - declare it upfront in the data option.');\n        return val;\n    }\n    if (!ob) {\n        target[key] = val;\n        return val;\n    }\n    defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);\n    if (process.env.NODE_ENV !== 'production') {\n        ob.dep.notify({\n            type: \"add\" /* TriggerOpTypes.ADD */,\n            target: target,\n            key: key,\n            newValue: val,\n            oldValue: undefined\n        });\n    }\n    else {\n        ob.dep.notify();\n    }\n    return val;\n}\nfunction del(target, key) {\n    if (process.env.NODE_ENV !== 'production' && (isUndef(target) || isPrimitive(target))) {\n        warn(\"Cannot delete reactive property on undefined, null, or primitive value: \".concat(target));\n    }\n    if (isArray(target) && isValidArrayIndex(key)) {\n        target.splice(key, 1);\n        return;\n    }\n    var ob = target.__ob__;\n    if (target._isVue || (ob && ob.vmCount)) {\n        process.env.NODE_ENV !== 'production' &&\n            warn('Avoid deleting properties on a Vue instance or its root $data ' +\n                '- just set it to null.');\n        return;\n    }\n    if (isReadonly(target)) {\n        process.env.NODE_ENV !== 'production' &&\n            warn(\"Delete operation on key \\\"\".concat(key, \"\\\" failed: target is readonly.\"));\n        return;\n    }\n    if (!hasOwn(target, key)) {\n        return;\n    }\n    delete target[key];\n    if (!ob) {\n        return;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        ob.dep.notify({\n            type: \"delete\" /* TriggerOpTypes.DELETE */,\n            target: target,\n            key: key\n        });\n    }\n    else {\n        ob.dep.notify();\n    }\n}\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray(value) {\n    for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n        e = value[i];\n        if (e && e.__ob__) {\n            e.__ob__.dep.depend();\n        }\n        if (isArray(e)) {\n            dependArray(e);\n        }\n    }\n}\n\nfunction reactive(target) {\n    makeReactive(target, false);\n    return target;\n}\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nfunction shallowReactive(target) {\n    makeReactive(target, true);\n    def(target, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, true);\n    return target;\n}\nfunction makeReactive(target, shallow) {\n    // if trying to observe a readonly proxy, return the readonly version.\n    if (!isReadonly(target)) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (isArray(target)) {\n                warn(\"Avoid using Array as root value for \".concat(shallow ? \"shallowReactive()\" : \"reactive()\", \" as it cannot be tracked in watch() or watchEffect(). Use \").concat(shallow ? \"shallowRef()\" : \"ref()\", \" instead. This is a Vue-2-only limitation.\"));\n            }\n            var existingOb = target && target.__ob__;\n            if (existingOb && existingOb.shallow !== shallow) {\n                warn(\"Target is already a \".concat(existingOb.shallow ? \"\" : \"non-\", \"shallow reactive object, and cannot be converted to \").concat(shallow ? \"\" : \"non-\", \"shallow.\"));\n            }\n        }\n        var ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);\n        if (process.env.NODE_ENV !== 'production' && !ob) {\n            if (target == null || isPrimitive(target)) {\n                warn(\"value cannot be made reactive: \".concat(String(target)));\n            }\n            if (isCollectionType(target)) {\n                warn(\"Vue 2 does not support reactive collection types such as Map or Set.\");\n            }\n        }\n    }\n}\nfunction isReactive(value) {\n    if (isReadonly(value)) {\n        return isReactive(value[\"__v_raw\" /* ReactiveFlags.RAW */]);\n    }\n    return !!(value && value.__ob__);\n}\nfunction isShallow(value) {\n    return !!(value && value.__v_isShallow);\n}\nfunction isReadonly(value) {\n    return !!(value && value.__v_isReadonly);\n}\nfunction isProxy(value) {\n    return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n    var raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n    return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n    // non-extensible objects won't be observed anyway\n    if (Object.isExtensible(value)) {\n        def(value, \"__v_skip\" /* ReactiveFlags.SKIP */, true);\n    }\n    return value;\n}\n/**\n * @internal\n */\nfunction isCollectionType(value) {\n    var type = toRawType(value);\n    return (type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet');\n}\n\n/**\n * @internal\n */\nvar RefFlag = \"__v_isRef\";\nfunction isRef(r) {\n    return !!(r && r.__v_isRef === true);\n}\nfunction ref$1(value) {\n    return createRef(value, false);\n}\nfunction shallowRef(value) {\n    return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n    if (isRef(rawValue)) {\n        return rawValue;\n    }\n    var ref = {};\n    def(ref, RefFlag, true);\n    def(ref, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, shallow);\n    def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));\n    return ref;\n}\nfunction triggerRef(ref) {\n    if (process.env.NODE_ENV !== 'production' && !ref.dep) {\n        warn(\"received object is not a triggerable ref.\");\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        ref.dep &&\n            ref.dep.notify({\n                type: \"set\" /* TriggerOpTypes.SET */,\n                target: ref,\n                key: 'value'\n            });\n    }\n    else {\n        ref.dep && ref.dep.notify();\n    }\n}\nfunction unref(ref) {\n    return isRef(ref) ? ref.value : ref;\n}\nfunction proxyRefs(objectWithRefs) {\n    if (isReactive(objectWithRefs)) {\n        return objectWithRefs;\n    }\n    var proxy = {};\n    var keys = Object.keys(objectWithRefs);\n    for (var i = 0; i < keys.length; i++) {\n        proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);\n    }\n    return proxy;\n}\nfunction proxyWithRefUnwrap(target, source, key) {\n    Object.defineProperty(target, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            var val = source[key];\n            if (isRef(val)) {\n                return val.value;\n            }\n            else {\n                var ob = val && val.__ob__;\n                if (ob)\n                    ob.dep.depend();\n                return val;\n            }\n        },\n        set: function (value) {\n            var oldValue = source[key];\n            if (isRef(oldValue) && !isRef(value)) {\n                oldValue.value = value;\n            }\n            else {\n                source[key] = value;\n            }\n        }\n    });\n}\nfunction customRef(factory) {\n    var dep = new Dep();\n    var _a = factory(function () {\n        if (process.env.NODE_ENV !== 'production') {\n            dep.depend({\n                target: ref,\n                type: \"get\" /* TrackOpTypes.GET */,\n                key: 'value'\n            });\n        }\n        else {\n            dep.depend();\n        }\n    }, function () {\n        if (process.env.NODE_ENV !== 'production') {\n            dep.notify({\n                target: ref,\n                type: \"set\" /* TriggerOpTypes.SET */,\n                key: 'value'\n            });\n        }\n        else {\n            dep.notify();\n        }\n    }), get = _a.get, set = _a.set;\n    var ref = {\n        get value() {\n            return get();\n        },\n        set value(newVal) {\n            set(newVal);\n        }\n    };\n    def(ref, RefFlag, true);\n    return ref;\n}\nfunction toRefs(object) {\n    if (process.env.NODE_ENV !== 'production' && !isReactive(object)) {\n        warn(\"toRefs() expects a reactive object but received a plain one.\");\n    }\n    var ret = isArray(object) ? new Array(object.length) : {};\n    for (var key in object) {\n        ret[key] = toRef(object, key);\n    }\n    return ret;\n}\nfunction toRef(object, key, defaultValue) {\n    var val = object[key];\n    if (isRef(val)) {\n        return val;\n    }\n    var ref = {\n        get value() {\n            var val = object[key];\n            return val === undefined ? defaultValue : val;\n        },\n        set value(newVal) {\n            object[key] = newVal;\n        }\n    };\n    def(ref, RefFlag, true);\n    return ref;\n}\n\nvar rawToReadonlyFlag = \"__v_rawToReadonly\";\nvar rawToShallowReadonlyFlag = \"__v_rawToShallowReadonly\";\nfunction readonly(target) {\n    return createReadonly(target, false);\n}\nfunction createReadonly(target, shallow) {\n    if (!isPlainObject(target)) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (isArray(target)) {\n                warn(\"Vue 2 does not support readonly arrays.\");\n            }\n            else if (isCollectionType(target)) {\n                warn(\"Vue 2 does not support readonly collection types such as Map or Set.\");\n            }\n            else {\n                warn(\"value cannot be made readonly: \".concat(typeof target));\n            }\n        }\n        return target;\n    }\n    if (process.env.NODE_ENV !== 'production' && !Object.isExtensible(target)) {\n        warn(\"Vue 2 does not support creating readonly proxy for non-extensible object.\");\n    }\n    // already a readonly object\n    if (isReadonly(target)) {\n        return target;\n    }\n    // already has a readonly proxy\n    var existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;\n    var existingProxy = target[existingFlag];\n    if (existingProxy) {\n        return existingProxy;\n    }\n    var proxy = Object.create(Object.getPrototypeOf(target));\n    def(target, existingFlag, proxy);\n    def(proxy, \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */, true);\n    def(proxy, \"__v_raw\" /* ReactiveFlags.RAW */, target);\n    if (isRef(target)) {\n        def(proxy, RefFlag, true);\n    }\n    if (shallow || isShallow(target)) {\n        def(proxy, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, true);\n    }\n    var keys = Object.keys(target);\n    for (var i = 0; i < keys.length; i++) {\n        defineReadonlyProperty(proxy, target, keys[i], shallow);\n    }\n    return proxy;\n}\nfunction defineReadonlyProperty(proxy, target, key, shallow) {\n    Object.defineProperty(proxy, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            var val = target[key];\n            return shallow || !isPlainObject(val) ? val : readonly(val);\n        },\n        set: function () {\n            process.env.NODE_ENV !== 'production' &&\n                warn(\"Set operation on key \\\"\".concat(key, \"\\\" failed: target is readonly.\"));\n        }\n    });\n}\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nfunction shallowReadonly(target) {\n    return createReadonly(target, true);\n}\n\nfunction computed(getterOrOptions, debugOptions) {\n    var getter;\n    var setter;\n    var onlyGetter = isFunction(getterOrOptions);\n    if (onlyGetter) {\n        getter = getterOrOptions;\n        setter = process.env.NODE_ENV !== 'production'\n            ? function () {\n                warn('Write operation failed: computed value is readonly');\n            }\n            : noop;\n    }\n    else {\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set;\n    }\n    var watcher = isServerRendering()\n        ? null\n        : new Watcher(currentInstance, getter, noop, { lazy: true });\n    if (process.env.NODE_ENV !== 'production' && watcher && debugOptions) {\n        watcher.onTrack = debugOptions.onTrack;\n        watcher.onTrigger = debugOptions.onTrigger;\n    }\n    var ref = {\n        // some libs rely on the presence effect for checking computed refs\n        // from normal refs, but the implementation doesn't matter\n        effect: watcher,\n        get value() {\n            if (watcher) {\n                if (watcher.dirty) {\n                    watcher.evaluate();\n                }\n                if (Dep.target) {\n                    if (process.env.NODE_ENV !== 'production' && Dep.target.onTrack) {\n                        Dep.target.onTrack({\n                            effect: Dep.target,\n                            target: ref,\n                            type: \"get\" /* TrackOpTypes.GET */,\n                            key: 'value'\n                        });\n                    }\n                    watcher.depend();\n                }\n                return watcher.value;\n            }\n            else {\n                return getter();\n            }\n        },\n        set value(newVal) {\n            setter(newVal);\n        }\n    };\n    def(ref, RefFlag, true);\n    def(ref, \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */, onlyGetter);\n    return ref;\n}\n\nvar WATCHER = \"watcher\";\nvar WATCHER_CB = \"\".concat(WATCHER, \" callback\");\nvar WATCHER_GETTER = \"\".concat(WATCHER, \" getter\");\nvar WATCHER_CLEANUP = \"\".concat(WATCHER, \" cleanup\");\n// Simple effect.\nfunction watchEffect(effect, options) {\n    return doWatch(effect, null, options);\n}\nfunction watchPostEffect(effect, options) {\n    return doWatch(effect, null, (process.env.NODE_ENV !== 'production'\n        ? __assign(__assign({}, options), { flush: 'post' }) : { flush: 'post' }));\n}\nfunction watchSyncEffect(effect, options) {\n    return doWatch(effect, null, (process.env.NODE_ENV !== 'production'\n        ? __assign(__assign({}, options), { flush: 'sync' }) : { flush: 'sync' }));\n}\n// initial value for watchers to trigger on undefined initial values\nvar INITIAL_WATCHER_VALUE = {};\n// implementation\nfunction watch(source, cb, options) {\n    if (process.env.NODE_ENV !== 'production' && typeof cb !== 'function') {\n        warn(\"`watch(fn, options?)` signature has been moved to a separate API. \" +\n            \"Use `watchEffect(fn, options?)` instead. `watch` now only \" +\n            \"supports `watch(source, cb, options?) signature.\");\n    }\n    return doWatch(source, cb, options);\n}\nfunction doWatch(source, cb, _a) {\n    var _b = _a === void 0 ? emptyObject : _a, immediate = _b.immediate, deep = _b.deep, _c = _b.flush, flush = _c === void 0 ? 'pre' : _c, onTrack = _b.onTrack, onTrigger = _b.onTrigger;\n    if (process.env.NODE_ENV !== 'production' && !cb) {\n        if (immediate !== undefined) {\n            warn(\"watch() \\\"immediate\\\" option is only respected when using the \" +\n                \"watch(source, callback, options?) signature.\");\n        }\n        if (deep !== undefined) {\n            warn(\"watch() \\\"deep\\\" option is only respected when using the \" +\n                \"watch(source, callback, options?) signature.\");\n        }\n    }\n    var warnInvalidSource = function (s) {\n        warn(\"Invalid watch source: \".concat(s, \". A watch source can only be a getter/effect \") +\n            \"function, a ref, a reactive object, or an array of these types.\");\n    };\n    var instance = currentInstance;\n    var call = function (fn, type, args) {\n        if (args === void 0) { args = null; }\n        return invokeWithErrorHandling(fn, null, args, instance, type);\n    };\n    var getter;\n    var forceTrigger = false;\n    var isMultiSource = false;\n    if (isRef(source)) {\n        getter = function () { return source.value; };\n        forceTrigger = isShallow(source);\n    }\n    else if (isReactive(source)) {\n        getter = function () {\n            source.__ob__.dep.depend();\n            return source;\n        };\n        deep = true;\n    }\n    else if (isArray(source)) {\n        isMultiSource = true;\n        forceTrigger = source.some(function (s) { return isReactive(s) || isShallow(s); });\n        getter = function () {\n            return source.map(function (s) {\n                if (isRef(s)) {\n                    return s.value;\n                }\n                else if (isReactive(s)) {\n                    return traverse(s);\n                }\n                else if (isFunction(s)) {\n                    return call(s, WATCHER_GETTER);\n                }\n                else {\n                    process.env.NODE_ENV !== 'production' && warnInvalidSource(s);\n                }\n            });\n        };\n    }\n    else if (isFunction(source)) {\n        if (cb) {\n            // getter with cb\n            getter = function () { return call(source, WATCHER_GETTER); };\n        }\n        else {\n            // no cb -> simple effect\n            getter = function () {\n                if (instance && instance._isDestroyed) {\n                    return;\n                }\n                if (cleanup) {\n                    cleanup();\n                }\n                return call(source, WATCHER, [onCleanup]);\n            };\n        }\n    }\n    else {\n        getter = noop;\n        process.env.NODE_ENV !== 'production' && warnInvalidSource(source);\n    }\n    if (cb && deep) {\n        var baseGetter_1 = getter;\n        getter = function () { return traverse(baseGetter_1()); };\n    }\n    var cleanup;\n    var onCleanup = function (fn) {\n        cleanup = watcher.onStop = function () {\n            call(fn, WATCHER_CLEANUP);\n        };\n    };\n    // in SSR there is no need to setup an actual effect, and it should be noop\n    // unless it's eager\n    if (isServerRendering()) {\n        // we will also not call the invalidate callback (+ runner is not set up)\n        onCleanup = noop;\n        if (!cb) {\n            getter();\n        }\n        else if (immediate) {\n            call(cb, WATCHER_CB, [\n                getter(),\n                isMultiSource ? [] : undefined,\n                onCleanup\n            ]);\n        }\n        return noop;\n    }\n    var watcher = new Watcher(currentInstance, getter, noop, {\n        lazy: true\n    });\n    watcher.noRecurse = !cb;\n    var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;\n    // overwrite default run\n    watcher.run = function () {\n        if (!watcher.active) {\n            return;\n        }\n        if (cb) {\n            // watch(source, cb)\n            var newValue = watcher.get();\n            if (deep ||\n                forceTrigger ||\n                (isMultiSource\n                    ? newValue.some(function (v, i) {\n                        return hasChanged(v, oldValue[i]);\n                    })\n                    : hasChanged(newValue, oldValue))) {\n                // cleanup before running cb again\n                if (cleanup) {\n                    cleanup();\n                }\n                call(cb, WATCHER_CB, [\n                    newValue,\n                    // pass undefined as the old value when it's changed for the first time\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\n                    onCleanup\n                ]);\n                oldValue = newValue;\n            }\n        }\n        else {\n            // watchEffect\n            watcher.get();\n        }\n    };\n    if (flush === 'sync') {\n        watcher.update = watcher.run;\n    }\n    else if (flush === 'post') {\n        watcher.post = true;\n        watcher.update = function () { return queueWatcher(watcher); };\n    }\n    else {\n        // pre\n        watcher.update = function () {\n            if (instance && instance === currentInstance && !instance._isMounted) {\n                // pre-watcher triggered before\n                var buffer = instance._preWatchers || (instance._preWatchers = []);\n                if (buffer.indexOf(watcher) < 0)\n                    buffer.push(watcher);\n            }\n            else {\n                queueWatcher(watcher);\n            }\n        };\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        watcher.onTrack = onTrack;\n        watcher.onTrigger = onTrigger;\n    }\n    // initial run\n    if (cb) {\n        if (immediate) {\n            watcher.run();\n        }\n        else {\n            oldValue = watcher.get();\n        }\n    }\n    else if (flush === 'post' && instance) {\n        instance.$once('hook:mounted', function () { return watcher.get(); });\n    }\n    else {\n        watcher.get();\n    }\n    return function () {\n        watcher.teardown();\n    };\n}\n\nvar activeEffectScope;\nvar EffectScope = /** @class */ (function () {\n    function EffectScope(detached) {\n        if (detached === void 0) { detached = false; }\n        this.detached = detached;\n        /**\n         * @internal\n         */\n        this.active = true;\n        /**\n         * @internal\n         */\n        this.effects = [];\n        /**\n         * @internal\n         */\n        this.cleanups = [];\n        this.parent = activeEffectScope;\n        if (!detached && activeEffectScope) {\n            this.index =\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n        }\n    }\n    EffectScope.prototype.run = function (fn) {\n        if (this.active) {\n            var currentEffectScope = activeEffectScope;\n            try {\n                activeEffectScope = this;\n                return fn();\n            }\n            finally {\n                activeEffectScope = currentEffectScope;\n            }\n        }\n        else if (process.env.NODE_ENV !== 'production') {\n            warn(\"cannot run an inactive effect scope.\");\n        }\n    };\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    EffectScope.prototype.on = function () {\n        activeEffectScope = this;\n    };\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    EffectScope.prototype.off = function () {\n        activeEffectScope = this.parent;\n    };\n    EffectScope.prototype.stop = function (fromParent) {\n        if (this.active) {\n            var i = void 0, l = void 0;\n            for (i = 0, l = this.effects.length; i < l; i++) {\n                this.effects[i].teardown();\n            }\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\n                this.cleanups[i]();\n            }\n            if (this.scopes) {\n                for (i = 0, l = this.scopes.length; i < l; i++) {\n                    this.scopes[i].stop(true);\n                }\n            }\n            // nested scope, dereference from parent to avoid memory leaks\n            if (!this.detached && this.parent && !fromParent) {\n                // optimized O(1) removal\n                var last = this.parent.scopes.pop();\n                if (last && last !== this) {\n                    this.parent.scopes[this.index] = last;\n                    last.index = this.index;\n                }\n            }\n            this.parent = undefined;\n            this.active = false;\n        }\n    };\n    return EffectScope;\n}());\nfunction effectScope(detached) {\n    return new EffectScope(detached);\n}\n/**\n * @internal\n */\nfunction recordEffectScope(effect, scope) {\n    if (scope === void 0) { scope = activeEffectScope; }\n    if (scope && scope.active) {\n        scope.effects.push(effect);\n    }\n}\nfunction getCurrentScope() {\n    return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n    if (activeEffectScope) {\n        activeEffectScope.cleanups.push(fn);\n    }\n    else if (process.env.NODE_ENV !== 'production') {\n        warn(\"onScopeDispose() is called when there is no active effect scope\" +\n            \" to be associated with.\");\n    }\n}\n\nfunction provide(key, value) {\n    if (!currentInstance) {\n        if (process.env.NODE_ENV !== 'production') {\n            warn(\"provide() can only be used inside setup().\");\n        }\n    }\n    else {\n        // TS doesn't allow symbol as index type\n        resolveProvided(currentInstance)[key] = value;\n    }\n}\nfunction resolveProvided(vm) {\n    // by default an instance inherits its parent's provides object\n    // but when it needs to provide values of its own, it creates its\n    // own provides object using parent provides object as prototype.\n    // this way in `inject` we can simply look up injections from direct\n    // parent and let the prototype chain do the work.\n    var existing = vm._provided;\n    var parentProvides = vm.$parent && vm.$parent._provided;\n    if (parentProvides === existing) {\n        return (vm._provided = Object.create(parentProvides));\n    }\n    else {\n        return existing;\n    }\n}\nfunction inject(key, defaultValue, treatDefaultAsFactory) {\n    if (treatDefaultAsFactory === void 0) { treatDefaultAsFactory = false; }\n    // fallback to `currentRenderingInstance` so that this can be called in\n    // a functional component\n    var instance = currentInstance;\n    if (instance) {\n        // #2400\n        // to support `app.use` plugins,\n        // fallback to appContext's `provides` if the instance is at root\n        var provides = instance.$parent && instance.$parent._provided;\n        if (provides && key in provides) {\n            // TS doesn't allow symbol as index type\n            return provides[key];\n        }\n        else if (arguments.length > 1) {\n            return treatDefaultAsFactory && isFunction(defaultValue)\n                ? defaultValue.call(instance)\n                : defaultValue;\n        }\n        else if (process.env.NODE_ENV !== 'production') {\n            warn(\"injection \\\"\".concat(String(key), \"\\\" not found.\"));\n        }\n    }\n    else if (process.env.NODE_ENV !== 'production') {\n        warn(\"inject() can only be used inside setup() or functional components.\");\n    }\n}\n\nvar normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once = name.charAt(0) === '~'; // Prefixed last, checked first\n    name = once ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n        name: name,\n        once: once,\n        capture: capture,\n        passive: passive\n    };\n});\nfunction createFnInvoker(fns, vm) {\n    function invoker() {\n        var fns = invoker.fns;\n        if (isArray(fns)) {\n            var cloned = fns.slice();\n            for (var i = 0; i < cloned.length; i++) {\n                invokeWithErrorHandling(cloned[i], null, arguments, vm, \"v-on handler\");\n            }\n        }\n        else {\n            // return handler return value for single handlers\n            return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\");\n        }\n    }\n    invoker.fns = fns;\n    return invoker;\n}\nfunction updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {\n    var name, cur, old, event;\n    for (name in on) {\n        cur = on[name];\n        old = oldOn[name];\n        event = normalizeEvent(name);\n        if (isUndef(cur)) {\n            process.env.NODE_ENV !== 'production' &&\n                warn(\"Invalid handler for event \\\"\".concat(event.name, \"\\\": got \") + String(cur), vm);\n        }\n        else if (isUndef(old)) {\n            if (isUndef(cur.fns)) {\n                cur = on[name] = createFnInvoker(cur, vm);\n            }\n            if (isTrue(event.once)) {\n                cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n            }\n            add(event.name, cur, event.capture, event.passive, event.params);\n        }\n        else if (cur !== old) {\n            old.fns = cur;\n            on[name] = old;\n        }\n    }\n    for (name in oldOn) {\n        if (isUndef(on[name])) {\n            event = normalizeEvent(name);\n            remove(event.name, oldOn[name], event.capture);\n        }\n    }\n}\n\nfunction mergeVNodeHook(def, hookKey, hook) {\n    if (def instanceof VNode) {\n        def = def.data.hook || (def.data.hook = {});\n    }\n    var invoker;\n    var oldHook = def[hookKey];\n    function wrappedHook() {\n        hook.apply(this, arguments);\n        // important: remove merged hook to ensure it's called only once\n        // and prevent memory leak\n        remove$2(invoker.fns, wrappedHook);\n    }\n    if (isUndef(oldHook)) {\n        // no existing hook\n        invoker = createFnInvoker([wrappedHook]);\n    }\n    else {\n        /* istanbul ignore if */\n        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n            // already a merged invoker\n            invoker = oldHook;\n            invoker.fns.push(wrappedHook);\n        }\n        else {\n            // existing plain hook\n            invoker = createFnInvoker([oldHook, wrappedHook]);\n        }\n    }\n    invoker.merged = true;\n    def[hookKey] = invoker;\n}\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n    if (isUndef(propOptions)) {\n        return;\n    }\n    var res = {};\n    var attrs = data.attrs, props = data.props;\n    if (isDef(attrs) || isDef(props)) {\n        for (var key in propOptions) {\n            var altKey = hyphenate(key);\n            if (process.env.NODE_ENV !== 'production') {\n                var keyInLowerCase = key.toLowerCase();\n                if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n                    tip(\"Prop \\\"\".concat(keyInLowerCase, \"\\\" is passed to component \") +\n                        \"\".concat(formatComponentName(\n                        // @ts-expect-error tag is string\n                        tag || Ctor), \", but the declared prop name is\") +\n                        \" \\\"\".concat(key, \"\\\". \") +\n                        \"Note that HTML attributes are case-insensitive and camelCased \" +\n                        \"props need to use their kebab-case equivalents when using in-DOM \" +\n                        \"templates. You should probably use \\\"\".concat(altKey, \"\\\" instead of \\\"\").concat(key, \"\\\".\"));\n                }\n            }\n            checkProp(res, props, key, altKey, true) ||\n                checkProp(res, attrs, key, altKey, false);\n        }\n    }\n    return res;\n}\nfunction checkProp(res, hash, key, altKey, preserve) {\n    if (isDef(hash)) {\n        if (hasOwn(hash, key)) {\n            res[key] = hash[key];\n            if (!preserve) {\n                delete hash[key];\n            }\n            return true;\n        }\n        else if (hasOwn(hash, altKey)) {\n            res[key] = hash[altKey];\n            if (!preserve) {\n                delete hash[altKey];\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren(children) {\n    for (var i = 0; i < children.length; i++) {\n        if (isArray(children[i])) {\n            return Array.prototype.concat.apply([], children);\n        }\n    }\n    return children;\n}\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren(children) {\n    return isPrimitive(children)\n        ? [createTextVNode(children)]\n        : isArray(children)\n            ? normalizeArrayChildren(children)\n            : undefined;\n}\nfunction isTextNode(node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n}\nfunction normalizeArrayChildren(children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n    for (i = 0; i < children.length; i++) {\n        c = children[i];\n        if (isUndef(c) || typeof c === 'boolean')\n            continue;\n        lastIndex = res.length - 1;\n        last = res[lastIndex];\n        //  nested\n        if (isArray(c)) {\n            if (c.length > 0) {\n                c = normalizeArrayChildren(c, \"\".concat(nestedIndex || '', \"_\").concat(i));\n                // merge adjacent text nodes\n                if (isTextNode(c[0]) && isTextNode(last)) {\n                    res[lastIndex] = createTextVNode(last.text + c[0].text);\n                    c.shift();\n                }\n                res.push.apply(res, c);\n            }\n        }\n        else if (isPrimitive(c)) {\n            if (isTextNode(last)) {\n                // merge adjacent text nodes\n                // this is necessary for SSR hydration because text nodes are\n                // essentially merged when rendered to HTML strings\n                res[lastIndex] = createTextVNode(last.text + c);\n            }\n            else if (c !== '') {\n                // convert primitive to vnode\n                res.push(createTextVNode(c));\n            }\n        }\n        else {\n            if (isTextNode(c) && isTextNode(last)) {\n                // merge adjacent text nodes\n                res[lastIndex] = createTextVNode(last.text + c.text);\n            }\n            else {\n                // default key for nested array children (likely generated by v-for)\n                if (isTrue(children._isVList) &&\n                    isDef(c.tag) &&\n                    isUndef(c.key) &&\n                    isDef(nestedIndex)) {\n                    c.key = \"__vlist\".concat(nestedIndex, \"_\").concat(i, \"__\");\n                }\n                res.push(c);\n            }\n        }\n    }\n    return res;\n}\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList(val, render) {\n    var ret = null, i, l, keys, key;\n    if (isArray(val) || typeof val === 'string') {\n        ret = new Array(val.length);\n        for (i = 0, l = val.length; i < l; i++) {\n            ret[i] = render(val[i], i);\n        }\n    }\n    else if (typeof val === 'number') {\n        ret = new Array(val);\n        for (i = 0; i < val; i++) {\n            ret[i] = render(i + 1, i);\n        }\n    }\n    else if (isObject(val)) {\n        if (hasSymbol && val[Symbol.iterator]) {\n            ret = [];\n            var iterator = val[Symbol.iterator]();\n            var result = iterator.next();\n            while (!result.done) {\n                ret.push(render(result.value, ret.length));\n                result = iterator.next();\n            }\n        }\n        else {\n            keys = Object.keys(val);\n            ret = new Array(keys.length);\n            for (i = 0, l = keys.length; i < l; i++) {\n                key = keys[i];\n                ret[i] = render(val[key], key, i);\n            }\n        }\n    }\n    if (!isDef(ret)) {\n        ret = [];\n    }\n    ret._isVList = true;\n    return ret;\n}\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot(name, fallbackRender, props, bindObject) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n    if (scopedSlotFn) {\n        // scoped slot\n        props = props || {};\n        if (bindObject) {\n            if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {\n                warn('slot v-bind without argument expects an Object', this);\n            }\n            props = extend(extend({}, bindObject), props);\n        }\n        nodes =\n            scopedSlotFn(props) ||\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\n    }\n    else {\n        nodes =\n            this.$slots[name] ||\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\n    }\n    var target = props && props.slot;\n    if (target) {\n        return this.$createElement('template', { slot: target }, nodes);\n    }\n    else {\n        return nodes;\n    }\n}\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter(id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\n}\n\nfunction isKeyNotMatch(expect, actual) {\n    if (isArray(expect)) {\n        return expect.indexOf(actual) === -1;\n    }\n    else {\n        return expect !== actual;\n    }\n}\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n        return isKeyNotMatch(builtInKeyName, eventKeyName);\n    }\n    else if (mappedKeyCode) {\n        return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n    }\n    else if (eventKeyName) {\n        return hyphenate(eventKeyName) !== key;\n    }\n    return eventKeyCode === undefined;\n}\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps(data, tag, value, asProp, isSync) {\n    if (value) {\n        if (!isObject(value)) {\n            process.env.NODE_ENV !== 'production' &&\n                warn('v-bind without argument expects an Object or Array value', this);\n        }\n        else {\n            if (isArray(value)) {\n                value = toObject(value);\n            }\n            var hash = void 0;\n            var _loop_1 = function (key) {\n                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n                    hash = data;\n                }\n                else {\n                    var type = data.attrs && data.attrs.type;\n                    hash =\n                        asProp || config.mustUseProp(tag, type, key)\n                            ? data.domProps || (data.domProps = {})\n                            : data.attrs || (data.attrs = {});\n                }\n                var camelizedKey = camelize(key);\n                var hyphenatedKey = hyphenate(key);\n                if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n                    hash[key] = value[key];\n                    if (isSync) {\n                        var on = data.on || (data.on = {});\n                        on[\"update:\".concat(key)] = function ($event) {\n                            value[key] = $event;\n                        };\n                    }\n                }\n            };\n            for (var key in value) {\n                _loop_1(key);\n            }\n        }\n    }\n    return data;\n}\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic(index, isInFor) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n    if (tree && !isInFor) {\n        return tree;\n    }\n    // otherwise, render a fresh tree.\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates\n    );\n    markStatic(tree, \"__static__\".concat(index), false);\n    return tree;\n}\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce(tree, index, key) {\n    markStatic(tree, \"__once__\".concat(index).concat(key ? \"_\".concat(key) : \"\"), true);\n    return tree;\n}\nfunction markStatic(tree, key, isOnce) {\n    if (isArray(tree)) {\n        for (var i = 0; i < tree.length; i++) {\n            if (tree[i] && typeof tree[i] !== 'string') {\n                markStaticNode(tree[i], \"\".concat(key, \"_\").concat(i), isOnce);\n            }\n        }\n    }\n    else {\n        markStaticNode(tree, key, isOnce);\n    }\n}\nfunction markStaticNode(node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n}\n\nfunction bindObjectListeners(data, value) {\n    if (value) {\n        if (!isPlainObject(value)) {\n            process.env.NODE_ENV !== 'production' && warn('v-on without argument expects an Object value', this);\n        }\n        else {\n            var on = (data.on = data.on ? extend({}, data.on) : {});\n            for (var key in value) {\n                var existing = on[key];\n                var ours = value[key];\n                on[key] = existing ? [].concat(existing, ours) : ours;\n            }\n        }\n    }\n    return data;\n}\n\nfunction resolveScopedSlots(fns, res, \n// the following are added in 2.6\nhasDynamicKeys, contentHashKey) {\n    res = res || { $stable: !hasDynamicKeys };\n    for (var i = 0; i < fns.length; i++) {\n        var slot = fns[i];\n        if (isArray(slot)) {\n            resolveScopedSlots(slot, res, hasDynamicKeys);\n        }\n        else if (slot) {\n            // marker for reverse proxying v-slot without scope on this.$slots\n            // @ts-expect-error\n            if (slot.proxy) {\n                // @ts-expect-error\n                slot.fn.proxy = true;\n            }\n            res[slot.key] = slot.fn;\n        }\n    }\n    if (contentHashKey) {\n        res.$key = contentHashKey;\n    }\n    return res;\n}\n\n// helper to process dynamic keys for dynamic arguments in v-bind and v-on.\nfunction bindDynamicKeys(baseObj, values) {\n    for (var i = 0; i < values.length; i += 2) {\n        var key = values[i];\n        if (typeof key === 'string' && key) {\n            baseObj[values[i]] = values[i + 1];\n        }\n        else if (process.env.NODE_ENV !== 'production' && key !== '' && key !== null) {\n            // null is a special value for explicitly removing a binding\n            warn(\"Invalid value for dynamic directive argument (expected string or null): \".concat(key), this);\n        }\n    }\n    return baseObj;\n}\n// helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\nfunction prependModifier(value, symbol) {\n    return typeof value === 'string' ? symbol + value : value;\n}\n\nfunction installRenderHelpers(target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n    target._d = bindDynamicKeys;\n    target._p = prependModifier;\n}\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots(children, context) {\n    if (!children || !children.length) {\n        return {};\n    }\n    var slots = {};\n    for (var i = 0, l = children.length; i < l; i++) {\n        var child = children[i];\n        var data = child.data;\n        // remove slot attribute if the node is resolved as a Vue slot node\n        if (data && data.attrs && data.attrs.slot) {\n            delete data.attrs.slot;\n        }\n        // named slots should only be respected if the vnode was rendered in the\n        // same context.\n        if ((child.context === context || child.fnContext === context) &&\n            data &&\n            data.slot != null) {\n            var name_1 = data.slot;\n            var slot = slots[name_1] || (slots[name_1] = []);\n            if (child.tag === 'template') {\n                slot.push.apply(slot, child.children || []);\n            }\n            else {\n                slot.push(child);\n            }\n        }\n        else {\n            (slots.default || (slots.default = [])).push(child);\n        }\n    }\n    // ignore slots that contains only whitespace\n    for (var name_2 in slots) {\n        if (slots[name_2].every(isWhitespace)) {\n            delete slots[name_2];\n        }\n    }\n    return slots;\n}\nfunction isWhitespace(node) {\n    return (node.isComment && !node.asyncFactory) || node.text === ' ';\n}\n\nfunction isAsyncPlaceholder(node) {\n    // @ts-expect-error not really boolean type\n    return node.isComment && node.asyncFactory;\n}\n\nfunction normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {\n    var res;\n    var hasNormalSlots = Object.keys(normalSlots).length > 0;\n    var isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;\n    var key = scopedSlots && scopedSlots.$key;\n    if (!scopedSlots) {\n        res = {};\n    }\n    else if (scopedSlots._normalized) {\n        // fast path 1: child component re-render only, parent did not change\n        return scopedSlots._normalized;\n    }\n    else if (isStable &&\n        prevScopedSlots &&\n        prevScopedSlots !== emptyObject &&\n        key === prevScopedSlots.$key &&\n        !hasNormalSlots &&\n        !prevScopedSlots.$hasNormal) {\n        // fast path 2: stable scoped slots w/ no normal slots to proxy,\n        // only need to normalize once\n        return prevScopedSlots;\n    }\n    else {\n        res = {};\n        for (var key_1 in scopedSlots) {\n            if (scopedSlots[key_1] && key_1[0] !== '$') {\n                res[key_1] = normalizeScopedSlot(ownerVm, normalSlots, key_1, scopedSlots[key_1]);\n            }\n        }\n    }\n    // expose normal slots on scopedSlots\n    for (var key_2 in normalSlots) {\n        if (!(key_2 in res)) {\n            res[key_2] = proxyNormalSlot(normalSlots, key_2);\n        }\n    }\n    // avoriaz seems to mock a non-extensible $scopedSlots object\n    // and when that is passed down this would cause an error\n    if (scopedSlots && Object.isExtensible(scopedSlots)) {\n        scopedSlots._normalized = res;\n    }\n    def(res, '$stable', isStable);\n    def(res, '$key', key);\n    def(res, '$hasNormal', hasNormalSlots);\n    return res;\n}\nfunction normalizeScopedSlot(vm, normalSlots, key, fn) {\n    var normalized = function () {\n        var cur = currentInstance;\n        setCurrentInstance(vm);\n        var res = arguments.length ? fn.apply(null, arguments) : fn({});\n        res =\n            res && typeof res === 'object' && !isArray(res)\n                ? [res] // single vnode\n                : normalizeChildren(res);\n        var vnode = res && res[0];\n        setCurrentInstance(cur);\n        return res &&\n            (!vnode ||\n                (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode))) // #9658, #10391\n            ? undefined\n            : res;\n    };\n    // this is a slot using the new v-slot syntax without scope. although it is\n    // compiled as a scoped slot, render fn users would expect it to be present\n    // on this.$slots because the usage is semantically a normal slot.\n    if (fn.proxy) {\n        Object.defineProperty(normalSlots, key, {\n            get: normalized,\n            enumerable: true,\n            configurable: true\n        });\n    }\n    return normalized;\n}\nfunction proxyNormalSlot(slots, key) {\n    return function () { return slots[key]; };\n}\n\nfunction initSetup(vm) {\n    var options = vm.$options;\n    var setup = options.setup;\n    if (setup) {\n        var ctx = (vm._setupContext = createSetupContext(vm));\n        setCurrentInstance(vm);\n        pushTarget();\n        var setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, \"setup\");\n        popTarget();\n        setCurrentInstance();\n        if (isFunction(setupResult)) {\n            // render function\n            // @ts-ignore\n            options.render = setupResult;\n        }\n        else if (isObject(setupResult)) {\n            // bindings\n            if (process.env.NODE_ENV !== 'production' && setupResult instanceof VNode) {\n                warn(\"setup() should not return VNodes directly - \" +\n                    \"return a render function instead.\");\n            }\n            vm._setupState = setupResult;\n            // __sfc indicates compiled bindings from <script setup>\n            if (!setupResult.__sfc) {\n                for (var key in setupResult) {\n                    if (!isReserved(key)) {\n                        proxyWithRefUnwrap(vm, setupResult, key);\n                    }\n                    else if (process.env.NODE_ENV !== 'production') {\n                        warn(\"Avoid using variables that start with _ or $ in setup().\");\n                    }\n                }\n            }\n            else {\n                // exposed for compiled render fn\n                var proxy = (vm._setupProxy = {});\n                for (var key in setupResult) {\n                    if (key !== '__sfc') {\n                        proxyWithRefUnwrap(proxy, setupResult, key);\n                    }\n                }\n            }\n        }\n        else if (process.env.NODE_ENV !== 'production' && setupResult !== undefined) {\n            warn(\"setup() should return an object. Received: \".concat(setupResult === null ? 'null' : typeof setupResult));\n        }\n    }\n}\nfunction createSetupContext(vm) {\n    var exposeCalled = false;\n    return {\n        get attrs() {\n            if (!vm._attrsProxy) {\n                var proxy = (vm._attrsProxy = {});\n                def(proxy, '_v_attr_proxy', true);\n                syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');\n            }\n            return vm._attrsProxy;\n        },\n        get listeners() {\n            if (!vm._listenersProxy) {\n                var proxy = (vm._listenersProxy = {});\n                syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');\n            }\n            return vm._listenersProxy;\n        },\n        get slots() {\n            return initSlotsProxy(vm);\n        },\n        emit: bind(vm.$emit, vm),\n        expose: function (exposed) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (exposeCalled) {\n                    warn(\"expose() should be called only once per setup().\", vm);\n                }\n                exposeCalled = true;\n            }\n            if (exposed) {\n                Object.keys(exposed).forEach(function (key) {\n                    return proxyWithRefUnwrap(vm, exposed, key);\n                });\n            }\n        }\n    };\n}\nfunction syncSetupProxy(to, from, prev, instance, type) {\n    var changed = false;\n    for (var key in from) {\n        if (!(key in to)) {\n            changed = true;\n            defineProxyAttr(to, key, instance, type);\n        }\n        else if (from[key] !== prev[key]) {\n            changed = true;\n        }\n    }\n    for (var key in to) {\n        if (!(key in from)) {\n            changed = true;\n            delete to[key];\n        }\n    }\n    return changed;\n}\nfunction defineProxyAttr(proxy, key, instance, type) {\n    Object.defineProperty(proxy, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            return instance[type][key];\n        }\n    });\n}\nfunction initSlotsProxy(vm) {\n    if (!vm._slotsProxy) {\n        syncSetupSlots((vm._slotsProxy = {}), vm.$scopedSlots);\n    }\n    return vm._slotsProxy;\n}\nfunction syncSetupSlots(to, from) {\n    for (var key in from) {\n        to[key] = from[key];\n    }\n    for (var key in to) {\n        if (!(key in from)) {\n            delete to[key];\n        }\n    }\n}\n/**\n * @internal use manual type def because public setup context type relies on\n * legacy VNode types\n */\nfunction useSlots() {\n    return getContext().slots;\n}\n/**\n * @internal use manual type def because public setup context type relies on\n * legacy VNode types\n */\nfunction useAttrs() {\n    return getContext().attrs;\n}\n/**\n * Vue 2 only\n * @internal use manual type def because public setup context type relies on\n * legacy VNode types\n */\nfunction useListeners() {\n    return getContext().listeners;\n}\nfunction getContext() {\n    if (process.env.NODE_ENV !== 'production' && !currentInstance) {\n        warn(\"useContext() called without active instance.\");\n    }\n    var vm = currentInstance;\n    return vm._setupContext || (vm._setupContext = createSetupContext(vm));\n}\n/**\n * Runtime helper for merging default declarations. Imported by compiled code\n * only.\n * @internal\n */\nfunction mergeDefaults(raw, defaults) {\n    var props = isArray(raw)\n        ? raw.reduce(function (normalized, p) { return ((normalized[p] = {}), normalized); }, {})\n        : raw;\n    for (var key in defaults) {\n        var opt = props[key];\n        if (opt) {\n            if (isArray(opt) || isFunction(opt)) {\n                props[key] = { type: opt, default: defaults[key] };\n            }\n            else {\n                opt.default = defaults[key];\n            }\n        }\n        else if (opt === null) {\n            props[key] = { default: defaults[key] };\n        }\n        else if (process.env.NODE_ENV !== 'production') {\n            warn(\"props default key \\\"\".concat(key, \"\\\" has no corresponding declaration.\"));\n        }\n    }\n    return props;\n}\n\nfunction initRender(vm) {\n    vm._vnode = null; // the root of the child tree\n    vm._staticTrees = null; // v-once cached trees\n    var options = vm.$options;\n    var parentVnode = (vm.$vnode = options._parentVnode); // the placeholder node in parent tree\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = parentVnode\n        ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots)\n        : emptyObject;\n    // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n    // @ts-expect-error\n    vm._c = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, false); };\n    // normalization is always applied for the public version, used in\n    // user-written render functions.\n    // @ts-expect-error\n    vm.$createElement = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, true); };\n    // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n    var parentData = parentVnode && parentVnode.data;\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n        defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, function () {\n            !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n        }, true);\n        defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {\n            !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n        }, true);\n    }\n    else {\n        defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, null, true);\n        defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);\n    }\n}\nvar currentRenderingInstance = null;\nfunction renderMixin(Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n    Vue.prototype.$nextTick = function (fn) {\n        return nextTick(fn, this);\n    };\n    Vue.prototype._render = function () {\n        var vm = this;\n        var _a = vm.$options, render = _a.render, _parentVnode = _a._parentVnode;\n        if (_parentVnode && vm._isMounted) {\n            vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\n            if (vm._slotsProxy) {\n                syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);\n            }\n        }\n        // set parent vnode. this allows render functions to have access\n        // to the data on the placeholder node.\n        vm.$vnode = _parentVnode;\n        // render self\n        var vnode;\n        try {\n            // There's no need to maintain a stack because all render fns are called\n            // separately from one another. Nested component's render fns are called\n            // when parent component is patched.\n            setCurrentInstance(vm);\n            currentRenderingInstance = vm;\n            vnode = render.call(vm._renderProxy, vm.$createElement);\n        }\n        catch (e) {\n            handleError(e, vm, \"render\");\n            // return error render result,\n            // or previous vnode to prevent render error causing blank component\n            /* istanbul ignore else */\n            if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {\n                try {\n                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n                }\n                catch (e) {\n                    handleError(e, vm, \"renderError\");\n                    vnode = vm._vnode;\n                }\n            }\n            else {\n                vnode = vm._vnode;\n            }\n        }\n        finally {\n            currentRenderingInstance = null;\n            setCurrentInstance();\n        }\n        // if the returned array contains only a single node, allow it\n        if (isArray(vnode) && vnode.length === 1) {\n            vnode = vnode[0];\n        }\n        // return empty vnode in case the render function errored out\n        if (!(vnode instanceof VNode)) {\n            if (process.env.NODE_ENV !== 'production' && isArray(vnode)) {\n                warn('Multiple root nodes returned from render function. Render function ' +\n                    'should return a single root node.', vm);\n            }\n            vnode = createEmptyVNode();\n        }\n        // set parent\n        vnode.parent = _parentVnode;\n        return vnode;\n    };\n}\n\nfunction ensureCtor(comp, base) {\n    if (comp.__esModule || (hasSymbol && comp[Symbol.toStringTag] === 'Module')) {\n        comp = comp.default;\n    }\n    return isObject(comp) ? base.extend(comp) : comp;\n}\nfunction createAsyncPlaceholder(factory, data, context, children, tag) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n    return node;\n}\nfunction resolveAsyncComponent(factory, baseCtor) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n        return factory.errorComp;\n    }\n    if (isDef(factory.resolved)) {\n        return factory.resolved;\n    }\n    var owner = currentRenderingInstance;\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n        // already pending\n        factory.owners.push(owner);\n    }\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n        return factory.loadingComp;\n    }\n    if (owner && !isDef(factory.owners)) {\n        var owners_1 = (factory.owners = [owner]);\n        var sync_1 = true;\n        var timerLoading_1 = null;\n        var timerTimeout_1 = null;\n        owner.$on('hook:destroyed', function () { return remove$2(owners_1, owner); });\n        var forceRender_1 = function (renderCompleted) {\n            for (var i = 0, l = owners_1.length; i < l; i++) {\n                owners_1[i].$forceUpdate();\n            }\n            if (renderCompleted) {\n                owners_1.length = 0;\n                if (timerLoading_1 !== null) {\n                    clearTimeout(timerLoading_1);\n                    timerLoading_1 = null;\n                }\n                if (timerTimeout_1 !== null) {\n                    clearTimeout(timerTimeout_1);\n                    timerTimeout_1 = null;\n                }\n            }\n        };\n        var resolve = once(function (res) {\n            // cache resolved\n            factory.resolved = ensureCtor(res, baseCtor);\n            // invoke callbacks only if this is not a synchronous resolve\n            // (async resolves are shimmed as synchronous during SSR)\n            if (!sync_1) {\n                forceRender_1(true);\n            }\n            else {\n                owners_1.length = 0;\n            }\n        });\n        var reject_1 = once(function (reason) {\n            process.env.NODE_ENV !== 'production' &&\n                warn(\"Failed to resolve async component: \".concat(String(factory)) +\n                    (reason ? \"\\nReason: \".concat(reason) : ''));\n            if (isDef(factory.errorComp)) {\n                factory.error = true;\n                forceRender_1(true);\n            }\n        });\n        var res_1 = factory(resolve, reject_1);\n        if (isObject(res_1)) {\n            if (isPromise(res_1)) {\n                // () => Promise\n                if (isUndef(factory.resolved)) {\n                    res_1.then(resolve, reject_1);\n                }\n            }\n            else if (isPromise(res_1.component)) {\n                res_1.component.then(resolve, reject_1);\n                if (isDef(res_1.error)) {\n                    factory.errorComp = ensureCtor(res_1.error, baseCtor);\n                }\n                if (isDef(res_1.loading)) {\n                    factory.loadingComp = ensureCtor(res_1.loading, baseCtor);\n                    if (res_1.delay === 0) {\n                        factory.loading = true;\n                    }\n                    else {\n                        // @ts-expect-error NodeJS timeout type\n                        timerLoading_1 = setTimeout(function () {\n                            timerLoading_1 = null;\n                            if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                                factory.loading = true;\n                                forceRender_1(false);\n                            }\n                        }, res_1.delay || 200);\n                    }\n                }\n                if (isDef(res_1.timeout)) {\n                    // @ts-expect-error NodeJS timeout type\n                    timerTimeout_1 = setTimeout(function () {\n                        timerTimeout_1 = null;\n                        if (isUndef(factory.resolved)) {\n                            reject_1(process.env.NODE_ENV !== 'production' ? \"timeout (\".concat(res_1.timeout, \"ms)\") : null);\n                        }\n                    }, res_1.timeout);\n                }\n            }\n        }\n        sync_1 = false;\n        // return in case resolved synchronously\n        return factory.loading ? factory.loadingComp : factory.resolved;\n    }\n}\n\nfunction getFirstComponentChild(children) {\n    if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n            var c = children[i];\n            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n                return c;\n            }\n        }\n    }\n}\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {\n    if (isArray(data) || isPrimitive(data)) {\n        normalizationType = children;\n        children = data;\n        data = undefined;\n    }\n    if (isTrue(alwaysNormalize)) {\n        normalizationType = ALWAYS_NORMALIZE;\n    }\n    return _createElement(context, tag, data, children, normalizationType);\n}\nfunction _createElement(context, tag, data, children, normalizationType) {\n    if (isDef(data) && isDef(data.__ob__)) {\n        process.env.NODE_ENV !== 'production' &&\n            warn(\"Avoid using observed data object as vnode data: \".concat(JSON.stringify(data), \"\\n\") + 'Always create fresh vnode data objects in each render!', context);\n        return createEmptyVNode();\n    }\n    // object syntax in v-bind\n    if (isDef(data) && isDef(data.is)) {\n        tag = data.is;\n    }\n    if (!tag) {\n        // in case of component :is set to falsy value\n        return createEmptyVNode();\n    }\n    // warn against non-primitive key\n    if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n        warn('Avoid using non-primitive value as key, ' +\n            'use string/number value instead.', context);\n    }\n    // support single function children as default scoped slot\n    if (isArray(children) && isFunction(children[0])) {\n        data = data || {};\n        data.scopedSlots = { default: children[0] };\n        children.length = 0;\n    }\n    if (normalizationType === ALWAYS_NORMALIZE) {\n        children = normalizeChildren(children);\n    }\n    else if (normalizationType === SIMPLE_NORMALIZE) {\n        children = simpleNormalizeChildren(children);\n    }\n    var vnode, ns;\n    if (typeof tag === 'string') {\n        var Ctor = void 0;\n        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n        if (config.isReservedTag(tag)) {\n            // platform built-in elements\n            if (process.env.NODE_ENV !== 'production' &&\n                isDef(data) &&\n                isDef(data.nativeOn) &&\n                data.tag !== 'component') {\n                warn(\"The .native modifier for v-on is only valid on components but it was used on <\".concat(tag, \">.\"), context);\n            }\n            vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n        }\n        else if ((!data || !data.pre) &&\n            isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {\n            // component\n            vnode = createComponent(Ctor, data, context, children, tag);\n        }\n        else {\n            // unknown or unlisted namespaced elements\n            // check at runtime because it may get assigned a namespace when its\n            // parent normalizes children\n            vnode = new VNode(tag, data, children, undefined, undefined, context);\n        }\n    }\n    else {\n        // direct component options / constructor\n        vnode = createComponent(tag, data, context, children);\n    }\n    if (isArray(vnode)) {\n        return vnode;\n    }\n    else if (isDef(vnode)) {\n        if (isDef(ns))\n            applyNS(vnode, ns);\n        if (isDef(data))\n            registerDeepBindings(data);\n        return vnode;\n    }\n    else {\n        return createEmptyVNode();\n    }\n}\nfunction applyNS(vnode, ns, force) {\n    vnode.ns = ns;\n    if (vnode.tag === 'foreignObject') {\n        // use default namespace inside foreignObject\n        ns = undefined;\n        force = true;\n    }\n    if (isDef(vnode.children)) {\n        for (var i = 0, l = vnode.children.length; i < l; i++) {\n            var child = vnode.children[i];\n            if (isDef(child.tag) &&\n                (isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n                applyNS(child, ns, force);\n            }\n        }\n    }\n}\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings(data) {\n    if (isObject(data.style)) {\n        traverse(data.style);\n    }\n    if (isObject(data.class)) {\n        traverse(data.class);\n    }\n}\n\n/**\n * @internal this function needs manual public type declaration because it relies\n * on previously manually authored types from Vue 2\n */\nfunction h(type, props, children) {\n    if (!currentInstance) {\n        process.env.NODE_ENV !== 'production' &&\n            warn(\"globally imported h() can only be invoked when there is an active \" +\n                \"component instance, e.g. synchronously in a component's render or setup function.\");\n    }\n    return createElement$1(currentInstance, type, props, children, 2, true);\n}\n\nfunction handleError(err, vm, info) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    // See: https://github.com/vuejs/vuex/issues/1505\n    pushTarget();\n    try {\n        if (vm) {\n            var cur = vm;\n            while ((cur = cur.$parent)) {\n                var hooks = cur.$options.errorCaptured;\n                if (hooks) {\n                    for (var i = 0; i < hooks.length; i++) {\n                        try {\n                            var capture = hooks[i].call(cur, err, vm, info) === false;\n                            if (capture)\n                                return;\n                        }\n                        catch (e) {\n                            globalHandleError(e, cur, 'errorCaptured hook');\n                        }\n                    }\n                }\n            }\n        }\n        globalHandleError(err, vm, info);\n    }\n    finally {\n        popTarget();\n    }\n}\nfunction invokeWithErrorHandling(handler, context, args, vm, info) {\n    var res;\n    try {\n        res = args ? handler.apply(context, args) : handler.call(context);\n        if (res && !res._isVue && isPromise(res) && !res._handled) {\n            res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n            res._handled = true;\n        }\n    }\n    catch (e) {\n        handleError(e, vm, info);\n    }\n    return res;\n}\nfunction globalHandleError(err, vm, info) {\n    if (config.errorHandler) {\n        try {\n            return config.errorHandler.call(null, err, vm, info);\n        }\n        catch (e) {\n            // if the user intentionally throws the original error in the handler,\n            // do not log it twice\n            if (e !== err) {\n                logError(e, null, 'config.errorHandler');\n            }\n        }\n    }\n    logError(err, vm, info);\n}\nfunction logError(err, vm, info) {\n    if (process.env.NODE_ENV !== 'production') {\n        warn(\"Error in \".concat(info, \": \\\"\").concat(err.toString(), \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n        console.error(err);\n    }\n    else {\n        throw err;\n    }\n}\n\n/* globals MutationObserver */\nvar isUsingMicroTask = false;\nvar callbacks = [];\nvar pending = false;\nfunction flushCallbacks() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n        copies[i]();\n    }\n}\n// Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\nvar timerFunc;\n// The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p_1 = Promise.resolve();\n    timerFunc = function () {\n        p_1.then(flushCallbacks);\n        // In problematic UIWebViews, Promise.then doesn't completely break, but\n        // it can get stuck in a weird state where callbacks are pushed into the\n        // microtask queue but the queue isn't being flushed, until the browser\n        // needs to do some other work, e.g. handle a timer. Therefore we can\n        // \"force\" the microtask queue to be flushed by adding an empty timer.\n        if (isIOS)\n            setTimeout(noop);\n    };\n    isUsingMicroTask = true;\n}\nelse if (!isIE &&\n    typeof MutationObserver !== 'undefined' &&\n    (isNative(MutationObserver) ||\n        // PhantomJS and iOS 7.x\n        MutationObserver.toString() === '[object MutationObserverConstructor]')) {\n    // Use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    // (#6466 MutationObserver is unreliable in IE11)\n    var counter_1 = 1;\n    var observer = new MutationObserver(flushCallbacks);\n    var textNode_1 = document.createTextNode(String(counter_1));\n    observer.observe(textNode_1, {\n        characterData: true\n    });\n    timerFunc = function () {\n        counter_1 = (counter_1 + 1) % 2;\n        textNode_1.data = String(counter_1);\n    };\n    isUsingMicroTask = true;\n}\nelse if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    // Fallback to setImmediate.\n    // Technically it leverages the (macro) task queue,\n    // but it is still a better choice than setTimeout.\n    timerFunc = function () {\n        setImmediate(flushCallbacks);\n    };\n}\nelse {\n    // Fallback to setTimeout.\n    timerFunc = function () {\n        setTimeout(flushCallbacks, 0);\n    };\n}\n/**\n * @internal\n */\nfunction nextTick(cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n        if (cb) {\n            try {\n                cb.call(ctx);\n            }\n            catch (e) {\n                handleError(e, ctx, 'nextTick');\n            }\n        }\n        else if (_resolve) {\n            _resolve(ctx);\n        }\n    });\n    if (!pending) {\n        pending = true;\n        timerFunc();\n    }\n    // $flow-disable-line\n    if (!cb && typeof Promise !== 'undefined') {\n        return new Promise(function (resolve) {\n            _resolve = resolve;\n        });\n    }\n}\n\nfunction useCssModule(name) {\n    if (name === void 0) { name = '$style'; }\n    /* istanbul ignore else */\n    {\n        if (!currentInstance) {\n            process.env.NODE_ENV !== 'production' && warn(\"useCssModule must be called inside setup()\");\n            return emptyObject;\n        }\n        var mod = currentInstance[name];\n        if (!mod) {\n            process.env.NODE_ENV !== 'production' &&\n                warn(\"Current instance does not have CSS module named \\\"\".concat(name, \"\\\".\"));\n            return emptyObject;\n        }\n        return mod;\n    }\n}\n\n/**\n * Runtime helper for SFC's CSS variable injection feature.\n * @private\n */\nfunction useCssVars(getter) {\n    if (!inBrowser && !false)\n        return;\n    var instance = currentInstance;\n    if (!instance) {\n        process.env.NODE_ENV !== 'production' &&\n            warn(\"useCssVars is called without current active component instance.\");\n        return;\n    }\n    watchPostEffect(function () {\n        var el = instance.$el;\n        var vars = getter(instance, instance._setupProxy);\n        if (el && el.nodeType === 1) {\n            var style = el.style;\n            for (var key in vars) {\n                style.setProperty(\"--\".concat(key), vars[key]);\n            }\n        }\n    });\n}\n\n/**\n * v3-compatible async component API.\n * @internal the type is manually declared in <root>/types/v3-define-async-component.d.ts\n * because it relies on existing manual types\n */\nfunction defineAsyncComponent(source) {\n    if (isFunction(source)) {\n        source = { loader: source };\n    }\n    var loader = source.loader, loadingComponent = source.loadingComponent, errorComponent = source.errorComponent, _a = source.delay, delay = _a === void 0 ? 200 : _a, timeout = source.timeout, // undefined = never times out\n    _b = source.suspensible, // undefined = never times out\n    suspensible = _b === void 0 ? false : _b, // in Vue 3 default is true\n    userOnError = source.onError;\n    if (process.env.NODE_ENV !== 'production' && suspensible) {\n        warn(\"The suspensiblbe option for async components is not supported in Vue2. It is ignored.\");\n    }\n    var pendingRequest = null;\n    var retries = 0;\n    var retry = function () {\n        retries++;\n        pendingRequest = null;\n        return load();\n    };\n    var load = function () {\n        var thisRequest;\n        return (pendingRequest ||\n            (thisRequest = pendingRequest =\n                loader()\n                    .catch(function (err) {\n                    err = err instanceof Error ? err : new Error(String(err));\n                    if (userOnError) {\n                        return new Promise(function (resolve, reject) {\n                            var userRetry = function () { return resolve(retry()); };\n                            var userFail = function () { return reject(err); };\n                            userOnError(err, userRetry, userFail, retries + 1);\n                        });\n                    }\n                    else {\n                        throw err;\n                    }\n                })\n                    .then(function (comp) {\n                    if (thisRequest !== pendingRequest && pendingRequest) {\n                        return pendingRequest;\n                    }\n                    if (process.env.NODE_ENV !== 'production' && !comp) {\n                        warn(\"Async component loader resolved to undefined. \" +\n                            \"If you are using retry(), make sure to return its return value.\");\n                    }\n                    // interop module default\n                    if (comp &&\n                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\n                        comp = comp.default;\n                    }\n                    if (process.env.NODE_ENV !== 'production' && comp && !isObject(comp) && !isFunction(comp)) {\n                        throw new Error(\"Invalid async component load result: \".concat(comp));\n                    }\n                    return comp;\n                })));\n    };\n    return function () {\n        var component = load();\n        return {\n            component: component,\n            delay: delay,\n            timeout: timeout,\n            error: errorComponent,\n            loading: loadingComponent\n        };\n    };\n}\n\nfunction createLifeCycle(hookName) {\n    return function (fn, target) {\n        if (target === void 0) { target = currentInstance; }\n        if (!target) {\n            process.env.NODE_ENV !== 'production' &&\n                warn(\"\".concat(formatName(hookName), \" is called when there is no active component instance to be \") +\n                    \"associated with. \" +\n                    \"Lifecycle injection APIs can only be used during execution of setup().\");\n            return;\n        }\n        return injectHook(target, hookName, fn);\n    };\n}\nfunction formatName(name) {\n    if (name === 'beforeDestroy') {\n        name = 'beforeUnmount';\n    }\n    else if (name === 'destroyed') {\n        name = 'unmounted';\n    }\n    return \"on\".concat(name[0].toUpperCase() + name.slice(1));\n}\nfunction injectHook(instance, hookName, fn) {\n    var options = instance.$options;\n    options[hookName] = mergeLifecycleHook(options[hookName], fn);\n}\nvar onBeforeMount = createLifeCycle('beforeMount');\nvar onMounted = createLifeCycle('mounted');\nvar onBeforeUpdate = createLifeCycle('beforeUpdate');\nvar onUpdated = createLifeCycle('updated');\nvar onBeforeUnmount = createLifeCycle('beforeDestroy');\nvar onUnmounted = createLifeCycle('destroyed');\nvar onActivated = createLifeCycle('activated');\nvar onDeactivated = createLifeCycle('deactivated');\nvar onServerPrefetch = createLifeCycle('serverPrefetch');\nvar onRenderTracked = createLifeCycle('renderTracked');\nvar onRenderTriggered = createLifeCycle('renderTriggered');\nvar injectErrorCapturedHook = createLifeCycle('errorCaptured');\nfunction onErrorCaptured(hook, target) {\n    if (target === void 0) { target = currentInstance; }\n    injectErrorCapturedHook(hook, target);\n}\n\n/**\n * Note: also update dist/vue.runtime.mjs when adding new exports to this file.\n */\nvar version = '2.7.14';\n/**\n * @internal type is manually declared in <root>/types/v3-define-component.d.ts\n */\nfunction defineComponent(options) {\n    return options;\n}\n\nvar seenObjects = new _Set();\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse(val) {\n    _traverse(val, seenObjects);\n    seenObjects.clear();\n    return val;\n}\nfunction _traverse(val, seen) {\n    var i, keys;\n    var isA = isArray(val);\n    if ((!isA && !isObject(val)) ||\n        val.__v_skip /* ReactiveFlags.SKIP */ ||\n        Object.isFrozen(val) ||\n        val instanceof VNode) {\n        return;\n    }\n    if (val.__ob__) {\n        var depId = val.__ob__.dep.id;\n        if (seen.has(depId)) {\n            return;\n        }\n        seen.add(depId);\n    }\n    if (isA) {\n        i = val.length;\n        while (i--)\n            _traverse(val[i], seen);\n    }\n    else if (isRef(val)) {\n        _traverse(val.value, seen);\n    }\n    else {\n        keys = Object.keys(val);\n        i = keys.length;\n        while (i--)\n            _traverse(val[keys[i]], seen);\n    }\n}\n\nvar uid$1 = 0;\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n * @internal\n */\nvar Watcher = /** @class */ (function () {\n    function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n        recordEffectScope(this, \n        // if the active effect scope is manually created (not a component scope),\n        // prioritize it\n        activeEffectScope && !activeEffectScope._vm\n            ? activeEffectScope\n            : vm\n                ? vm._scope\n                : undefined);\n        if ((this.vm = vm) && isRenderWatcher) {\n            vm._watcher = this;\n        }\n        // options\n        if (options) {\n            this.deep = !!options.deep;\n            this.user = !!options.user;\n            this.lazy = !!options.lazy;\n            this.sync = !!options.sync;\n            this.before = options.before;\n            if (process.env.NODE_ENV !== 'production') {\n                this.onTrack = options.onTrack;\n                this.onTrigger = options.onTrigger;\n            }\n        }\n        else {\n            this.deep = this.user = this.lazy = this.sync = false;\n        }\n        this.cb = cb;\n        this.id = ++uid$1; // uid for batching\n        this.active = true;\n        this.post = false;\n        this.dirty = this.lazy; // for lazy watchers\n        this.deps = [];\n        this.newDeps = [];\n        this.depIds = new _Set();\n        this.newDepIds = new _Set();\n        this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';\n        // parse expression for getter\n        if (isFunction(expOrFn)) {\n            this.getter = expOrFn;\n        }\n        else {\n            this.getter = parsePath(expOrFn);\n            if (!this.getter) {\n                this.getter = noop;\n                process.env.NODE_ENV !== 'production' &&\n                    warn(\"Failed watching path: \\\"\".concat(expOrFn, \"\\\" \") +\n                        'Watcher only accepts simple dot-delimited paths. ' +\n                        'For full control, use a function instead.', vm);\n            }\n        }\n        this.value = this.lazy ? undefined : this.get();\n    }\n    /**\n     * Evaluate the getter, and re-collect dependencies.\n     */\n    Watcher.prototype.get = function () {\n        pushTarget(this);\n        var value;\n        var vm = this.vm;\n        try {\n            value = this.getter.call(vm, vm);\n        }\n        catch (e) {\n            if (this.user) {\n                handleError(e, vm, \"getter for watcher \\\"\".concat(this.expression, \"\\\"\"));\n            }\n            else {\n                throw e;\n            }\n        }\n        finally {\n            // \"touch\" every property so they are all tracked as\n            // dependencies for deep watching\n            if (this.deep) {\n                traverse(value);\n            }\n            popTarget();\n            this.cleanupDeps();\n        }\n        return value;\n    };\n    /**\n     * Add a dependency to this directive.\n     */\n    Watcher.prototype.addDep = function (dep) {\n        var id = dep.id;\n        if (!this.newDepIds.has(id)) {\n            this.newDepIds.add(id);\n            this.newDeps.push(dep);\n            if (!this.depIds.has(id)) {\n                dep.addSub(this);\n            }\n        }\n    };\n    /**\n     * Clean up for dependency collection.\n     */\n    Watcher.prototype.cleanupDeps = function () {\n        var i = this.deps.length;\n        while (i--) {\n            var dep = this.deps[i];\n            if (!this.newDepIds.has(dep.id)) {\n                dep.removeSub(this);\n            }\n        }\n        var tmp = this.depIds;\n        this.depIds = this.newDepIds;\n        this.newDepIds = tmp;\n        this.newDepIds.clear();\n        tmp = this.deps;\n        this.deps = this.newDeps;\n        this.newDeps = tmp;\n        this.newDeps.length = 0;\n    };\n    /**\n     * Subscriber interface.\n     * Will be called when a dependency changes.\n     */\n    Watcher.prototype.update = function () {\n        /* istanbul ignore else */\n        if (this.lazy) {\n            this.dirty = true;\n        }\n        else if (this.sync) {\n            this.run();\n        }\n        else {\n            queueWatcher(this);\n        }\n    };\n    /**\n     * Scheduler job interface.\n     * Will be called by the scheduler.\n     */\n    Watcher.prototype.run = function () {\n        if (this.active) {\n            var value = this.get();\n            if (value !== this.value ||\n                // Deep watchers and watchers on Object/Arrays should fire even\n                // when the value is the same, because the value may\n                // have mutated.\n                isObject(value) ||\n                this.deep) {\n                // set new value\n                var oldValue = this.value;\n                this.value = value;\n                if (this.user) {\n                    var info = \"callback for watcher \\\"\".concat(this.expression, \"\\\"\");\n                    invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);\n                }\n                else {\n                    this.cb.call(this.vm, value, oldValue);\n                }\n            }\n        }\n    };\n    /**\n     * Evaluate the value of the watcher.\n     * This only gets called for lazy watchers.\n     */\n    Watcher.prototype.evaluate = function () {\n        this.value = this.get();\n        this.dirty = false;\n    };\n    /**\n     * Depend on all deps collected by this watcher.\n     */\n    Watcher.prototype.depend = function () {\n        var i = this.deps.length;\n        while (i--) {\n            this.deps[i].depend();\n        }\n    };\n    /**\n     * Remove self from all dependencies' subscriber list.\n     */\n    Watcher.prototype.teardown = function () {\n        if (this.vm && !this.vm._isBeingDestroyed) {\n            remove$2(this.vm._scope.effects, this);\n        }\n        if (this.active) {\n            var i = this.deps.length;\n            while (i--) {\n                this.deps[i].removeSub(this);\n            }\n            this.active = false;\n            if (this.onStop) {\n                this.onStop();\n            }\n        }\n    };\n    return Watcher;\n}());\n\nvar mark;\nvar measure;\nif (process.env.NODE_ENV !== 'production') {\n    var perf_1 = inBrowser && window.performance;\n    /* istanbul ignore if */\n    if (perf_1 &&\n        // @ts-ignore\n        perf_1.mark &&\n        // @ts-ignore\n        perf_1.measure &&\n        // @ts-ignore\n        perf_1.clearMarks &&\n        // @ts-ignore\n        perf_1.clearMeasures) {\n        mark = function (tag) { return perf_1.mark(tag); };\n        measure = function (name, startTag, endTag) {\n            perf_1.measure(name, startTag, endTag);\n            perf_1.clearMarks(startTag);\n            perf_1.clearMarks(endTag);\n            // perf.clearMeasures(name)\n        };\n    }\n}\n\nfunction initEvents(vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false;\n    // init parent attached events\n    var listeners = vm.$options._parentListeners;\n    if (listeners) {\n        updateComponentListeners(vm, listeners);\n    }\n}\nvar target$1;\nfunction add$1(event, fn) {\n    target$1.$on(event, fn);\n}\nfunction remove$1(event, fn) {\n    target$1.$off(event, fn);\n}\nfunction createOnceHandler$1(event, fn) {\n    var _target = target$1;\n    return function onceHandler() {\n        var res = fn.apply(null, arguments);\n        if (res !== null) {\n            _target.$off(event, onceHandler);\n        }\n    };\n}\nfunction updateComponentListeners(vm, listeners, oldListeners) {\n    target$1 = vm;\n    updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);\n    target$1 = undefined;\n}\nfunction eventsMixin(Vue) {\n    var hookRE = /^hook:/;\n    Vue.prototype.$on = function (event, fn) {\n        var vm = this;\n        if (isArray(event)) {\n            for (var i = 0, l = event.length; i < l; i++) {\n                vm.$on(event[i], fn);\n            }\n        }\n        else {\n            (vm._events[event] || (vm._events[event] = [])).push(fn);\n            // optimize hook:event cost by using a boolean flag marked at registration\n            // instead of a hash lookup\n            if (hookRE.test(event)) {\n                vm._hasHookEvent = true;\n            }\n        }\n        return vm;\n    };\n    Vue.prototype.$once = function (event, fn) {\n        var vm = this;\n        function on() {\n            vm.$off(event, on);\n            fn.apply(vm, arguments);\n        }\n        on.fn = fn;\n        vm.$on(event, on);\n        return vm;\n    };\n    Vue.prototype.$off = function (event, fn) {\n        var vm = this;\n        // all\n        if (!arguments.length) {\n            vm._events = Object.create(null);\n            return vm;\n        }\n        // array of events\n        if (isArray(event)) {\n            for (var i_1 = 0, l = event.length; i_1 < l; i_1++) {\n                vm.$off(event[i_1], fn);\n            }\n            return vm;\n        }\n        // specific event\n        var cbs = vm._events[event];\n        if (!cbs) {\n            return vm;\n        }\n        if (!fn) {\n            vm._events[event] = null;\n            return vm;\n        }\n        // specific handler\n        var cb;\n        var i = cbs.length;\n        while (i--) {\n            cb = cbs[i];\n            if (cb === fn || cb.fn === fn) {\n                cbs.splice(i, 1);\n                break;\n            }\n        }\n        return vm;\n    };\n    Vue.prototype.$emit = function (event) {\n        var vm = this;\n        if (process.env.NODE_ENV !== 'production') {\n            var lowerCaseEvent = event.toLowerCase();\n            if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n                tip(\"Event \\\"\".concat(lowerCaseEvent, \"\\\" is emitted in component \") +\n                    \"\".concat(formatComponentName(vm), \" but the handler is registered for \\\"\").concat(event, \"\\\". \") +\n                    \"Note that HTML attributes are case-insensitive and you cannot use \" +\n                    \"v-on to listen to camelCase events when using in-DOM templates. \" +\n                    \"You should probably use \\\"\".concat(hyphenate(event), \"\\\" instead of \\\"\").concat(event, \"\\\".\"));\n            }\n        }\n        var cbs = vm._events[event];\n        if (cbs) {\n            cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n            var args = toArray(arguments, 1);\n            var info = \"event handler for \\\"\".concat(event, \"\\\"\");\n            for (var i = 0, l = cbs.length; i < l; i++) {\n                invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n            }\n        }\n        return vm;\n    };\n}\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\nfunction setActiveInstance(vm) {\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    return function () {\n        activeInstance = prevActiveInstance;\n    };\n}\nfunction initLifecycle(vm) {\n    var options = vm.$options;\n    // locate first non-abstract parent\n    var parent = options.parent;\n    if (parent && !options.abstract) {\n        while (parent.$options.abstract && parent.$parent) {\n            parent = parent.$parent;\n        }\n        parent.$children.push(vm);\n    }\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n    vm.$children = [];\n    vm.$refs = {};\n    vm._provided = parent ? parent._provided : Object.create(null);\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n}\nfunction lifecycleMixin(Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n        var vm = this;\n        var prevEl = vm.$el;\n        var prevVnode = vm._vnode;\n        var restoreActiveInstance = setActiveInstance(vm);\n        vm._vnode = vnode;\n        // Vue.prototype.__patch__ is injected in entry points\n        // based on the rendering backend used.\n        if (!prevVnode) {\n            // initial render\n            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n        }\n        else {\n            // updates\n            vm.$el = vm.__patch__(prevVnode, vnode);\n        }\n        restoreActiveInstance();\n        // update __vue__ reference\n        if (prevEl) {\n            prevEl.__vue__ = null;\n        }\n        if (vm.$el) {\n            vm.$el.__vue__ = vm;\n        }\n        // if parent is an HOC, update its $el as well\n        var wrapper = vm;\n        while (wrapper &&\n            wrapper.$vnode &&\n            wrapper.$parent &&\n            wrapper.$vnode === wrapper.$parent._vnode) {\n            wrapper.$parent.$el = wrapper.$el;\n            wrapper = wrapper.$parent;\n        }\n        // updated hook is called by the scheduler to ensure that children are\n        // updated in a parent's updated hook.\n    };\n    Vue.prototype.$forceUpdate = function () {\n        var vm = this;\n        if (vm._watcher) {\n            vm._watcher.update();\n        }\n    };\n    Vue.prototype.$destroy = function () {\n        var vm = this;\n        if (vm._isBeingDestroyed) {\n            return;\n        }\n        callHook$1(vm, 'beforeDestroy');\n        vm._isBeingDestroyed = true;\n        // remove self from parent\n        var parent = vm.$parent;\n        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n            remove$2(parent.$children, vm);\n        }\n        // teardown scope. this includes both the render watcher and other\n        // watchers created\n        vm._scope.stop();\n        // remove reference from data ob\n        // frozen object may not have observer.\n        if (vm._data.__ob__) {\n            vm._data.__ob__.vmCount--;\n        }\n        // call the last hook...\n        vm._isDestroyed = true;\n        // invoke destroy hooks on current rendered tree\n        vm.__patch__(vm._vnode, null);\n        // fire destroyed hook\n        callHook$1(vm, 'destroyed');\n        // turn off all instance listeners.\n        vm.$off();\n        // remove __vue__ reference\n        if (vm.$el) {\n            vm.$el.__vue__ = null;\n        }\n        // release circular reference (#6759)\n        if (vm.$vnode) {\n            vm.$vnode.parent = null;\n        }\n    };\n}\nfunction mountComponent(vm, el, hydrating) {\n    vm.$el = el;\n    if (!vm.$options.render) {\n        // @ts-expect-error invalid type\n        vm.$options.render = createEmptyVNode;\n        if (process.env.NODE_ENV !== 'production') {\n            /* istanbul ignore if */\n            if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n                vm.$options.el ||\n                el) {\n                warn('You are using the runtime-only build of Vue where the template ' +\n                    'compiler is not available. Either pre-compile the templates into ' +\n                    'render functions, or use the compiler-included build.', vm);\n            }\n            else {\n                warn('Failed to mount component: template or render function not defined.', vm);\n            }\n        }\n    }\n    callHook$1(vm, 'beforeMount');\n    var updateComponent;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        updateComponent = function () {\n            var name = vm._name;\n            var id = vm._uid;\n            var startTag = \"vue-perf-start:\".concat(id);\n            var endTag = \"vue-perf-end:\".concat(id);\n            mark(startTag);\n            var vnode = vm._render();\n            mark(endTag);\n            measure(\"vue \".concat(name, \" render\"), startTag, endTag);\n            mark(startTag);\n            vm._update(vnode, hydrating);\n            mark(endTag);\n            measure(\"vue \".concat(name, \" patch\"), startTag, endTag);\n        };\n    }\n    else {\n        updateComponent = function () {\n            vm._update(vm._render(), hydrating);\n        };\n    }\n    var watcherOptions = {\n        before: function () {\n            if (vm._isMounted && !vm._isDestroyed) {\n                callHook$1(vm, 'beforeUpdate');\n            }\n        }\n    };\n    if (process.env.NODE_ENV !== 'production') {\n        watcherOptions.onTrack = function (e) { return callHook$1(vm, 'renderTracked', [e]); };\n        watcherOptions.onTrigger = function (e) { return callHook$1(vm, 'renderTriggered', [e]); };\n    }\n    // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n    new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);\n    hydrating = false;\n    // flush buffer for flush: \"pre\" watchers queued in setup()\n    var preWatchers = vm._preWatchers;\n    if (preWatchers) {\n        for (var i = 0; i < preWatchers.length; i++) {\n            preWatchers[i].run();\n        }\n    }\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n        vm._isMounted = true;\n        callHook$1(vm, 'mounted');\n    }\n    return vm;\n}\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n    if (process.env.NODE_ENV !== 'production') {\n        isUpdatingChildComponent = true;\n    }\n    // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren.\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\n    // dynamic slot names). Static scoped slots compiled from template has the\n    // \"$stable\" marker.\n    var newScopedSlots = parentVnode.data.scopedSlots;\n    var oldScopedSlots = vm.$scopedSlots;\n    var hasDynamicScopedSlot = !!((newScopedSlots && !newScopedSlots.$stable) ||\n        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||\n        (!newScopedSlots && vm.$scopedSlots.$key));\n    // Any static slot children from the parent may have changed during parent's\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\n    // update is necessary to ensure correctness.\n    var needsForceUpdate = !!(renderChildren || // has new static slots\n        vm.$options._renderChildren || // has old static slots\n        hasDynamicScopedSlot);\n    var prevVNode = vm.$vnode;\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n    if (vm._vnode) {\n        // update child tree's parent\n        vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n    // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n    var attrs = parentVnode.data.attrs || emptyObject;\n    if (vm._attrsProxy) {\n        // force update if attrs are accessed and has changed since it may be\n        // passed to a child component.\n        if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data && prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {\n            needsForceUpdate = true;\n        }\n    }\n    vm.$attrs = attrs;\n    // update listeners\n    listeners = listeners || emptyObject;\n    var prevListeners = vm.$options._parentListeners;\n    if (vm._listenersProxy) {\n        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');\n    }\n    vm.$listeners = vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, prevListeners);\n    // update props\n    if (propsData && vm.$options.props) {\n        toggleObserving(false);\n        var props = vm._props;\n        var propKeys = vm.$options._propKeys || [];\n        for (var i = 0; i < propKeys.length; i++) {\n            var key = propKeys[i];\n            var propOptions = vm.$options.props; // wtf flow?\n            props[key] = validateProp(key, propOptions, propsData, vm);\n        }\n        toggleObserving(true);\n        // keep a copy of raw propsData\n        vm.$options.propsData = propsData;\n    }\n    // resolve slots + force update if has children\n    if (needsForceUpdate) {\n        vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n        vm.$forceUpdate();\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        isUpdatingChildComponent = false;\n    }\n}\nfunction isInInactiveTree(vm) {\n    while (vm && (vm = vm.$parent)) {\n        if (vm._inactive)\n            return true;\n    }\n    return false;\n}\nfunction activateChildComponent(vm, direct) {\n    if (direct) {\n        vm._directInactive = false;\n        if (isInInactiveTree(vm)) {\n            return;\n        }\n    }\n    else if (vm._directInactive) {\n        return;\n    }\n    if (vm._inactive || vm._inactive === null) {\n        vm._inactive = false;\n        for (var i = 0; i < vm.$children.length; i++) {\n            activateChildComponent(vm.$children[i]);\n        }\n        callHook$1(vm, 'activated');\n    }\n}\nfunction deactivateChildComponent(vm, direct) {\n    if (direct) {\n        vm._directInactive = true;\n        if (isInInactiveTree(vm)) {\n            return;\n        }\n    }\n    if (!vm._inactive) {\n        vm._inactive = true;\n        for (var i = 0; i < vm.$children.length; i++) {\n            deactivateChildComponent(vm.$children[i]);\n        }\n        callHook$1(vm, 'deactivated');\n    }\n}\nfunction callHook$1(vm, hook, args, setContext) {\n    if (setContext === void 0) { setContext = true; }\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    var prev = currentInstance;\n    setContext && setCurrentInstance(vm);\n    var handlers = vm.$options[hook];\n    var info = \"\".concat(hook, \" hook\");\n    if (handlers) {\n        for (var i = 0, j = handlers.length; i < j; i++) {\n            invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);\n        }\n    }\n    if (vm._hasHookEvent) {\n        vm.$emit('hook:' + hook);\n    }\n    setContext && setCurrentInstance(prev);\n    popTarget();\n}\n\nvar MAX_UPDATE_COUNT = 100;\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState() {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    if (process.env.NODE_ENV !== 'production') {\n        circular = {};\n    }\n    waiting = flushing = false;\n}\n// Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\nvar currentFlushTimestamp = 0;\n// Async edge case fix requires storing an event listener's attach timestamp.\nvar getNow = Date.now;\n// Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\nif (inBrowser && !isIE) {\n    var performance_1 = window.performance;\n    if (performance_1 &&\n        typeof performance_1.now === 'function' &&\n        getNow() > document.createEvent('Event').timeStamp) {\n        // if the event timestamp, although evaluated AFTER the Date.now(), is\n        // smaller than it, it means the event is using a hi-res timestamp,\n        // and we need to use the hi-res version for event listener timestamps as\n        // well.\n        getNow = function () { return performance_1.now(); };\n    }\n}\nvar sortCompareFn = function (a, b) {\n    if (a.post) {\n        if (!b.post)\n            return 1;\n    }\n    else if (b.post) {\n        return -1;\n    }\n    return a.id - b.id;\n};\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue() {\n    currentFlushTimestamp = getNow();\n    flushing = true;\n    var watcher, id;\n    // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n    queue.sort(sortCompareFn);\n    // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n    for (index = 0; index < queue.length; index++) {\n        watcher = queue[index];\n        if (watcher.before) {\n            watcher.before();\n        }\n        id = watcher.id;\n        has[id] = null;\n        watcher.run();\n        // in dev build, check and stop circular updates.\n        if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n            circular[id] = (circular[id] || 0) + 1;\n            if (circular[id] > MAX_UPDATE_COUNT) {\n                warn('You may have an infinite update loop ' +\n                    (watcher.user\n                        ? \"in watcher with expression \\\"\".concat(watcher.expression, \"\\\"\")\n                        : \"in a component render function.\"), watcher.vm);\n                break;\n            }\n        }\n    }\n    // keep copies of post queues before resetting state\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n    resetSchedulerState();\n    // call component updated and activated hooks\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue);\n    cleanupDeps();\n    // devtool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n        devtools.emit('flush');\n    }\n}\nfunction callUpdatedHooks(queue) {\n    var i = queue.length;\n    while (i--) {\n        var watcher = queue[i];\n        var vm = watcher.vm;\n        if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n            callHook$1(vm, 'updated');\n        }\n    }\n}\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent(vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n}\nfunction callActivatedHooks(queue) {\n    for (var i = 0; i < queue.length; i++) {\n        queue[i]._inactive = true;\n        activateChildComponent(queue[i], true /* true */);\n    }\n}\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher(watcher) {\n    var id = watcher.id;\n    if (has[id] != null) {\n        return;\n    }\n    if (watcher === Dep.target && watcher.noRecurse) {\n        return;\n    }\n    has[id] = true;\n    if (!flushing) {\n        queue.push(watcher);\n    }\n    else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n        while (i > index && queue[i].id > watcher.id) {\n            i--;\n        }\n        queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n        waiting = true;\n        if (process.env.NODE_ENV !== 'production' && !config.async) {\n            flushSchedulerQueue();\n            return;\n        }\n        nextTick(flushSchedulerQueue);\n    }\n}\n\nfunction initProvide(vm) {\n    var provideOption = vm.$options.provide;\n    if (provideOption) {\n        var provided = isFunction(provideOption)\n            ? provideOption.call(vm)\n            : provideOption;\n        if (!isObject(provided)) {\n            return;\n        }\n        var source = resolveProvided(vm);\n        // IE9 doesn't support Object.getOwnPropertyDescriptors so we have to\n        // iterate the keys ourselves.\n        var keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));\n        }\n    }\n}\nfunction initInjections(vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n    if (result) {\n        toggleObserving(false);\n        Object.keys(result).forEach(function (key) {\n            /* istanbul ignore else */\n            if (process.env.NODE_ENV !== 'production') {\n                defineReactive(vm, key, result[key], function () {\n                    warn(\"Avoid mutating an injected value directly since the changes will be \" +\n                        \"overwritten whenever the provided component re-renders. \" +\n                        \"injection being mutated: \\\"\".concat(key, \"\\\"\"), vm);\n                });\n            }\n            else {\n                defineReactive(vm, key, result[key]);\n            }\n        });\n        toggleObserving(true);\n    }\n}\nfunction resolveInject(inject, vm) {\n    if (inject) {\n        // inject is :any because flow is not smart enough to figure out cached\n        var result = Object.create(null);\n        var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            // #6574 in case the inject object is observed...\n            if (key === '__ob__')\n                continue;\n            var provideKey = inject[key].from;\n            if (provideKey in vm._provided) {\n                result[key] = vm._provided[provideKey];\n            }\n            else if ('default' in inject[key]) {\n                var provideDefault = inject[key].default;\n                result[key] = isFunction(provideDefault)\n                    ? provideDefault.call(vm)\n                    : provideDefault;\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                warn(\"Injection \\\"\".concat(key, \"\\\" not found\"), vm);\n            }\n        }\n        return result;\n    }\n}\n\nfunction FunctionalRenderContext(data, props, children, parent, Ctor) {\n    var _this = this;\n    var options = Ctor.options;\n    // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n    var contextVm;\n    if (hasOwn(parent, '_uid')) {\n        contextVm = Object.create(parent);\n        contextVm._original = parent;\n    }\n    else {\n        // the context vm passed in is a functional context as well.\n        // in this case we want to make sure we are able to get a hold to the\n        // real context instance.\n        contextVm = parent;\n        // @ts-ignore\n        parent = parent._original;\n    }\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n    this.slots = function () {\n        if (!_this.$slots) {\n            normalizeScopedSlots(parent, data.scopedSlots, (_this.$slots = resolveSlots(children, parent)));\n        }\n        return _this.$slots;\n    };\n    Object.defineProperty(this, 'scopedSlots', {\n        enumerable: true,\n        get: function () {\n            return normalizeScopedSlots(parent, data.scopedSlots, this.slots());\n        }\n    });\n    // support for compiled functional template\n    if (isCompiled) {\n        // exposing $options for renderStatic()\n        this.$options = options;\n        // pre-resolve slots for renderSlot()\n        this.$slots = this.slots();\n        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);\n    }\n    if (options._scopeId) {\n        this._c = function (a, b, c, d) {\n            var vnode = createElement$1(contextVm, a, b, c, d, needNormalization);\n            if (vnode && !isArray(vnode)) {\n                vnode.fnScopeId = options._scopeId;\n                vnode.fnContext = parent;\n            }\n            return vnode;\n        };\n    }\n    else {\n        this._c = function (a, b, c, d) {\n            return createElement$1(contextVm, a, b, c, d, needNormalization);\n        };\n    }\n}\ninstallRenderHelpers(FunctionalRenderContext.prototype);\nfunction createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n    if (isDef(propOptions)) {\n        for (var key in propOptions) {\n            props[key] = validateProp(key, propOptions, propsData || emptyObject);\n        }\n    }\n    else {\n        if (isDef(data.attrs))\n            mergeProps(props, data.attrs);\n        if (isDef(data.props))\n            mergeProps(props, data.props);\n    }\n    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n    if (vnode instanceof VNode) {\n        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\n    }\n    else if (isArray(vnode)) {\n        var vnodes = normalizeChildren(vnode) || [];\n        var res = new Array(vnodes.length);\n        for (var i = 0; i < vnodes.length; i++) {\n            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n        }\n        return res;\n    }\n}\nfunction cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    var clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    if (process.env.NODE_ENV !== 'production') {\n        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =\n            renderContext;\n    }\n    if (data.slot) {\n        (clone.data || (clone.data = {})).slot = data.slot;\n    }\n    return clone;\n}\nfunction mergeProps(to, from) {\n    for (var key in from) {\n        to[camelize(key)] = from[key];\n    }\n}\n\nfunction getComponentName(options) {\n    return options.name || options.__name || options._componentTag;\n}\n// inline hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n    init: function (vnode, hydrating) {\n        if (vnode.componentInstance &&\n            !vnode.componentInstance._isDestroyed &&\n            vnode.data.keepAlive) {\n            // kept-alive components, treat as a patch\n            var mountedNode = vnode; // work around flow\n            componentVNodeHooks.prepatch(mountedNode, mountedNode);\n        }\n        else {\n            var child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));\n            child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n        }\n    },\n    prepatch: function (oldVnode, vnode) {\n        var options = vnode.componentOptions;\n        var child = (vnode.componentInstance = oldVnode.componentInstance);\n        updateChildComponent(child, options.propsData, // updated props\n        options.listeners, // updated listeners\n        vnode, // new parent vnode\n        options.children // new children\n        );\n    },\n    insert: function (vnode) {\n        var context = vnode.context, componentInstance = vnode.componentInstance;\n        if (!componentInstance._isMounted) {\n            componentInstance._isMounted = true;\n            callHook$1(componentInstance, 'mounted');\n        }\n        if (vnode.data.keepAlive) {\n            if (context._isMounted) {\n                // vue-router#1212\n                // During updates, a kept-alive component's child components may\n                // change, so directly walking the tree here may call activated hooks\n                // on incorrect children. Instead we push them into a queue which will\n                // be processed after the whole patch process ended.\n                queueActivatedComponent(componentInstance);\n            }\n            else {\n                activateChildComponent(componentInstance, true /* direct */);\n            }\n        }\n    },\n    destroy: function (vnode) {\n        var componentInstance = vnode.componentInstance;\n        if (!componentInstance._isDestroyed) {\n            if (!vnode.data.keepAlive) {\n                componentInstance.$destroy();\n            }\n            else {\n                deactivateChildComponent(componentInstance, true /* direct */);\n            }\n        }\n    }\n};\nvar hooksToMerge = Object.keys(componentVNodeHooks);\nfunction createComponent(Ctor, data, context, children, tag) {\n    if (isUndef(Ctor)) {\n        return;\n    }\n    var baseCtor = context.$options._base;\n    // plain options object: turn it into a constructor\n    if (isObject(Ctor)) {\n        Ctor = baseCtor.extend(Ctor);\n    }\n    // if at this stage it's not a constructor or an async component factory,\n    // reject.\n    if (typeof Ctor !== 'function') {\n        if (process.env.NODE_ENV !== 'production') {\n            warn(\"Invalid Component definition: \".concat(String(Ctor)), context);\n        }\n        return;\n    }\n    // async component\n    var asyncFactory;\n    // @ts-expect-error\n    if (isUndef(Ctor.cid)) {\n        asyncFactory = Ctor;\n        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n        if (Ctor === undefined) {\n            // return a placeholder node for async component, which is rendered\n            // as a comment node but preserves all the raw information for the node.\n            // the information will be used for async server-rendering and hydration.\n            return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n        }\n    }\n    data = data || {};\n    // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n    resolveConstructorOptions(Ctor);\n    // transform component v-model data into props & events\n    if (isDef(data.model)) {\n        // @ts-expect-error\n        transformModel(Ctor.options, data);\n    }\n    // extract props\n    // @ts-expect-error\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n    // functional component\n    // @ts-expect-error\n    if (isTrue(Ctor.options.functional)) {\n        return createFunctionalComponent(Ctor, propsData, data, context, children);\n    }\n    // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n    var listeners = data.on;\n    // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n    data.on = data.nativeOn;\n    // @ts-expect-error\n    if (isTrue(Ctor.options.abstract)) {\n        // abstract components do not keep anything\n        // other than props & listeners & slot\n        // work around flow\n        var slot = data.slot;\n        data = {};\n        if (slot) {\n            data.slot = slot;\n        }\n    }\n    // install component management hooks onto the placeholder node\n    installComponentHooks(data);\n    // return a placeholder vnode\n    // @ts-expect-error\n    var name = getComponentName(Ctor.options) || tag;\n    var vnode = new VNode(\n    // @ts-expect-error\n    \"vue-component-\".concat(Ctor.cid).concat(name ? \"-\".concat(name) : ''), data, undefined, undefined, undefined, context, \n    // @ts-expect-error\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);\n    return vnode;\n}\nfunction createComponentInstanceForVnode(\n// we know it's MountedComponentVNode but flow doesn't\nvnode, \n// activeInstance in lifecycle state\nparent) {\n    var options = {\n        _isComponent: true,\n        _parentVnode: vnode,\n        parent: parent\n    };\n    // check inline-template render functions\n    var inlineTemplate = vnode.data.inlineTemplate;\n    if (isDef(inlineTemplate)) {\n        options.render = inlineTemplate.render;\n        options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n    return new vnode.componentOptions.Ctor(options);\n}\nfunction installComponentHooks(data) {\n    var hooks = data.hook || (data.hook = {});\n    for (var i = 0; i < hooksToMerge.length; i++) {\n        var key = hooksToMerge[i];\n        var existing = hooks[key];\n        var toMerge = componentVNodeHooks[key];\n        // @ts-expect-error\n        if (existing !== toMerge && !(existing && existing._merged)) {\n            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;\n        }\n    }\n}\nfunction mergeHook(f1, f2) {\n    var merged = function (a, b) {\n        // flow complains about extra args which is why we use any\n        f1(a, b);\n        f2(a, b);\n    };\n    merged._merged = true;\n    return merged;\n}\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel(options, data) {\n    var prop = (options.model && options.model.prop) || 'value';\n    var event = (options.model && options.model.event) || 'input';\n    (data.attrs || (data.attrs = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    var existing = on[event];\n    var callback = data.model.callback;\n    if (isDef(existing)) {\n        if (isArray(existing)\n            ? existing.indexOf(callback) === -1\n            : existing !== callback) {\n            on[event] = [callback].concat(existing);\n        }\n    }\n    else {\n        on[event] = callback;\n    }\n}\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace; // work around flow check\nvar formatComponentName;\nif (process.env.NODE_ENV !== 'production') {\n    var hasConsole_1 = typeof console !== 'undefined';\n    var classifyRE_1 = /(?:^|[-_])(\\w)/g;\n    var classify_1 = function (str) {\n        return str.replace(classifyRE_1, function (c) { return c.toUpperCase(); }).replace(/[-_]/g, '');\n    };\n    warn = function (msg, vm) {\n        if (vm === void 0) { vm = currentInstance; }\n        var trace = vm ? generateComponentTrace(vm) : '';\n        if (config.warnHandler) {\n            config.warnHandler.call(null, msg, vm, trace);\n        }\n        else if (hasConsole_1 && !config.silent) {\n            console.error(\"[Vue warn]: \".concat(msg).concat(trace));\n        }\n    };\n    tip = function (msg, vm) {\n        if (hasConsole_1 && !config.silent) {\n            console.warn(\"[Vue tip]: \".concat(msg) + (vm ? generateComponentTrace(vm) : ''));\n        }\n    };\n    formatComponentName = function (vm, includeFile) {\n        if (vm.$root === vm) {\n            return '<Root>';\n        }\n        var options = isFunction(vm) && vm.cid != null\n            ? vm.options\n            : vm._isVue\n                ? vm.$options || vm.constructor.options\n                : vm;\n        var name = getComponentName(options);\n        var file = options.__file;\n        if (!name && file) {\n            var match = file.match(/([^/\\\\]+)\\.vue$/);\n            name = match && match[1];\n        }\n        return ((name ? \"<\".concat(classify_1(name), \">\") : \"<Anonymous>\") +\n            (file && includeFile !== false ? \" at \".concat(file) : ''));\n    };\n    var repeat_1 = function (str, n) {\n        var res = '';\n        while (n) {\n            if (n % 2 === 1)\n                res += str;\n            if (n > 1)\n                str += str;\n            n >>= 1;\n        }\n        return res;\n    };\n    generateComponentTrace = function (vm) {\n        if (vm._isVue && vm.$parent) {\n            var tree = [];\n            var currentRecursiveSequence = 0;\n            while (vm) {\n                if (tree.length > 0) {\n                    var last = tree[tree.length - 1];\n                    if (last.constructor === vm.constructor) {\n                        currentRecursiveSequence++;\n                        vm = vm.$parent;\n                        continue;\n                    }\n                    else if (currentRecursiveSequence > 0) {\n                        tree[tree.length - 1] = [last, currentRecursiveSequence];\n                        currentRecursiveSequence = 0;\n                    }\n                }\n                tree.push(vm);\n                vm = vm.$parent;\n            }\n            return ('\\n\\nfound in\\n\\n' +\n                tree\n                    .map(function (vm, i) {\n                    return \"\".concat(i === 0 ? '---> ' : repeat_1(' ', 5 + i * 2)).concat(isArray(vm)\n                        ? \"\".concat(formatComponentName(vm[0]), \"... (\").concat(vm[1], \" recursive calls)\")\n                        : formatComponentName(vm));\n                })\n                    .join('\\n'));\n        }\n        else {\n            return \"\\n\\n(found in \".concat(formatComponentName(vm), \")\");\n        }\n    };\n}\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n        if (!vm) {\n            warn(\"option \\\"\".concat(key, \"\\\" can only be used during instance \") +\n                'creation with the `new` keyword.');\n        }\n        return defaultStrat(parent, child);\n    };\n}\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData(to, from, recursive) {\n    if (recursive === void 0) { recursive = true; }\n    if (!from)\n        return to;\n    var key, toVal, fromVal;\n    var keys = hasSymbol\n        ? Reflect.ownKeys(from)\n        : Object.keys(from);\n    for (var i = 0; i < keys.length; i++) {\n        key = keys[i];\n        // in case the object is already observed...\n        if (key === '__ob__')\n            continue;\n        toVal = to[key];\n        fromVal = from[key];\n        if (!recursive || !hasOwn(to, key)) {\n            set(to, key, fromVal);\n        }\n        else if (toVal !== fromVal &&\n            isPlainObject(toVal) &&\n            isPlainObject(fromVal)) {\n            mergeData(toVal, fromVal);\n        }\n    }\n    return to;\n}\n/**\n * Data\n */\nfunction mergeDataOrFn(parentVal, childVal, vm) {\n    if (!vm) {\n        // in a Vue.extend merge, both should be functions\n        if (!childVal) {\n            return parentVal;\n        }\n        if (!parentVal) {\n            return childVal;\n        }\n        // when parentVal & childVal are both present,\n        // we need to return a function that returns the\n        // merged result of both functions... no need to\n        // check if parentVal is a function here because\n        // it has to be a function to pass previous merges.\n        return function mergedDataFn() {\n            return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);\n        };\n    }\n    else {\n        return function mergedInstanceDataFn() {\n            // instance merge\n            var instanceData = isFunction(childVal)\n                ? childVal.call(vm, vm)\n                : childVal;\n            var defaultData = isFunction(parentVal)\n                ? parentVal.call(vm, vm)\n                : parentVal;\n            if (instanceData) {\n                return mergeData(instanceData, defaultData);\n            }\n            else {\n                return defaultData;\n            }\n        };\n    }\n}\nstrats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n        if (childVal && typeof childVal !== 'function') {\n            process.env.NODE_ENV !== 'production' &&\n                warn('The \"data\" option should be a function ' +\n                    'that returns a per-instance value in component ' +\n                    'definitions.', vm);\n            return parentVal;\n        }\n        return mergeDataOrFn(parentVal, childVal);\n    }\n    return mergeDataOrFn(parentVal, childVal, vm);\n};\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeLifecycleHook(parentVal, childVal) {\n    var res = childVal\n        ? parentVal\n            ? parentVal.concat(childVal)\n            : isArray(childVal)\n                ? childVal\n                : [childVal]\n        : parentVal;\n    return res ? dedupeHooks(res) : res;\n}\nfunction dedupeHooks(hooks) {\n    var res = [];\n    for (var i = 0; i < hooks.length; i++) {\n        if (res.indexOf(hooks[i]) === -1) {\n            res.push(hooks[i]);\n        }\n    }\n    return res;\n}\nLIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeLifecycleHook;\n});\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets(parentVal, childVal, vm, key) {\n    var res = Object.create(parentVal || null);\n    if (childVal) {\n        process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);\n        return extend(res, childVal);\n    }\n    else {\n        return res;\n    }\n}\nASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n});\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal, vm, key) {\n    // work around Firefox's Object.prototype.watch...\n    //@ts-expect-error work around\n    if (parentVal === nativeWatch)\n        parentVal = undefined;\n    //@ts-expect-error work around\n    if (childVal === nativeWatch)\n        childVal = undefined;\n    /* istanbul ignore if */\n    if (!childVal)\n        return Object.create(parentVal || null);\n    if (process.env.NODE_ENV !== 'production') {\n        assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal)\n        return childVal;\n    var ret = {};\n    extend(ret, parentVal);\n    for (var key_1 in childVal) {\n        var parent_1 = ret[key_1];\n        var child = childVal[key_1];\n        if (parent_1 && !isArray(parent_1)) {\n            parent_1 = [parent_1];\n        }\n        ret[key_1] = parent_1 ? parent_1.concat(child) : isArray(child) ? child : [child];\n    }\n    return ret;\n};\n/**\n * Other object hashes.\n */\nstrats.props =\n    strats.methods =\n        strats.inject =\n            strats.computed =\n                function (parentVal, childVal, vm, key) {\n                    if (childVal && process.env.NODE_ENV !== 'production') {\n                        assertObjectType(key, childVal, vm);\n                    }\n                    if (!parentVal)\n                        return childVal;\n                    var ret = Object.create(null);\n                    extend(ret, parentVal);\n                    if (childVal)\n                        extend(ret, childVal);\n                    return ret;\n                };\nstrats.provide = function (parentVal, childVal) {\n    if (!parentVal)\n        return childVal;\n    return function () {\n        var ret = Object.create(null);\n        mergeData(ret, isFunction(parentVal) ? parentVal.call(this) : parentVal);\n        if (childVal) {\n            mergeData(ret, isFunction(childVal) ? childVal.call(this) : childVal, false // non-recursive\n            );\n        }\n        return ret;\n    };\n};\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n};\n/**\n * Validate component names\n */\nfunction checkComponents(options) {\n    for (var key in options.components) {\n        validateComponentName(key);\n    }\n}\nfunction validateComponentName(name) {\n    if (!new RegExp(\"^[a-zA-Z][\\\\-\\\\.0-9_\".concat(unicodeRegExp.source, \"]*$\")).test(name)) {\n        warn('Invalid component name: \"' +\n            name +\n            '\". Component names ' +\n            'should conform to valid custom element name in html5 specification.');\n    }\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n        warn('Do not use built-in or reserved HTML elements as component ' +\n            'id: ' +\n            name);\n    }\n}\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps(options, vm) {\n    var props = options.props;\n    if (!props)\n        return;\n    var res = {};\n    var i, val, name;\n    if (isArray(props)) {\n        i = props.length;\n        while (i--) {\n            val = props[i];\n            if (typeof val === 'string') {\n                name = camelize(val);\n                res[name] = { type: null };\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                warn('props must be strings when using array syntax.');\n            }\n        }\n    }\n    else if (isPlainObject(props)) {\n        for (var key in props) {\n            val = props[key];\n            name = camelize(key);\n            res[name] = isPlainObject(val) ? val : { type: val };\n        }\n    }\n    else if (process.env.NODE_ENV !== 'production') {\n        warn(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n            \"but got \".concat(toRawType(props), \".\"), vm);\n    }\n    options.props = res;\n}\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject(options, vm) {\n    var inject = options.inject;\n    if (!inject)\n        return;\n    var normalized = (options.inject = {});\n    if (isArray(inject)) {\n        for (var i = 0; i < inject.length; i++) {\n            normalized[inject[i]] = { from: inject[i] };\n        }\n    }\n    else if (isPlainObject(inject)) {\n        for (var key in inject) {\n            var val = inject[key];\n            normalized[key] = isPlainObject(val)\n                ? extend({ from: key }, val)\n                : { from: val };\n        }\n    }\n    else if (process.env.NODE_ENV !== 'production') {\n        warn(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n            \"but got \".concat(toRawType(inject), \".\"), vm);\n    }\n}\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives$1(options) {\n    var dirs = options.directives;\n    if (dirs) {\n        for (var key in dirs) {\n            var def = dirs[key];\n            if (isFunction(def)) {\n                dirs[key] = { bind: def, update: def };\n            }\n        }\n    }\n}\nfunction assertObjectType(name, value, vm) {\n    if (!isPlainObject(value)) {\n        warn(\"Invalid value for option \\\"\".concat(name, \"\\\": expected an Object, \") +\n            \"but got \".concat(toRawType(value), \".\"), vm);\n    }\n}\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions(parent, child, vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        checkComponents(child);\n    }\n    if (isFunction(child)) {\n        // @ts-expect-error\n        child = child.options;\n    }\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives$1(child);\n    // Apply extends and mixins on the child options,\n    // but only if it is a raw options object that isn't\n    // the result of another mergeOptions call.\n    // Only merged options has the _base property.\n    if (!child._base) {\n        if (child.extends) {\n            parent = mergeOptions(parent, child.extends, vm);\n        }\n        if (child.mixins) {\n            for (var i = 0, l = child.mixins.length; i < l; i++) {\n                parent = mergeOptions(parent, child.mixins[i], vm);\n            }\n        }\n    }\n    var options = {};\n    var key;\n    for (key in parent) {\n        mergeField(key);\n    }\n    for (key in child) {\n        if (!hasOwn(parent, key)) {\n            mergeField(key);\n        }\n    }\n    function mergeField(key) {\n        var strat = strats[key] || defaultStrat;\n        options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options;\n}\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n        return;\n    }\n    var assets = options[type];\n    // check local registration variations first\n    if (hasOwn(assets, id))\n        return assets[id];\n    var camelizedId = camelize(id);\n    if (hasOwn(assets, camelizedId))\n        return assets[camelizedId];\n    var PascalCaseId = capitalize(camelizedId);\n    if (hasOwn(assets, PascalCaseId))\n        return assets[PascalCaseId];\n    // fallback to prototype chain\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n    if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n        warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id);\n    }\n    return res;\n}\n\nfunction validateProp(key, propOptions, propsData, vm) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key];\n    // boolean casting\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\n    if (booleanIndex > -1) {\n        if (absent && !hasOwn(prop, 'default')) {\n            value = false;\n        }\n        else if (value === '' || value === hyphenate(key)) {\n            // only cast empty string / same name to boolean if\n            // boolean has higher priority\n            var stringIndex = getTypeIndex(String, prop.type);\n            if (stringIndex < 0 || booleanIndex < stringIndex) {\n                value = true;\n            }\n        }\n    }\n    // check default value\n    if (value === undefined) {\n        value = getPropDefaultValue(vm, prop, key);\n        // since the default value is a fresh copy,\n        // make sure to observe it.\n        var prevShouldObserve = shouldObserve;\n        toggleObserving(true);\n        observe(value);\n        toggleObserving(prevShouldObserve);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assertProp(prop, key, value, vm, absent);\n    }\n    return value;\n}\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue(vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n        return undefined;\n    }\n    var def = prop.default;\n    // warn against non-factory defaults for Object & Array\n    if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n        warn('Invalid default value for prop \"' +\n            key +\n            '\": ' +\n            'Props with type Object/Array must use a factory function ' +\n            'to return the default value.', vm);\n    }\n    // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n    if (vm &&\n        vm.$options.propsData &&\n        vm.$options.propsData[key] === undefined &&\n        vm._props[key] !== undefined) {\n        return vm._props[key];\n    }\n    // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n    return isFunction(def) && getType(prop.type) !== 'Function'\n        ? def.call(vm)\n        : def;\n}\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp(prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n        warn('Missing required prop: \"' + name + '\"', vm);\n        return;\n    }\n    if (value == null && !prop.required) {\n        return;\n    }\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n    if (type) {\n        if (!isArray(type)) {\n            type = [type];\n        }\n        for (var i = 0; i < type.length && !valid; i++) {\n            var assertedType = assertType(value, type[i], vm);\n            expectedTypes.push(assertedType.expectedType || '');\n            valid = assertedType.valid;\n        }\n    }\n    var haveExpectedTypes = expectedTypes.some(function (t) { return t; });\n    if (!valid && haveExpectedTypes) {\n        warn(getInvalidTypeMessage(name, value, expectedTypes), vm);\n        return;\n    }\n    var validator = prop.validator;\n    if (validator) {\n        if (!validator(value)) {\n            warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n        }\n    }\n}\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;\nfunction assertType(value, type, vm) {\n    var valid;\n    var expectedType = getType(type);\n    if (simpleCheckRE.test(expectedType)) {\n        var t = typeof value;\n        valid = t === expectedType.toLowerCase();\n        // for primitive wrapper objects\n        if (!valid && t === 'object') {\n            valid = value instanceof type;\n        }\n    }\n    else if (expectedType === 'Object') {\n        valid = isPlainObject(value);\n    }\n    else if (expectedType === 'Array') {\n        valid = isArray(value);\n    }\n    else {\n        try {\n            valid = value instanceof type;\n        }\n        catch (e) {\n            warn('Invalid prop type: \"' + String(type) + '\" is not a constructor', vm);\n            valid = false;\n        }\n    }\n    return {\n        valid: valid,\n        expectedType: expectedType\n    };\n}\nvar functionTypeCheckRE = /^\\s*function (\\w+)/;\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType(fn) {\n    var match = fn && fn.toString().match(functionTypeCheckRE);\n    return match ? match[1] : '';\n}\nfunction isSameType(a, b) {\n    return getType(a) === getType(b);\n}\nfunction getTypeIndex(type, expectedTypes) {\n    if (!isArray(expectedTypes)) {\n        return isSameType(expectedTypes, type) ? 0 : -1;\n    }\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\n        if (isSameType(expectedTypes[i], type)) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n    var message = \"Invalid prop: type check failed for prop \\\"\".concat(name, \"\\\".\") +\n        \" Expected \".concat(expectedTypes.map(capitalize).join(', '));\n    var expectedType = expectedTypes[0];\n    var receivedType = toRawType(value);\n    // check if we need to specify expected value\n    if (expectedTypes.length === 1 &&\n        isExplicable(expectedType) &&\n        isExplicable(typeof value) &&\n        !isBoolean(expectedType, receivedType)) {\n        message += \" with value \".concat(styleValue(value, expectedType));\n    }\n    message += \", got \".concat(receivedType, \" \");\n    // check if we need to specify received value\n    if (isExplicable(receivedType)) {\n        message += \"with value \".concat(styleValue(value, receivedType), \".\");\n    }\n    return message;\n}\nfunction styleValue(value, type) {\n    if (type === 'String') {\n        return \"\\\"\".concat(value, \"\\\"\");\n    }\n    else if (type === 'Number') {\n        return \"\".concat(Number(value));\n    }\n    else {\n        return \"\".concat(value);\n    }\n}\nvar EXPLICABLE_TYPES = ['string', 'number', 'boolean'];\nfunction isExplicable(value) {\n    return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; });\n}\nfunction isBoolean() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; });\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\nvar initProxy;\nif (process.env.NODE_ENV !== 'production') {\n    var allowedGlobals_1 = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' +\n        'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n        'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +\n        'require' // for Webpack/Browserify\n    );\n    var warnNonPresent_1 = function (target, key) {\n        warn(\"Property or method \\\"\".concat(key, \"\\\" is not defined on the instance but \") +\n            'referenced during render. Make sure that this property is reactive, ' +\n            'either in the data option, or for class-based components, by ' +\n            'initializing the property. ' +\n            'See: https://v2.vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n    };\n    var warnReservedPrefix_1 = function (target, key) {\n        warn(\"Property \\\"\".concat(key, \"\\\" must be accessed with \\\"$data.\").concat(key, \"\\\" because \") +\n            'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n            'prevent conflicts with Vue internals. ' +\n            'See: https://v2.vuejs.org/v2/api/#data', target);\n    };\n    var hasProxy_1 = typeof Proxy !== 'undefined' && isNative(Proxy);\n    if (hasProxy_1) {\n        var isBuiltInModifier_1 = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n        config.keyCodes = new Proxy(config.keyCodes, {\n            set: function (target, key, value) {\n                if (isBuiltInModifier_1(key)) {\n                    warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\".concat(key));\n                    return false;\n                }\n                else {\n                    target[key] = value;\n                    return true;\n                }\n            }\n        });\n    }\n    var hasHandler_1 = {\n        has: function (target, key) {\n            var has = key in target;\n            var isAllowed = allowedGlobals_1(key) ||\n                (typeof key === 'string' &&\n                    key.charAt(0) === '_' &&\n                    !(key in target.$data));\n            if (!has && !isAllowed) {\n                if (key in target.$data)\n                    warnReservedPrefix_1(target, key);\n                else\n                    warnNonPresent_1(target, key);\n            }\n            return has || !isAllowed;\n        }\n    };\n    var getHandler_1 = {\n        get: function (target, key) {\n            if (typeof key === 'string' && !(key in target)) {\n                if (key in target.$data)\n                    warnReservedPrefix_1(target, key);\n                else\n                    warnNonPresent_1(target, key);\n            }\n            return target[key];\n        }\n    };\n    initProxy = function initProxy(vm) {\n        if (hasProxy_1) {\n            // determine which proxy handler to use\n            var options = vm.$options;\n            var handlers = options.render && options.render._withStripped ? getHandler_1 : hasHandler_1;\n            vm._renderProxy = new Proxy(vm, handlers);\n        }\n        else {\n            vm._renderProxy = vm;\n        }\n    };\n}\n\nvar sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n};\nfunction proxy(target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter() {\n        return this[sourceKey][key];\n    };\n    sharedPropertyDefinition.set = function proxySetter(val) {\n        this[sourceKey][key] = val;\n    };\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n}\nfunction initState(vm) {\n    var opts = vm.$options;\n    if (opts.props)\n        initProps$1(vm, opts.props);\n    // Composition API\n    initSetup(vm);\n    if (opts.methods)\n        initMethods(vm, opts.methods);\n    if (opts.data) {\n        initData(vm);\n    }\n    else {\n        var ob = observe((vm._data = {}));\n        ob && ob.vmCount++;\n    }\n    if (opts.computed)\n        initComputed$1(vm, opts.computed);\n    if (opts.watch && opts.watch !== nativeWatch) {\n        initWatch(vm, opts.watch);\n    }\n}\nfunction initProps$1(vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = (vm._props = shallowReactive({}));\n    // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n    var keys = (vm.$options._propKeys = []);\n    var isRoot = !vm.$parent;\n    // root instance props should be converted\n    if (!isRoot) {\n        toggleObserving(false);\n    }\n    var _loop_1 = function (key) {\n        keys.push(key);\n        var value = validateProp(key, propsOptions, propsData, vm);\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n            var hyphenatedKey = hyphenate(key);\n            if (isReservedAttribute(hyphenatedKey) ||\n                config.isReservedAttr(hyphenatedKey)) {\n                warn(\"\\\"\".concat(hyphenatedKey, \"\\\" is a reserved attribute and cannot be used as component prop.\"), vm);\n            }\n            defineReactive(props, key, value, function () {\n                if (!isRoot && !isUpdatingChildComponent) {\n                    warn(\"Avoid mutating a prop directly since the value will be \" +\n                        \"overwritten whenever the parent component re-renders. \" +\n                        \"Instead, use a data or computed property based on the prop's \" +\n                        \"value. Prop being mutated: \\\"\".concat(key, \"\\\"\"), vm);\n                }\n            });\n        }\n        else {\n            defineReactive(props, key, value);\n        }\n        // static props are already proxied on the component's prototype\n        // during Vue.extend(). We only need to proxy props defined at\n        // instantiation here.\n        if (!(key in vm)) {\n            proxy(vm, \"_props\", key);\n        }\n    };\n    for (var key in propsOptions) {\n        _loop_1(key);\n    }\n    toggleObserving(true);\n}\nfunction initData(vm) {\n    var data = vm.$options.data;\n    data = vm._data = isFunction(data) ? getData(data, vm) : data || {};\n    if (!isPlainObject(data)) {\n        data = {};\n        process.env.NODE_ENV !== 'production' &&\n            warn('data functions should return an object:\\n' +\n                'https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n    }\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n    while (i--) {\n        var key = keys[i];\n        if (process.env.NODE_ENV !== 'production') {\n            if (methods && hasOwn(methods, key)) {\n                warn(\"Method \\\"\".concat(key, \"\\\" has already been defined as a data property.\"), vm);\n            }\n        }\n        if (props && hasOwn(props, key)) {\n            process.env.NODE_ENV !== 'production' &&\n                warn(\"The data property \\\"\".concat(key, \"\\\" is already declared as a prop. \") +\n                    \"Use prop default value instead.\", vm);\n        }\n        else if (!isReserved(key)) {\n            proxy(vm, \"_data\", key);\n        }\n    }\n    // observe data\n    var ob = observe(data);\n    ob && ob.vmCount++;\n}\nfunction getData(data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n    try {\n        return data.call(vm, vm);\n    }\n    catch (e) {\n        handleError(e, vm, \"data()\");\n        return {};\n    }\n    finally {\n        popTarget();\n    }\n}\nvar computedWatcherOptions = { lazy: true };\nfunction initComputed$1(vm, computed) {\n    // $flow-disable-line\n    var watchers = (vm._computedWatchers = Object.create(null));\n    // computed properties are just getters during SSR\n    var isSSR = isServerRendering();\n    for (var key in computed) {\n        var userDef = computed[key];\n        var getter = isFunction(userDef) ? userDef : userDef.get;\n        if (process.env.NODE_ENV !== 'production' && getter == null) {\n            warn(\"Getter is missing for computed property \\\"\".concat(key, \"\\\".\"), vm);\n        }\n        if (!isSSR) {\n            // create internal watcher for the computed property.\n            watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n        }\n        // component-defined computed properties are already defined on the\n        // component prototype. We only need to define computed properties defined\n        // at instantiation here.\n        if (!(key in vm)) {\n            defineComputed(vm, key, userDef);\n        }\n        else if (process.env.NODE_ENV !== 'production') {\n            if (key in vm.$data) {\n                warn(\"The computed property \\\"\".concat(key, \"\\\" is already defined in data.\"), vm);\n            }\n            else if (vm.$options.props && key in vm.$options.props) {\n                warn(\"The computed property \\\"\".concat(key, \"\\\" is already defined as a prop.\"), vm);\n            }\n            else if (vm.$options.methods && key in vm.$options.methods) {\n                warn(\"The computed property \\\"\".concat(key, \"\\\" is already defined as a method.\"), vm);\n            }\n        }\n    }\n}\nfunction defineComputed(target, key, userDef) {\n    var shouldCache = !isServerRendering();\n    if (isFunction(userDef)) {\n        sharedPropertyDefinition.get = shouldCache\n            ? createComputedGetter(key)\n            : createGetterInvoker(userDef);\n        sharedPropertyDefinition.set = noop;\n    }\n    else {\n        sharedPropertyDefinition.get = userDef.get\n            ? shouldCache && userDef.cache !== false\n                ? createComputedGetter(key)\n                : createGetterInvoker(userDef.get)\n            : noop;\n        sharedPropertyDefinition.set = userDef.set || noop;\n    }\n    if (process.env.NODE_ENV !== 'production' && sharedPropertyDefinition.set === noop) {\n        sharedPropertyDefinition.set = function () {\n            warn(\"Computed property \\\"\".concat(key, \"\\\" was assigned to but it has no setter.\"), this);\n        };\n    }\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n}\nfunction createComputedGetter(key) {\n    return function computedGetter() {\n        var watcher = this._computedWatchers && this._computedWatchers[key];\n        if (watcher) {\n            if (watcher.dirty) {\n                watcher.evaluate();\n            }\n            if (Dep.target) {\n                if (process.env.NODE_ENV !== 'production' && Dep.target.onTrack) {\n                    Dep.target.onTrack({\n                        effect: Dep.target,\n                        target: this,\n                        type: \"get\" /* TrackOpTypes.GET */,\n                        key: key\n                    });\n                }\n                watcher.depend();\n            }\n            return watcher.value;\n        }\n    };\n}\nfunction createGetterInvoker(fn) {\n    return function computedGetter() {\n        return fn.call(this, this);\n    };\n}\nfunction initMethods(vm, methods) {\n    var props = vm.$options.props;\n    for (var key in methods) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (typeof methods[key] !== 'function') {\n                warn(\"Method \\\"\".concat(key, \"\\\" has type \\\"\").concat(typeof methods[key], \"\\\" in the component definition. \") +\n                    \"Did you reference the function correctly?\", vm);\n            }\n            if (props && hasOwn(props, key)) {\n                warn(\"Method \\\"\".concat(key, \"\\\" has already been defined as a prop.\"), vm);\n            }\n            if (key in vm && isReserved(key)) {\n                warn(\"Method \\\"\".concat(key, \"\\\" conflicts with an existing Vue instance method. \") +\n                    \"Avoid defining component methods that start with _ or $.\");\n            }\n        }\n        vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n    }\n}\nfunction initWatch(vm, watch) {\n    for (var key in watch) {\n        var handler = watch[key];\n        if (isArray(handler)) {\n            for (var i = 0; i < handler.length; i++) {\n                createWatcher(vm, key, handler[i]);\n            }\n        }\n        else {\n            createWatcher(vm, key, handler);\n        }\n    }\n}\nfunction createWatcher(vm, expOrFn, handler, options) {\n    if (isPlainObject(handler)) {\n        options = handler;\n        handler = handler.handler;\n    }\n    if (typeof handler === 'string') {\n        handler = vm[handler];\n    }\n    return vm.$watch(expOrFn, handler, options);\n}\nfunction stateMixin(Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n    dataDef.get = function () {\n        return this._data;\n    };\n    var propsDef = {};\n    propsDef.get = function () {\n        return this._props;\n    };\n    if (process.env.NODE_ENV !== 'production') {\n        dataDef.set = function () {\n            warn('Avoid replacing instance root $data. ' +\n                'Use nested data properties instead.', this);\n        };\n        propsDef.set = function () {\n            warn(\"$props is readonly.\", this);\n        };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n        var vm = this;\n        if (isPlainObject(cb)) {\n            return createWatcher(vm, expOrFn, cb, options);\n        }\n        options = options || {};\n        options.user = true;\n        var watcher = new Watcher(vm, expOrFn, cb, options);\n        if (options.immediate) {\n            var info = \"callback for immediate watcher \\\"\".concat(watcher.expression, \"\\\"\");\n            pushTarget();\n            invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);\n            popTarget();\n        }\n        return function unwatchFn() {\n            watcher.teardown();\n        };\n    };\n}\n\nvar uid = 0;\nfunction initMixin$1(Vue) {\n    Vue.prototype._init = function (options) {\n        var vm = this;\n        // a uid\n        vm._uid = uid++;\n        var startTag, endTag;\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n            startTag = \"vue-perf-start:\".concat(vm._uid);\n            endTag = \"vue-perf-end:\".concat(vm._uid);\n            mark(startTag);\n        }\n        // a flag to mark this as a Vue instance without having to do instanceof\n        // check\n        vm._isVue = true;\n        // avoid instances from being observed\n        vm.__v_skip = true;\n        // effect scope\n        vm._scope = new EffectScope(true /* detached */);\n        vm._scope._vm = true;\n        // merge options\n        if (options && options._isComponent) {\n            // optimize internal component instantiation\n            // since dynamic options merging is pretty slow, and none of the\n            // internal component options needs special treatment.\n            initInternalComponent(vm, options);\n        }\n        else {\n            vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n        }\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n            initProxy(vm);\n        }\n        else {\n            vm._renderProxy = vm;\n        }\n        // expose real self\n        vm._self = vm;\n        initLifecycle(vm);\n        initEvents(vm);\n        initRender(vm);\n        callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);\n        initInjections(vm); // resolve injections before data/props\n        initState(vm);\n        initProvide(vm); // resolve provide after data/props\n        callHook$1(vm, 'created');\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n            vm._name = formatComponentName(vm, false);\n            mark(endTag);\n            measure(\"vue \".concat(vm._name, \" init\"), startTag, endTag);\n        }\n        if (vm.$options.el) {\n            vm.$mount(vm.$options.el);\n        }\n    };\n}\nfunction initInternalComponent(vm, options) {\n    var opts = (vm.$options = Object.create(vm.constructor.options));\n    // doing this because it's faster than dynamic enumeration.\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n    if (options.render) {\n        opts.render = options.render;\n        opts.staticRenderFns = options.staticRenderFns;\n    }\n}\nfunction resolveConstructorOptions(Ctor) {\n    var options = Ctor.options;\n    if (Ctor.super) {\n        var superOptions = resolveConstructorOptions(Ctor.super);\n        var cachedSuperOptions = Ctor.superOptions;\n        if (superOptions !== cachedSuperOptions) {\n            // super option changed,\n            // need to resolve new options.\n            Ctor.superOptions = superOptions;\n            // check if there are any late-modified/attached options (#4976)\n            var modifiedOptions = resolveModifiedOptions(Ctor);\n            // update base extend options\n            if (modifiedOptions) {\n                extend(Ctor.extendOptions, modifiedOptions);\n            }\n            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n            if (options.name) {\n                options.components[options.name] = Ctor;\n            }\n        }\n    }\n    return options;\n}\nfunction resolveModifiedOptions(Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var sealed = Ctor.sealedOptions;\n    for (var key in latest) {\n        if (latest[key] !== sealed[key]) {\n            if (!modified)\n                modified = {};\n            modified[key] = latest[key];\n        }\n    }\n    return modified;\n}\n\nfunction Vue(options) {\n    if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue)) {\n        warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n    this._init(options);\n}\n//@ts-expect-error Vue has function type\ninitMixin$1(Vue);\n//@ts-expect-error Vue has function type\nstateMixin(Vue);\n//@ts-expect-error Vue has function type\neventsMixin(Vue);\n//@ts-expect-error Vue has function type\nlifecycleMixin(Vue);\n//@ts-expect-error Vue has function type\nrenderMixin(Vue);\n\nfunction initUse(Vue) {\n    Vue.use = function (plugin) {\n        var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n        if (installedPlugins.indexOf(plugin) > -1) {\n            return this;\n        }\n        // additional parameters\n        var args = toArray(arguments, 1);\n        args.unshift(this);\n        if (isFunction(plugin.install)) {\n            plugin.install.apply(plugin, args);\n        }\n        else if (isFunction(plugin)) {\n            plugin.apply(null, args);\n        }\n        installedPlugins.push(plugin);\n        return this;\n    };\n}\n\nfunction initMixin(Vue) {\n    Vue.mixin = function (mixin) {\n        this.options = mergeOptions(this.options, mixin);\n        return this;\n    };\n}\n\nfunction initExtend(Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n    /**\n     * Class inheritance\n     */\n    Vue.extend = function (extendOptions) {\n        extendOptions = extendOptions || {};\n        var Super = this;\n        var SuperId = Super.cid;\n        var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n        if (cachedCtors[SuperId]) {\n            return cachedCtors[SuperId];\n        }\n        var name = getComponentName(extendOptions) || getComponentName(Super.options);\n        if (process.env.NODE_ENV !== 'production' && name) {\n            validateComponentName(name);\n        }\n        var Sub = function VueComponent(options) {\n            this._init(options);\n        };\n        Sub.prototype = Object.create(Super.prototype);\n        Sub.prototype.constructor = Sub;\n        Sub.cid = cid++;\n        Sub.options = mergeOptions(Super.options, extendOptions);\n        Sub['super'] = Super;\n        // For props and computed properties, we define the proxy getters on\n        // the Vue instances at extension time, on the extended prototype. This\n        // avoids Object.defineProperty calls for each instance created.\n        if (Sub.options.props) {\n            initProps(Sub);\n        }\n        if (Sub.options.computed) {\n            initComputed(Sub);\n        }\n        // allow further extension/mixin/plugin usage\n        Sub.extend = Super.extend;\n        Sub.mixin = Super.mixin;\n        Sub.use = Super.use;\n        // create asset registers, so extended classes\n        // can have their private assets too.\n        ASSET_TYPES.forEach(function (type) {\n            Sub[type] = Super[type];\n        });\n        // enable recursive self-lookup\n        if (name) {\n            Sub.options.components[name] = Sub;\n        }\n        // keep a reference to the super options at extension time.\n        // later at instantiation we can check if Super's options have\n        // been updated.\n        Sub.superOptions = Super.options;\n        Sub.extendOptions = extendOptions;\n        Sub.sealedOptions = extend({}, Sub.options);\n        // cache constructor\n        cachedCtors[SuperId] = Sub;\n        return Sub;\n    };\n}\nfunction initProps(Comp) {\n    var props = Comp.options.props;\n    for (var key in props) {\n        proxy(Comp.prototype, \"_props\", key);\n    }\n}\nfunction initComputed(Comp) {\n    var computed = Comp.options.computed;\n    for (var key in computed) {\n        defineComputed(Comp.prototype, key, computed[key]);\n    }\n}\n\nfunction initAssetRegisters(Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n        // @ts-expect-error function is not exact same type\n        Vue[type] = function (id, definition) {\n            if (!definition) {\n                return this.options[type + 's'][id];\n            }\n            else {\n                /* istanbul ignore if */\n                if (process.env.NODE_ENV !== 'production' && type === 'component') {\n                    validateComponentName(id);\n                }\n                if (type === 'component' && isPlainObject(definition)) {\n                    // @ts-expect-error\n                    definition.name = definition.name || id;\n                    definition = this.options._base.extend(definition);\n                }\n                if (type === 'directive' && isFunction(definition)) {\n                    definition = { bind: definition, update: definition };\n                }\n                this.options[type + 's'][id] = definition;\n                return definition;\n            }\n        };\n    });\n}\n\nfunction _getComponentName(opts) {\n    return opts && (getComponentName(opts.Ctor.options) || opts.tag);\n}\nfunction matches(pattern, name) {\n    if (isArray(pattern)) {\n        return pattern.indexOf(name) > -1;\n    }\n    else if (typeof pattern === 'string') {\n        return pattern.split(',').indexOf(name) > -1;\n    }\n    else if (isRegExp(pattern)) {\n        return pattern.test(name);\n    }\n    /* istanbul ignore next */\n    return false;\n}\nfunction pruneCache(keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache, keys = keepAliveInstance.keys, _vnode = keepAliveInstance._vnode;\n    for (var key in cache) {\n        var entry = cache[key];\n        if (entry) {\n            var name_1 = entry.name;\n            if (name_1 && !filter(name_1)) {\n                pruneCacheEntry(cache, key, keys, _vnode);\n            }\n        }\n    }\n}\nfunction pruneCacheEntry(cache, key, keys, current) {\n    var entry = cache[key];\n    if (entry && (!current || entry.tag !== current.tag)) {\n        // @ts-expect-error can be undefined\n        entry.componentInstance.$destroy();\n    }\n    cache[key] = null;\n    remove$2(keys, key);\n}\nvar patternTypes = [String, RegExp, Array];\n// TODO defineComponent\nvar KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n    props: {\n        include: patternTypes,\n        exclude: patternTypes,\n        max: [String, Number]\n    },\n    methods: {\n        cacheVNode: function () {\n            var _a = this, cache = _a.cache, keys = _a.keys, vnodeToCache = _a.vnodeToCache, keyToCache = _a.keyToCache;\n            if (vnodeToCache) {\n                var tag = vnodeToCache.tag, componentInstance = vnodeToCache.componentInstance, componentOptions = vnodeToCache.componentOptions;\n                cache[keyToCache] = {\n                    name: _getComponentName(componentOptions),\n                    tag: tag,\n                    componentInstance: componentInstance\n                };\n                keys.push(keyToCache);\n                // prune oldest entry\n                if (this.max && keys.length > parseInt(this.max)) {\n                    pruneCacheEntry(cache, keys[0], keys, this._vnode);\n                }\n                this.vnodeToCache = null;\n            }\n        }\n    },\n    created: function () {\n        this.cache = Object.create(null);\n        this.keys = [];\n    },\n    destroyed: function () {\n        for (var key in this.cache) {\n            pruneCacheEntry(this.cache, key, this.keys);\n        }\n    },\n    mounted: function () {\n        var _this = this;\n        this.cacheVNode();\n        this.$watch('include', function (val) {\n            pruneCache(_this, function (name) { return matches(val, name); });\n        });\n        this.$watch('exclude', function (val) {\n            pruneCache(_this, function (name) { return !matches(val, name); });\n        });\n    },\n    updated: function () {\n        this.cacheVNode();\n    },\n    render: function () {\n        var slot = this.$slots.default;\n        var vnode = getFirstComponentChild(slot);\n        var componentOptions = vnode && vnode.componentOptions;\n        if (componentOptions) {\n            // check pattern\n            var name_2 = _getComponentName(componentOptions);\n            var _a = this, include = _a.include, exclude = _a.exclude;\n            if (\n            // not included\n            (include && (!name_2 || !matches(include, name_2))) ||\n                // excluded\n                (exclude && name_2 && matches(exclude, name_2))) {\n                return vnode;\n            }\n            var _b = this, cache = _b.cache, keys = _b.keys;\n            var key = vnode.key == null\n                ? // same constructor may get registered as different local components\n                    // so cid alone is not enough (#3269)\n                    componentOptions.Ctor.cid +\n                        (componentOptions.tag ? \"::\".concat(componentOptions.tag) : '')\n                : vnode.key;\n            if (cache[key]) {\n                vnode.componentInstance = cache[key].componentInstance;\n                // make current key freshest\n                remove$2(keys, key);\n                keys.push(key);\n            }\n            else {\n                // delay setting the cache until update\n                this.vnodeToCache = vnode;\n                this.keyToCache = key;\n            }\n            // @ts-expect-error can vnode.data can be undefined\n            vnode.data.keepAlive = true;\n        }\n        return vnode || (slot && slot[0]);\n    }\n};\n\nvar builtInComponents = {\n    KeepAlive: KeepAlive\n};\n\nfunction initGlobalAPI(Vue) {\n    // config\n    var configDef = {};\n    configDef.get = function () { return config; };\n    if (process.env.NODE_ENV !== 'production') {\n        configDef.set = function () {\n            warn('Do not replace the Vue.config object, set individual fields instead.');\n        };\n    }\n    Object.defineProperty(Vue, 'config', configDef);\n    // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n    Vue.util = {\n        warn: warn,\n        extend: extend,\n        mergeOptions: mergeOptions,\n        defineReactive: defineReactive\n    };\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick;\n    // 2.6 explicit observable API\n    Vue.observable = function (obj) {\n        observe(obj);\n        return obj;\n    };\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n        Vue.options[type + 's'] = Object.create(null);\n    });\n    // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n    Vue.options._base = Vue;\n    extend(Vue.options.components, builtInComponents);\n    initUse(Vue);\n    initMixin(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\nObject.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n});\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n    get: function () {\n        /* istanbul ignore next */\n        return this.$vnode && this.$vnode.ssrContext;\n    }\n});\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n});\nVue.version = version;\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n    return ((attr === 'value' && acceptValue(tag) && type !== 'button') ||\n        (attr === 'selected' && tag === 'option') ||\n        (attr === 'checked' && tag === 'input') ||\n        (attr === 'muted' && tag === 'video'));\n};\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\nvar convertEnumeratedValue = function (key, value) {\n    return isFalsyAttrValue(value) || value === 'false'\n        ? 'false'\n        : // allow arbitrary string value for contenteditable\n            key === 'contenteditable' && isValidContentEditableValue(value)\n                ? value\n                : 'true';\n};\nvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n    'required,reversed,scoped,seamless,selected,sortable,' +\n    'truespeed,typemustmatch,visible');\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar isXlink = function (name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n};\nvar getXlinkProp = function (name) {\n    return isXlink(name) ? name.slice(6, name.length) : '';\n};\nvar isFalsyAttrValue = function (val) {\n    return val == null || val === false;\n};\n\nfunction genClassForVnode(vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n    while (isDef(childNode.componentInstance)) {\n        childNode = childNode.componentInstance._vnode;\n        if (childNode && childNode.data) {\n            data = mergeClassData(childNode.data, data);\n        }\n    }\n    // @ts-expect-error parentNode.parent not VNodeWithData\n    while (isDef((parentNode = parentNode.parent))) {\n        if (parentNode && parentNode.data) {\n            data = mergeClassData(data, parentNode.data);\n        }\n    }\n    return renderClass(data.staticClass, data.class);\n}\nfunction mergeClassData(child, parent) {\n    return {\n        staticClass: concat(child.staticClass, parent.staticClass),\n        class: isDef(child.class) ? [child.class, parent.class] : parent.class\n    };\n}\nfunction renderClass(staticClass, dynamicClass) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n        return concat(staticClass, stringifyClass(dynamicClass));\n    }\n    /* istanbul ignore next */\n    return '';\n}\nfunction concat(a, b) {\n    return a ? (b ? a + ' ' + b : a) : b || '';\n}\nfunction stringifyClass(value) {\n    if (Array.isArray(value)) {\n        return stringifyArray(value);\n    }\n    if (isObject(value)) {\n        return stringifyObject(value);\n    }\n    if (typeof value === 'string') {\n        return value;\n    }\n    /* istanbul ignore next */\n    return '';\n}\nfunction stringifyArray(value) {\n    var res = '';\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n        if (isDef((stringified = stringifyClass(value[i]))) && stringified !== '') {\n            if (res)\n                res += ' ';\n            res += stringified;\n        }\n    }\n    return res;\n}\nfunction stringifyObject(value) {\n    var res = '';\n    for (var key in value) {\n        if (value[key]) {\n            if (res)\n                res += ' ';\n            res += key;\n        }\n    }\n    return res;\n}\n\nvar namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n};\nvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +\n    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n    'embed,object,param,source,canvas,script,noscript,del,ins,' +\n    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n    'output,progress,select,textarea,' +\n    'details,dialog,menu,menuitem,summary,' +\n    'content,element,shadow,template,blockquote,iframe,tfoot');\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\nvar isReservedTag = function (tag) {\n    return isHTMLTag(tag) || isSVG(tag);\n};\nfunction getTagNamespace(tag) {\n    if (isSVG(tag)) {\n        return 'svg';\n    }\n    // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n    if (tag === 'math') {\n        return 'math';\n    }\n}\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement(tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n        return true;\n    }\n    if (isReservedTag(tag)) {\n        return false;\n    }\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n    if (unknownElementCache[tag] != null) {\n        return unknownElementCache[tag];\n    }\n    var el = document.createElement(tag);\n    if (tag.indexOf('-') > -1) {\n        // http://stackoverflow.com/a/28210364/1070244\n        return (unknownElementCache[tag] =\n            el.constructor === window.HTMLUnknownElement ||\n                el.constructor === window.HTMLElement);\n    }\n    else {\n        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()));\n    }\n}\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query(el) {\n    if (typeof el === 'string') {\n        var selected = document.querySelector(el);\n        if (!selected) {\n            process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);\n            return document.createElement('div');\n        }\n        return selected;\n    }\n    else {\n        return el;\n    }\n}\n\nfunction createElement(tagName, vnode) {\n    var elm = document.createElement(tagName);\n    if (tagName !== 'select') {\n        return elm;\n    }\n    // false or null will remove the attribute but undefined will not\n    if (vnode.data &&\n        vnode.data.attrs &&\n        vnode.data.attrs.multiple !== undefined) {\n        elm.setAttribute('multiple', 'multiple');\n    }\n    return elm;\n}\nfunction createElementNS(namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName);\n}\nfunction createTextNode(text) {\n    return document.createTextNode(text);\n}\nfunction createComment(text) {\n    return document.createComment(text);\n}\nfunction insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n}\nfunction removeChild(node, child) {\n    node.removeChild(child);\n}\nfunction appendChild(node, child) {\n    node.appendChild(child);\n}\nfunction parentNode(node) {\n    return node.parentNode;\n}\nfunction nextSibling(node) {\n    return node.nextSibling;\n}\nfunction tagName(node) {\n    return node.tagName;\n}\nfunction setTextContent(node, text) {\n    node.textContent = text;\n}\nfunction setStyleScope(node, scopeId) {\n    node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createElement: createElement,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\nvar ref = {\n    create: function (_, vnode) {\n        registerRef(vnode);\n    },\n    update: function (oldVnode, vnode) {\n        if (oldVnode.data.ref !== vnode.data.ref) {\n            registerRef(oldVnode, true);\n            registerRef(vnode);\n        }\n    },\n    destroy: function (vnode) {\n        registerRef(vnode, true);\n    }\n};\nfunction registerRef(vnode, isRemoval) {\n    var ref = vnode.data.ref;\n    if (!isDef(ref))\n        return;\n    var vm = vnode.context;\n    var refValue = vnode.componentInstance || vnode.elm;\n    var value = isRemoval ? null : refValue;\n    var $refsValue = isRemoval ? undefined : refValue;\n    if (isFunction(ref)) {\n        invokeWithErrorHandling(ref, vm, [value], vm, \"template ref function\");\n        return;\n    }\n    var isFor = vnode.data.refInFor;\n    var _isString = typeof ref === 'string' || typeof ref === 'number';\n    var _isRef = isRef(ref);\n    var refs = vm.$refs;\n    if (_isString || _isRef) {\n        if (isFor) {\n            var existing = _isString ? refs[ref] : ref.value;\n            if (isRemoval) {\n                isArray(existing) && remove$2(existing, refValue);\n            }\n            else {\n                if (!isArray(existing)) {\n                    if (_isString) {\n                        refs[ref] = [refValue];\n                        setSetupRef(vm, ref, refs[ref]);\n                    }\n                    else {\n                        ref.value = [refValue];\n                    }\n                }\n                else if (!existing.includes(refValue)) {\n                    existing.push(refValue);\n                }\n            }\n        }\n        else if (_isString) {\n            if (isRemoval && refs[ref] !== refValue) {\n                return;\n            }\n            refs[ref] = $refsValue;\n            setSetupRef(vm, ref, value);\n        }\n        else if (_isRef) {\n            if (isRemoval && ref.value !== refValue) {\n                return;\n            }\n            ref.value = value;\n        }\n        else if (process.env.NODE_ENV !== 'production') {\n            warn(\"Invalid template ref type: \".concat(typeof ref));\n        }\n    }\n}\nfunction setSetupRef(_a, key, val) {\n    var _setupState = _a._setupState;\n    if (_setupState && hasOwn(_setupState, key)) {\n        if (isRef(_setupState[key])) {\n            _setupState[key].value = val;\n        }\n        else {\n            _setupState[key] = val;\n        }\n    }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\nvar emptyNode = new VNode('', {}, []);\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\nfunction sameVnode(a, b) {\n    return (a.key === b.key &&\n        a.asyncFactory === b.asyncFactory &&\n        ((a.tag === b.tag &&\n            a.isComment === b.isComment &&\n            isDef(a.data) === isDef(b.data) &&\n            sameInputType(a, b)) ||\n            (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error))));\n}\nfunction sameInputType(a, b) {\n    if (a.tag !== 'input')\n        return true;\n    var i;\n    var typeA = isDef((i = a.data)) && isDef((i = i.attrs)) && i.type;\n    var typeB = isDef((i = b.data)) && isDef((i = i.attrs)) && i.type;\n    return typeA === typeB || (isTextInputType(typeA) && isTextInputType(typeB));\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n    for (i = beginIdx; i <= endIdx; ++i) {\n        key = children[i].key;\n        if (isDef(key))\n            map[key] = i;\n    }\n    return map;\n}\nfunction createPatchFunction(backend) {\n    var i, j;\n    var cbs = {};\n    var modules = backend.modules, nodeOps = backend.nodeOps;\n    for (i = 0; i < hooks.length; ++i) {\n        cbs[hooks[i]] = [];\n        for (j = 0; j < modules.length; ++j) {\n            if (isDef(modules[j][hooks[i]])) {\n                cbs[hooks[i]].push(modules[j][hooks[i]]);\n            }\n        }\n    }\n    function emptyNodeAt(elm) {\n        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n    }\n    function createRmCb(childElm, listeners) {\n        function remove() {\n            if (--remove.listeners === 0) {\n                removeNode(childElm);\n            }\n        }\n        remove.listeners = listeners;\n        return remove;\n    }\n    function removeNode(el) {\n        var parent = nodeOps.parentNode(el);\n        // element may have already been removed due to v-html / v-text\n        if (isDef(parent)) {\n            nodeOps.removeChild(parent, el);\n        }\n    }\n    function isUnknownElement(vnode, inVPre) {\n        return (!inVPre &&\n            !vnode.ns &&\n            !(config.ignoredElements.length &&\n                config.ignoredElements.some(function (ignore) {\n                    return isRegExp(ignore)\n                        ? ignore.test(vnode.tag)\n                        : ignore === vnode.tag;\n                })) &&\n            config.isUnknownElement(vnode.tag));\n    }\n    var creatingElmInVPre = 0;\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n        if (isDef(vnode.elm) && isDef(ownerArray)) {\n            // This vnode was used in a previous render!\n            // now it's used as a new node, overwriting its elm would cause\n            // potential patch errors down the road when it's used as an insertion\n            // reference node. Instead, we clone the node on-demand before creating\n            // associated DOM element for it.\n            vnode = ownerArray[index] = cloneVNode(vnode);\n        }\n        vnode.isRootInsert = !nested; // for transition enter check\n        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n            return;\n        }\n        var data = vnode.data;\n        var children = vnode.children;\n        var tag = vnode.tag;\n        if (isDef(tag)) {\n            if (process.env.NODE_ENV !== 'production') {\n                if (data && data.pre) {\n                    creatingElmInVPre++;\n                }\n                if (isUnknownElement(vnode, creatingElmInVPre)) {\n                    warn('Unknown custom element: <' +\n                        tag +\n                        '> - did you ' +\n                        'register the component correctly? For recursive components, ' +\n                        'make sure to provide the \"name\" option.', vnode.context);\n                }\n            }\n            vnode.elm = vnode.ns\n                ? nodeOps.createElementNS(vnode.ns, tag)\n                : nodeOps.createElement(tag, vnode);\n            setScope(vnode);\n            createChildren(vnode, children, insertedVnodeQueue);\n            if (isDef(data)) {\n                invokeCreateHooks(vnode, insertedVnodeQueue);\n            }\n            insert(parentElm, vnode.elm, refElm);\n            if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n                creatingElmInVPre--;\n            }\n        }\n        else if (isTrue(vnode.isComment)) {\n            vnode.elm = nodeOps.createComment(vnode.text);\n            insert(parentElm, vnode.elm, refElm);\n        }\n        else {\n            vnode.elm = nodeOps.createTextNode(vnode.text);\n            insert(parentElm, vnode.elm, refElm);\n        }\n    }\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n        var i = vnode.data;\n        if (isDef(i)) {\n            var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n            if (isDef((i = i.hook)) && isDef((i = i.init))) {\n                i(vnode, false /* hydrating */);\n            }\n            // after calling the init hook, if the vnode is a child component\n            // it should've created a child instance and mounted it. the child\n            // component also has set the placeholder vnode's elm.\n            // in that case we can just return the element and be done.\n            if (isDef(vnode.componentInstance)) {\n                initComponent(vnode, insertedVnodeQueue);\n                insert(parentElm, vnode.elm, refElm);\n                if (isTrue(isReactivated)) {\n                    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n                }\n                return true;\n            }\n        }\n    }\n    function initComponent(vnode, insertedVnodeQueue) {\n        if (isDef(vnode.data.pendingInsert)) {\n            insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n            vnode.data.pendingInsert = null;\n        }\n        vnode.elm = vnode.componentInstance.$el;\n        if (isPatchable(vnode)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            setScope(vnode);\n        }\n        else {\n            // empty component root.\n            // skip all element-related modules except for ref (#3455)\n            registerRef(vnode);\n            // make sure to invoke the insert hook\n            insertedVnodeQueue.push(vnode);\n        }\n    }\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n        var i;\n        // hack for #4339: a reactivated component with inner transition\n        // does not trigger because the inner node's created hooks are not called\n        // again. It's not ideal to involve module-specific logic in here but\n        // there doesn't seem to be a better way to do it.\n        var innerNode = vnode;\n        while (innerNode.componentInstance) {\n            innerNode = innerNode.componentInstance._vnode;\n            if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {\n                for (i = 0; i < cbs.activate.length; ++i) {\n                    cbs.activate[i](emptyNode, innerNode);\n                }\n                insertedVnodeQueue.push(innerNode);\n                break;\n            }\n        }\n        // unlike a newly created component,\n        // a reactivated keep-alive component doesn't insert itself\n        insert(parentElm, vnode.elm, refElm);\n    }\n    function insert(parent, elm, ref) {\n        if (isDef(parent)) {\n            if (isDef(ref)) {\n                if (nodeOps.parentNode(ref) === parent) {\n                    nodeOps.insertBefore(parent, elm, ref);\n                }\n            }\n            else {\n                nodeOps.appendChild(parent, elm);\n            }\n        }\n    }\n    function createChildren(vnode, children, insertedVnodeQueue) {\n        if (isArray(children)) {\n            if (process.env.NODE_ENV !== 'production') {\n                checkDuplicateKeys(children);\n            }\n            for (var i_1 = 0; i_1 < children.length; ++i_1) {\n                createElm(children[i_1], insertedVnodeQueue, vnode.elm, null, true, children, i_1);\n            }\n        }\n        else if (isPrimitive(vnode.text)) {\n            nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n        }\n    }\n    function isPatchable(vnode) {\n        while (vnode.componentInstance) {\n            vnode = vnode.componentInstance._vnode;\n        }\n        return isDef(vnode.tag);\n    }\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\n        for (var i_2 = 0; i_2 < cbs.create.length; ++i_2) {\n            cbs.create[i_2](emptyNode, vnode);\n        }\n        i = vnode.data.hook; // Reuse variable\n        if (isDef(i)) {\n            if (isDef(i.create))\n                i.create(emptyNode, vnode);\n            if (isDef(i.insert))\n                insertedVnodeQueue.push(vnode);\n        }\n    }\n    // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n    function setScope(vnode) {\n        var i;\n        if (isDef((i = vnode.fnScopeId))) {\n            nodeOps.setStyleScope(vnode.elm, i);\n        }\n        else {\n            var ancestor = vnode;\n            while (ancestor) {\n                if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {\n                    nodeOps.setStyleScope(vnode.elm, i);\n                }\n                ancestor = ancestor.parent;\n            }\n        }\n        // for slot content they should also get the scopeId from the host instance.\n        if (isDef((i = activeInstance)) &&\n            i !== vnode.context &&\n            i !== vnode.fnContext &&\n            isDef((i = i.$options._scopeId))) {\n            nodeOps.setStyleScope(vnode.elm, i);\n        }\n    }\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n        }\n    }\n    function invokeDestroyHook(vnode) {\n        var i, j;\n        var data = vnode.data;\n        if (isDef(data)) {\n            if (isDef((i = data.hook)) && isDef((i = i.destroy)))\n                i(vnode);\n            for (i = 0; i < cbs.destroy.length; ++i)\n                cbs.destroy[i](vnode);\n        }\n        if (isDef((i = vnode.children))) {\n            for (j = 0; j < vnode.children.length; ++j) {\n                invokeDestroyHook(vnode.children[j]);\n            }\n        }\n    }\n    function removeVnodes(vnodes, startIdx, endIdx) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            var ch = vnodes[startIdx];\n            if (isDef(ch)) {\n                if (isDef(ch.tag)) {\n                    removeAndInvokeRemoveHook(ch);\n                    invokeDestroyHook(ch);\n                }\n                else {\n                    // Text node\n                    removeNode(ch.elm);\n                }\n            }\n        }\n    }\n    function removeAndInvokeRemoveHook(vnode, rm) {\n        if (isDef(rm) || isDef(vnode.data)) {\n            var i_3;\n            var listeners = cbs.remove.length + 1;\n            if (isDef(rm)) {\n                // we have a recursively passed down rm callback\n                // increase the listeners count\n                rm.listeners += listeners;\n            }\n            else {\n                // directly removing\n                rm = createRmCb(vnode.elm, listeners);\n            }\n            // recursively invoke hooks on child component root node\n            if (isDef((i_3 = vnode.componentInstance)) &&\n                isDef((i_3 = i_3._vnode)) &&\n                isDef(i_3.data)) {\n                removeAndInvokeRemoveHook(i_3, rm);\n            }\n            for (i_3 = 0; i_3 < cbs.remove.length; ++i_3) {\n                cbs.remove[i_3](vnode, rm);\n            }\n            if (isDef((i_3 = vnode.data.hook)) && isDef((i_3 = i_3.remove))) {\n                i_3(vnode, rm);\n            }\n            else {\n                rm();\n            }\n        }\n        else {\n            removeNode(vnode.elm);\n        }\n    }\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n        var oldStartIdx = 0;\n        var newStartIdx = 0;\n        var oldEndIdx = oldCh.length - 1;\n        var oldStartVnode = oldCh[0];\n        var oldEndVnode = oldCh[oldEndIdx];\n        var newEndIdx = newCh.length - 1;\n        var newStartVnode = newCh[0];\n        var newEndVnode = newCh[newEndIdx];\n        var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n        // removeOnly is a special flag used only by <transition-group>\n        // to ensure removed elements stay in correct relative positions\n        // during leaving transitions\n        var canMove = !removeOnly;\n        if (process.env.NODE_ENV !== 'production') {\n            checkDuplicateKeys(newCh);\n        }\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n            if (isUndef(oldStartVnode)) {\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n            }\n            else if (isUndef(oldEndVnode)) {\n                oldEndVnode = oldCh[--oldEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n                oldStartVnode = oldCh[++oldStartIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newEndVnode)) {\n                // Vnode moved right\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n                canMove &&\n                    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n                oldStartVnode = oldCh[++oldStartIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldEndVnode, newStartVnode)) {\n                // Vnode moved left\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n                canMove &&\n                    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                if (isUndef(oldKeyToIdx))\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n                idxInOld = isDef(newStartVnode.key)\n                    ? oldKeyToIdx[newStartVnode.key]\n                    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n                if (isUndef(idxInOld)) {\n                    // New element\n                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n                }\n                else {\n                    vnodeToMove = oldCh[idxInOld];\n                    if (sameVnode(vnodeToMove, newStartVnode)) {\n                        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n                        oldCh[idxInOld] = undefined;\n                        canMove &&\n                            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n                    }\n                    else {\n                        // same key but different element. treat as new element\n                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n                    }\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n        }\n        if (oldStartIdx > oldEndIdx) {\n            refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n            addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n        }\n        else if (newStartIdx > newEndIdx) {\n            removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n        }\n    }\n    function checkDuplicateKeys(children) {\n        var seenKeys = {};\n        for (var i_4 = 0; i_4 < children.length; i_4++) {\n            var vnode = children[i_4];\n            var key = vnode.key;\n            if (isDef(key)) {\n                if (seenKeys[key]) {\n                    warn(\"Duplicate keys detected: '\".concat(key, \"'. This may cause an update error.\"), vnode.context);\n                }\n                else {\n                    seenKeys[key] = true;\n                }\n            }\n        }\n    }\n    function findIdxInOld(node, oldCh, start, end) {\n        for (var i_5 = start; i_5 < end; i_5++) {\n            var c = oldCh[i_5];\n            if (isDef(c) && sameVnode(node, c))\n                return i_5;\n        }\n    }\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\n        if (oldVnode === vnode) {\n            return;\n        }\n        if (isDef(vnode.elm) && isDef(ownerArray)) {\n            // clone reused vnode\n            vnode = ownerArray[index] = cloneVNode(vnode);\n        }\n        var elm = (vnode.elm = oldVnode.elm);\n        if (isTrue(oldVnode.isAsyncPlaceholder)) {\n            if (isDef(vnode.asyncFactory.resolved)) {\n                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n            }\n            else {\n                vnode.isAsyncPlaceholder = true;\n            }\n            return;\n        }\n        // reuse element for static trees.\n        // note we only do this if the vnode is cloned -\n        // if the new node is not cloned it means the render functions have been\n        // reset by the hot-reload-api and we need to do a proper re-render.\n        if (isTrue(vnode.isStatic) &&\n            isTrue(oldVnode.isStatic) &&\n            vnode.key === oldVnode.key &&\n            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n            vnode.componentInstance = oldVnode.componentInstance;\n            return;\n        }\n        var i;\n        var data = vnode.data;\n        if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {\n            i(oldVnode, vnode);\n        }\n        var oldCh = oldVnode.children;\n        var ch = vnode.children;\n        if (isDef(data) && isPatchable(vnode)) {\n            for (i = 0; i < cbs.update.length; ++i)\n                cbs.update[i](oldVnode, vnode);\n            if (isDef((i = data.hook)) && isDef((i = i.update)))\n                i(oldVnode, vnode);\n        }\n        if (isUndef(vnode.text)) {\n            if (isDef(oldCh) && isDef(ch)) {\n                if (oldCh !== ch)\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n            }\n            else if (isDef(ch)) {\n                if (process.env.NODE_ENV !== 'production') {\n                    checkDuplicateKeys(ch);\n                }\n                if (isDef(oldVnode.text))\n                    nodeOps.setTextContent(elm, '');\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n            }\n            else if (isDef(oldCh)) {\n                removeVnodes(oldCh, 0, oldCh.length - 1);\n            }\n            else if (isDef(oldVnode.text)) {\n                nodeOps.setTextContent(elm, '');\n            }\n        }\n        else if (oldVnode.text !== vnode.text) {\n            nodeOps.setTextContent(elm, vnode.text);\n        }\n        if (isDef(data)) {\n            if (isDef((i = data.hook)) && isDef((i = i.postpatch)))\n                i(oldVnode, vnode);\n        }\n    }\n    function invokeInsertHook(vnode, queue, initial) {\n        // delay insert hooks for component root nodes, invoke them after the\n        // element is really inserted\n        if (isTrue(initial) && isDef(vnode.parent)) {\n            vnode.parent.data.pendingInsert = queue;\n        }\n        else {\n            for (var i_6 = 0; i_6 < queue.length; ++i_6) {\n                queue[i_6].data.hook.insert(queue[i_6]);\n            }\n        }\n    }\n    var hydrationBailed = false;\n    // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n        var i;\n        var tag = vnode.tag, data = vnode.data, children = vnode.children;\n        inVPre = inVPre || (data && data.pre);\n        vnode.elm = elm;\n        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n            vnode.isAsyncPlaceholder = true;\n            return true;\n        }\n        // assert node match\n        if (process.env.NODE_ENV !== 'production') {\n            if (!assertNodeMatch(elm, vnode, inVPre)) {\n                return false;\n            }\n        }\n        if (isDef(data)) {\n            if (isDef((i = data.hook)) && isDef((i = i.init)))\n                i(vnode, true /* hydrating */);\n            if (isDef((i = vnode.componentInstance))) {\n                // child component. it should have hydrated its own tree.\n                initComponent(vnode, insertedVnodeQueue);\n                return true;\n            }\n        }\n        if (isDef(tag)) {\n            if (isDef(children)) {\n                // empty element, allow client to pick up and populate children\n                if (!elm.hasChildNodes()) {\n                    createChildren(vnode, children, insertedVnodeQueue);\n                }\n                else {\n                    // v-html and domProps: innerHTML\n                    if (isDef((i = data)) &&\n                        isDef((i = i.domProps)) &&\n                        isDef((i = i.innerHTML))) {\n                        if (i !== elm.innerHTML) {\n                            /* istanbul ignore if */\n                            if (process.env.NODE_ENV !== 'production' &&\n                                typeof console !== 'undefined' &&\n                                !hydrationBailed) {\n                                hydrationBailed = true;\n                                console.warn('Parent: ', elm);\n                                console.warn('server innerHTML: ', i);\n                                console.warn('client innerHTML: ', elm.innerHTML);\n                            }\n                            return false;\n                        }\n                    }\n                    else {\n                        // iterate and compare children lists\n                        var childrenMatch = true;\n                        var childNode = elm.firstChild;\n                        for (var i_7 = 0; i_7 < children.length; i_7++) {\n                            if (!childNode ||\n                                !hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)) {\n                                childrenMatch = false;\n                                break;\n                            }\n                            childNode = childNode.nextSibling;\n                        }\n                        // if childNode is not null, it means the actual childNodes list is\n                        // longer than the virtual children list.\n                        if (!childrenMatch || childNode) {\n                            /* istanbul ignore if */\n                            if (process.env.NODE_ENV !== 'production' &&\n                                typeof console !== 'undefined' &&\n                                !hydrationBailed) {\n                                hydrationBailed = true;\n                                console.warn('Parent: ', elm);\n                                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                            }\n                            return false;\n                        }\n                    }\n                }\n            }\n            if (isDef(data)) {\n                var fullInvoke = false;\n                for (var key in data) {\n                    if (!isRenderedModule(key)) {\n                        fullInvoke = true;\n                        invokeCreateHooks(vnode, insertedVnodeQueue);\n                        break;\n                    }\n                }\n                if (!fullInvoke && data['class']) {\n                    // ensure collecting deps for deep class bindings for future updates\n                    traverse(data['class']);\n                }\n            }\n        }\n        else if (elm.data !== vnode.text) {\n            elm.data = vnode.text;\n        }\n        return true;\n    }\n    function assertNodeMatch(node, vnode, inVPre) {\n        if (isDef(vnode.tag)) {\n            return (vnode.tag.indexOf('vue-component') === 0 ||\n                (!isUnknownElement(vnode, inVPre) &&\n                    vnode.tag.toLowerCase() ===\n                        (node.tagName && node.tagName.toLowerCase())));\n        }\n        else {\n            return node.nodeType === (vnode.isComment ? 8 : 3);\n        }\n    }\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\n        if (isUndef(vnode)) {\n            if (isDef(oldVnode))\n                invokeDestroyHook(oldVnode);\n            return;\n        }\n        var isInitialPatch = false;\n        var insertedVnodeQueue = [];\n        if (isUndef(oldVnode)) {\n            // empty mount (likely as component), create new root element\n            isInitialPatch = true;\n            createElm(vnode, insertedVnodeQueue);\n        }\n        else {\n            var isRealElement = isDef(oldVnode.nodeType);\n            if (!isRealElement && sameVnode(oldVnode, vnode)) {\n                // patch existing root node\n                patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n            }\n            else {\n                if (isRealElement) {\n                    // mounting to a real element\n                    // check if this is server-rendered content and if we can perform\n                    // a successful hydration.\n                    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n                        oldVnode.removeAttribute(SSR_ATTR);\n                        hydrating = true;\n                    }\n                    if (isTrue(hydrating)) {\n                        if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                            invokeInsertHook(vnode, insertedVnodeQueue, true);\n                            return oldVnode;\n                        }\n                        else if (process.env.NODE_ENV !== 'production') {\n                            warn('The client-side rendered virtual DOM tree is not matching ' +\n                                'server-rendered content. This is likely caused by incorrect ' +\n                                'HTML markup, for example nesting block-level elements inside ' +\n                                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                                'full client-side render.');\n                        }\n                    }\n                    // either not server-rendered, or hydration failed.\n                    // create an empty node and replace it\n                    oldVnode = emptyNodeAt(oldVnode);\n                }\n                // replacing existing element\n                var oldElm = oldVnode.elm;\n                var parentElm = nodeOps.parentNode(oldElm);\n                // create new node\n                createElm(vnode, insertedVnodeQueue, \n                // extremely rare edge case: do not insert if old element is in a\n                // leaving transition. Only happens when combining transition +\n                // keep-alive + HOCs. (#4590)\n                oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));\n                // update parent placeholder node element, recursively\n                if (isDef(vnode.parent)) {\n                    var ancestor = vnode.parent;\n                    var patchable = isPatchable(vnode);\n                    while (ancestor) {\n                        for (var i_8 = 0; i_8 < cbs.destroy.length; ++i_8) {\n                            cbs.destroy[i_8](ancestor);\n                        }\n                        ancestor.elm = vnode.elm;\n                        if (patchable) {\n                            for (var i_9 = 0; i_9 < cbs.create.length; ++i_9) {\n                                cbs.create[i_9](emptyNode, ancestor);\n                            }\n                            // #6513\n                            // invoke insert hooks that may have been merged by create hooks.\n                            // e.g. for directives that uses the \"inserted\" hook.\n                            var insert_1 = ancestor.data.hook.insert;\n                            if (insert_1.merged) {\n                                // start at index 1 to avoid re-invoking component mounted hook\n                                for (var i_10 = 1; i_10 < insert_1.fns.length; i_10++) {\n                                    insert_1.fns[i_10]();\n                                }\n                            }\n                        }\n                        else {\n                            registerRef(ancestor);\n                        }\n                        ancestor = ancestor.parent;\n                    }\n                }\n                // destroy old node\n                if (isDef(parentElm)) {\n                    removeVnodes([oldVnode], 0, 0);\n                }\n                else if (isDef(oldVnode.tag)) {\n                    invokeDestroyHook(oldVnode);\n                }\n            }\n        }\n        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n        return vnode.elm;\n    };\n}\n\nvar directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives(vnode) {\n        // @ts-expect-error emptyNode is not VNodeWithData\n        updateDirectives(vnode, emptyNode);\n    }\n};\nfunction updateDirectives(oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n        _update(oldVnode, vnode);\n    }\n}\nfunction _update(oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n    var key, oldDir, dir;\n    for (key in newDirs) {\n        oldDir = oldDirs[key];\n        dir = newDirs[key];\n        if (!oldDir) {\n            // new directive, bind\n            callHook(dir, 'bind', vnode, oldVnode);\n            if (dir.def && dir.def.inserted) {\n                dirsWithInsert.push(dir);\n            }\n        }\n        else {\n            // existing directive, update\n            dir.oldValue = oldDir.value;\n            dir.oldArg = oldDir.arg;\n            callHook(dir, 'update', vnode, oldVnode);\n            if (dir.def && dir.def.componentUpdated) {\n                dirsWithPostpatch.push(dir);\n            }\n        }\n    }\n    if (dirsWithInsert.length) {\n        var callInsert = function () {\n            for (var i = 0; i < dirsWithInsert.length; i++) {\n                callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n            }\n        };\n        if (isCreate) {\n            mergeVNodeHook(vnode, 'insert', callInsert);\n        }\n        else {\n            callInsert();\n        }\n    }\n    if (dirsWithPostpatch.length) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n            for (var i = 0; i < dirsWithPostpatch.length; i++) {\n                callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n            }\n        });\n    }\n    if (!isCreate) {\n        for (key in oldDirs) {\n            if (!newDirs[key]) {\n                // no longer present, unbind\n                callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n            }\n        }\n    }\n}\nvar emptyModifiers = Object.create(null);\nfunction normalizeDirectives(dirs, vm) {\n    var res = Object.create(null);\n    if (!dirs) {\n        // $flow-disable-line\n        return res;\n    }\n    var i, dir;\n    for (i = 0; i < dirs.length; i++) {\n        dir = dirs[i];\n        if (!dir.modifiers) {\n            // $flow-disable-line\n            dir.modifiers = emptyModifiers;\n        }\n        res[getRawDirName(dir)] = dir;\n        if (vm._setupState && vm._setupState.__sfc) {\n            var setupDef = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);\n            if (typeof setupDef === 'function') {\n                dir.def = {\n                    bind: setupDef,\n                    update: setupDef,\n                };\n            }\n            else {\n                dir.def = setupDef;\n            }\n        }\n        dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);\n    }\n    // $flow-disable-line\n    return res;\n}\nfunction getRawDirName(dir) {\n    return (dir.rawName || \"\".concat(dir.name, \".\").concat(Object.keys(dir.modifiers || {}).join('.')));\n}\nfunction callHook(dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n    if (fn) {\n        try {\n            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n        }\n        catch (e) {\n            handleError(e, vnode.context, \"directive \".concat(dir.name, \" \").concat(hook, \" hook\"));\n        }\n    }\n}\n\nvar baseModules = [ref, directives];\n\nfunction updateAttrs(oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n        return;\n    }\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n        return;\n    }\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {\n        attrs = vnode.data.attrs = extend({}, attrs);\n    }\n    for (key in attrs) {\n        cur = attrs[key];\n        old = oldAttrs[key];\n        if (old !== cur) {\n            setAttr(elm, key, cur, vnode.data.pre);\n        }\n    }\n    // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n    /* istanbul ignore if */\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n        setAttr(elm, 'value', attrs.value);\n    }\n    for (key in oldAttrs) {\n        if (isUndef(attrs[key])) {\n            if (isXlink(key)) {\n                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n            }\n            else if (!isEnumeratedAttr(key)) {\n                elm.removeAttribute(key);\n            }\n        }\n    }\n}\nfunction setAttr(el, key, value, isInPre) {\n    if (isInPre || el.tagName.indexOf('-') > -1) {\n        baseSetAttr(el, key, value);\n    }\n    else if (isBooleanAttr(key)) {\n        // set attribute for blank value\n        // e.g. <option disabled>Select one</option>\n        if (isFalsyAttrValue(value)) {\n            el.removeAttribute(key);\n        }\n        else {\n            // technically allowfullscreen is a boolean attribute for <iframe>,\n            // but Flash expects a value of \"true\" when used on <embed> tag\n            value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n            el.setAttribute(key, value);\n        }\n    }\n    else if (isEnumeratedAttr(key)) {\n        el.setAttribute(key, convertEnumeratedValue(key, value));\n    }\n    else if (isXlink(key)) {\n        if (isFalsyAttrValue(value)) {\n            el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        }\n        else {\n            el.setAttributeNS(xlinkNS, key, value);\n        }\n    }\n    else {\n        baseSetAttr(el, key, value);\n    }\n}\nfunction baseSetAttr(el, key, value) {\n    if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n    }\n    else {\n        // #7138: IE10 & 11 fires input event when setting placeholder on\n        // <textarea>... block the first input event and remove the blocker\n        // immediately.\n        /* istanbul ignore if */\n        if (isIE &&\n            !isIE9 &&\n            el.tagName === 'TEXTAREA' &&\n            key === 'placeholder' &&\n            value !== '' &&\n            !el.__ieph) {\n            var blocker_1 = function (e) {\n                e.stopImmediatePropagation();\n                el.removeEventListener('input', blocker_1);\n            };\n            el.addEventListener('input', blocker_1);\n            // $flow-disable-line\n            el.__ieph = true; /* IE placeholder patched */\n        }\n        el.setAttribute(key, value);\n    }\n}\nvar attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n};\n\nfunction updateClass(oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n    if (isUndef(data.staticClass) &&\n        isUndef(data.class) &&\n        (isUndef(oldData) ||\n            (isUndef(oldData.staticClass) && isUndef(oldData.class)))) {\n        return;\n    }\n    var cls = genClassForVnode(vnode);\n    // handle transition classes\n    var transitionClass = el._transitionClasses;\n    if (isDef(transitionClass)) {\n        cls = concat(cls, stringifyClass(transitionClass));\n    }\n    // set the class\n    if (cls !== el._prevClass) {\n        el.setAttribute('class', cls);\n        el._prevClass = cls;\n    }\n}\nvar klass = {\n    create: updateClass,\n    update: updateClass\n};\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents(on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n        // IE input[type=range] only supports `change` event\n        var event_1 = isIE ? 'change' : 'input';\n        on[event_1] = [].concat(on[RANGE_TOKEN], on[event_1] || []);\n        delete on[RANGE_TOKEN];\n    }\n    // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n    /* istanbul ignore if */\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n        delete on[CHECKBOX_RADIO_TOKEN];\n    }\n}\nvar target;\nfunction createOnceHandler(event, handler, capture) {\n    var _target = target; // save current target element in closure\n    return function onceHandler() {\n        var res = handler.apply(null, arguments);\n        if (res !== null) {\n            remove(event, onceHandler, capture, _target);\n        }\n    };\n}\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\nfunction add(name, handler, capture, passive) {\n    // async edge case #6566: inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // the solution is simple: we save the timestamp when a handler is attached,\n    // and the handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (useMicrotaskFix) {\n        var attachedTimestamp_1 = currentFlushTimestamp;\n        var original_1 = handler;\n        //@ts-expect-error\n        handler = original_1._wrapper = function (e) {\n            if (\n            // no bubbling, should always fire.\n            // this is just a safety net in case event.timeStamp is unreliable in\n            // certain weird environments...\n            e.target === e.currentTarget ||\n                // event is fired after handler attachment\n                e.timeStamp >= attachedTimestamp_1 ||\n                // bail for environments that have buggy event.timeStamp implementations\n                // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n                // #9681 QtWebEngine event.timeStamp is negative value\n                e.timeStamp <= 0 ||\n                // #9448 bail if event is fired in another document in a multi-page\n                // electron/nw.js app, since event.timeStamp will be using a different\n                // starting reference\n                e.target.ownerDocument !== document) {\n                return original_1.apply(this, arguments);\n            }\n        };\n    }\n    target.addEventListener(name, handler, supportsPassive ? { capture: capture, passive: passive } : capture);\n}\nfunction remove(name, handler, capture, _target) {\n    (_target || target).removeEventListener(name, \n    //@ts-expect-error\n    handler._wrapper || handler, capture);\n}\nfunction updateDOMListeners(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n        return;\n    }\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    // vnode is empty when removing all listeners,\n    // and use old vnode dom element\n    target = vnode.elm || oldVnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);\n    target = undefined;\n}\nvar events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners,\n    // @ts-expect-error emptyNode has actually data\n    destroy: function (vnode) { return updateDOMListeners(vnode, emptyNode); }\n};\n\nvar svgContainer;\nfunction updateDOMProps(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n        return;\n    }\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {\n        props = vnode.data.domProps = extend({}, props);\n    }\n    for (key in oldProps) {\n        if (!(key in props)) {\n            elm[key] = '';\n        }\n    }\n    for (key in props) {\n        cur = props[key];\n        // ignore children if the node has textContent or innerHTML,\n        // as these will throw away existing DOM nodes and cause removal errors\n        // on subsequent patches (#3360)\n        if (key === 'textContent' || key === 'innerHTML') {\n            if (vnode.children)\n                vnode.children.length = 0;\n            if (cur === oldProps[key])\n                continue;\n            // #6601 work around Chrome version <= 55 bug where single textNode\n            // replaced by innerHTML/textContent retains its parentNode property\n            if (elm.childNodes.length === 1) {\n                elm.removeChild(elm.childNodes[0]);\n            }\n        }\n        if (key === 'value' && elm.tagName !== 'PROGRESS') {\n            // store value as _value as well since\n            // non-string values will be stringified\n            elm._value = cur;\n            // avoid resetting cursor position when value is the same\n            var strCur = isUndef(cur) ? '' : String(cur);\n            if (shouldUpdateValue(elm, strCur)) {\n                elm.value = strCur;\n            }\n        }\n        else if (key === 'innerHTML' &&\n            isSVG(elm.tagName) &&\n            isUndef(elm.innerHTML)) {\n            // IE doesn't support innerHTML for SVG elements\n            svgContainer = svgContainer || document.createElement('div');\n            svgContainer.innerHTML = \"<svg>\".concat(cur, \"</svg>\");\n            var svg = svgContainer.firstChild;\n            while (elm.firstChild) {\n                elm.removeChild(elm.firstChild);\n            }\n            while (svg.firstChild) {\n                elm.appendChild(svg.firstChild);\n            }\n        }\n        else if (\n        // skip the update if old and new VDOM state is the same.\n        // `value` is handled separately because the DOM value may be temporarily\n        // out of sync with VDOM state due to focus, composition and modifiers.\n        // This  #4521 by skipping the unnecessary `checked` update.\n        cur !== oldProps[key]) {\n            // some property updates can throw\n            // e.g. `value` on <progress> w/ non-finite value\n            try {\n                elm[key] = cur;\n            }\n            catch (e) { }\n        }\n    }\n}\nfunction shouldUpdateValue(elm, checkVal) {\n    return (\n    //@ts-expect-error\n    !elm.composing &&\n        (elm.tagName === 'OPTION' ||\n            isNotInFocusAndDirty(elm, checkVal) ||\n            isDirtyWithModifiers(elm, checkVal)));\n}\nfunction isNotInFocusAndDirty(elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true;\n    // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n    try {\n        notInFocus = document.activeElement !== elm;\n    }\n    catch (e) { }\n    return notInFocus && elm.value !== checkVal;\n}\nfunction isDirtyWithModifiers(elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n    if (isDef(modifiers)) {\n        if (modifiers.number) {\n            return toNumber(value) !== toNumber(newVal);\n        }\n        if (modifiers.trim) {\n            return value.trim() !== newVal.trim();\n        }\n    }\n    return value !== newVal;\n}\nvar domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n};\n\nvar parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n        if (item) {\n            var tmp = item.split(propertyDelimiter);\n            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n        }\n    });\n    return res;\n});\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData(data) {\n    var style = normalizeStyleBinding(data.style);\n    // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\n}\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding(bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n        return toObject(bindingStyle);\n    }\n    if (typeof bindingStyle === 'string') {\n        return parseStyleText(bindingStyle);\n    }\n    return bindingStyle;\n}\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle(vnode, checkChild) {\n    var res = {};\n    var styleData;\n    if (checkChild) {\n        var childNode = vnode;\n        while (childNode.componentInstance) {\n            childNode = childNode.componentInstance._vnode;\n            if (childNode &&\n                childNode.data &&\n                (styleData = normalizeStyleData(childNode.data))) {\n                extend(res, styleData);\n            }\n        }\n    }\n    if ((styleData = normalizeStyleData(vnode.data))) {\n        extend(res, styleData);\n    }\n    var parentNode = vnode;\n    // @ts-expect-error parentNode.parent not VNodeWithData\n    while ((parentNode = parentNode.parent)) {\n        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n            extend(res, styleData);\n        }\n    }\n    return res;\n}\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n        el.style.setProperty(name, val);\n    }\n    else if (importantRE.test(val)) {\n        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n    }\n    else {\n        var normalizedName = normalize(name);\n        if (Array.isArray(val)) {\n            // Support values array created by autoprefixer, e.g.\n            // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n            // Set them one by one, and the browser will only set those it can recognize\n            for (var i = 0, len = val.length; i < len; i++) {\n                el.style[normalizedName] = val[i];\n            }\n        }\n        else {\n            el.style[normalizedName] = val;\n        }\n    }\n};\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n    if (prop !== 'filter' && prop in emptyStyle) {\n        return prop;\n    }\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n    for (var i = 0; i < vendorNames.length; i++) {\n        var name_1 = vendorNames[i] + capName;\n        if (name_1 in emptyStyle) {\n            return name_1;\n        }\n    }\n});\nfunction updateStyle(oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n    if (isUndef(data.staticStyle) &&\n        isUndef(data.style) &&\n        isUndef(oldData.staticStyle) &&\n        isUndef(oldData.style)) {\n        return;\n    }\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n    var style = normalizeStyleBinding(vnode.data.style) || {};\n    // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n    var newStyle = getStyle(vnode, true);\n    for (name in oldStyle) {\n        if (isUndef(newStyle[name])) {\n            setProp(el, name, '');\n        }\n    }\n    for (name in newStyle) {\n        cur = newStyle[name];\n        if (cur !== oldStyle[name]) {\n            // ie9 setting to null has no effect, must use empty string\n            setProp(el, name, cur == null ? '' : cur);\n        }\n    }\n}\nvar style = {\n    create: updateStyle,\n    update: updateStyle\n};\n\nvar whitespaceRE = /\\s+/;\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n        return;\n    }\n    /* istanbul ignore else */\n    if (el.classList) {\n        if (cls.indexOf(' ') > -1) {\n            cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n        }\n        else {\n            el.classList.add(cls);\n        }\n    }\n    else {\n        var cur = \" \".concat(el.getAttribute('class') || '', \" \");\n        if (cur.indexOf(' ' + cls + ' ') < 0) {\n            el.setAttribute('class', (cur + cls).trim());\n        }\n    }\n}\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n        return;\n    }\n    /* istanbul ignore else */\n    if (el.classList) {\n        if (cls.indexOf(' ') > -1) {\n            cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n        }\n        else {\n            el.classList.remove(cls);\n        }\n        if (!el.classList.length) {\n            el.removeAttribute('class');\n        }\n    }\n    else {\n        var cur = \" \".concat(el.getAttribute('class') || '', \" \");\n        var tar = ' ' + cls + ' ';\n        while (cur.indexOf(tar) >= 0) {\n            cur = cur.replace(tar, ' ');\n        }\n        cur = cur.trim();\n        if (cur) {\n            el.setAttribute('class', cur);\n        }\n        else {\n            el.removeAttribute('class');\n        }\n    }\n}\n\nfunction resolveTransition(def) {\n    if (!def) {\n        return;\n    }\n    /* istanbul ignore else */\n    if (typeof def === 'object') {\n        var res = {};\n        if (def.css !== false) {\n            extend(res, autoCssTransition(def.name || 'v'));\n        }\n        extend(res, def);\n        return res;\n    }\n    else if (typeof def === 'string') {\n        return autoCssTransition(def);\n    }\n}\nvar autoCssTransition = cached(function (name) {\n    return {\n        enterClass: \"\".concat(name, \"-enter\"),\n        enterToClass: \"\".concat(name, \"-enter-to\"),\n        enterActiveClass: \"\".concat(name, \"-enter-active\"),\n        leaveClass: \"\".concat(name, \"-leave\"),\n        leaveToClass: \"\".concat(name, \"-leave-to\"),\n        leaveActiveClass: \"\".concat(name, \"-leave-active\")\n    };\n});\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined &&\n        window.onwebkittransitionend !== undefined) {\n        transitionProp = 'WebkitTransition';\n        transitionEndEvent = 'webkitTransitionEnd';\n    }\n    if (window.onanimationend === undefined &&\n        window.onwebkitanimationend !== undefined) {\n        animationProp = 'WebkitAnimation';\n        animationEndEvent = 'webkitAnimationEnd';\n    }\n}\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n    ? window.requestAnimationFrame\n        ? window.requestAnimationFrame.bind(window)\n        : setTimeout\n    : /* istanbul ignore next */ function (/* istanbul ignore next */ fn) { return fn(); };\nfunction nextFrame(fn) {\n    raf(function () {\n        // @ts-expect-error\n        raf(fn);\n    });\n}\nfunction addTransitionClass(el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n    if (transitionClasses.indexOf(cls) < 0) {\n        transitionClasses.push(cls);\n        addClass(el, cls);\n    }\n}\nfunction removeTransitionClass(el, cls) {\n    if (el._transitionClasses) {\n        remove$2(el._transitionClasses, cls);\n    }\n    removeClass(el, cls);\n}\nfunction whenTransitionEnds(el, expectedType, cb) {\n    var _a = getTransitionInfo(el, expectedType), type = _a.type, timeout = _a.timeout, propCount = _a.propCount;\n    if (!type)\n        return cb();\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n    var end = function () {\n        el.removeEventListener(event, onEnd);\n        cb();\n    };\n    var onEnd = function (e) {\n        if (e.target === el) {\n            if (++ended >= propCount) {\n                end();\n            }\n        }\n    };\n    setTimeout(function () {\n        if (ended < propCount) {\n            end();\n        }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n}\nvar transformRE = /\\b(transform|all)(,|$)/;\nfunction getTransitionInfo(el, expectedType) {\n    var styles = window.getComputedStyle(el);\n    // JSDOM may return undefined for transition properties\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n    if (expectedType === TRANSITION) {\n        if (transitionTimeout > 0) {\n            type = TRANSITION;\n            timeout = transitionTimeout;\n            propCount = transitionDurations.length;\n        }\n    }\n    else if (expectedType === ANIMATION) {\n        if (animationTimeout > 0) {\n            type = ANIMATION;\n            timeout = animationTimeout;\n            propCount = animationDurations.length;\n        }\n    }\n    else {\n        timeout = Math.max(transitionTimeout, animationTimeout);\n        type =\n            timeout > 0\n                ? transitionTimeout > animationTimeout\n                    ? TRANSITION\n                    : ANIMATION\n                : null;\n        propCount = type\n            ? type === TRANSITION\n                ? transitionDurations.length\n                : animationDurations.length\n            : 0;\n    }\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n    return {\n        type: type,\n        timeout: timeout,\n        propCount: propCount,\n        hasTransform: hasTransform\n    };\n}\nfunction getTimeout(delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n        delays = delays.concat(delays);\n    }\n    return Math.max.apply(null, durations.map(function (d, i) {\n        return toMs(d) + toMs(delays[i]);\n    }));\n}\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\nfunction toMs(s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n}\n\nfunction enter(vnode, toggleDisplay) {\n    var el = vnode.elm;\n    // call leave callback now\n    if (isDef(el._leaveCb)) {\n        el._leaveCb.cancelled = true;\n        el._leaveCb();\n    }\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data)) {\n        return;\n    }\n    /* istanbul ignore if */\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n        return;\n    }\n    var css = data.css, type = data.type, enterClass = data.enterClass, enterToClass = data.enterToClass, enterActiveClass = data.enterActiveClass, appearClass = data.appearClass, appearToClass = data.appearToClass, appearActiveClass = data.appearActiveClass, beforeEnter = data.beforeEnter, enter = data.enter, afterEnter = data.afterEnter, enterCancelled = data.enterCancelled, beforeAppear = data.beforeAppear, appear = data.appear, afterAppear = data.afterAppear, appearCancelled = data.appearCancelled, duration = data.duration;\n    // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n    while (transitionNode && transitionNode.parent) {\n        context = transitionNode.context;\n        transitionNode = transitionNode.parent;\n    }\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n    if (isAppear && !appear && appear !== '') {\n        return;\n    }\n    var startClass = isAppear && appearClass ? appearClass : enterClass;\n    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n    var enterHook = isAppear ? (isFunction(appear) ? appear : enter) : enter;\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n    var enterCancelledHook = isAppear\n        ? appearCancelled || enterCancelled\n        : enterCancelled;\n    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n    if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n        checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n    var cb = (el._enterCb = once(function () {\n        if (expectsCSS) {\n            removeTransitionClass(el, toClass);\n            removeTransitionClass(el, activeClass);\n        }\n        // @ts-expect-error\n        if (cb.cancelled) {\n            if (expectsCSS) {\n                removeTransitionClass(el, startClass);\n            }\n            enterCancelledHook && enterCancelledHook(el);\n        }\n        else {\n            afterEnterHook && afterEnterHook(el);\n        }\n        el._enterCb = null;\n    }));\n    if (!vnode.data.show) {\n        // remove pending leave element on enter by injecting an insert hook\n        mergeVNodeHook(vnode, 'insert', function () {\n            var parent = el.parentNode;\n            var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n            if (pendingNode &&\n                pendingNode.tag === vnode.tag &&\n                pendingNode.elm._leaveCb) {\n                pendingNode.elm._leaveCb();\n            }\n            enterHook && enterHook(el, cb);\n        });\n    }\n    // start enter transition\n    beforeEnterHook && beforeEnterHook(el);\n    if (expectsCSS) {\n        addTransitionClass(el, startClass);\n        addTransitionClass(el, activeClass);\n        nextFrame(function () {\n            removeTransitionClass(el, startClass);\n            // @ts-expect-error\n            if (!cb.cancelled) {\n                addTransitionClass(el, toClass);\n                if (!userWantsControl) {\n                    if (isValidDuration(explicitEnterDuration)) {\n                        setTimeout(cb, explicitEnterDuration);\n                    }\n                    else {\n                        whenTransitionEnds(el, type, cb);\n                    }\n                }\n            }\n        });\n    }\n    if (vnode.data.show) {\n        toggleDisplay && toggleDisplay();\n        enterHook && enterHook(el, cb);\n    }\n    if (!expectsCSS && !userWantsControl) {\n        cb();\n    }\n}\nfunction leave(vnode, rm) {\n    var el = vnode.elm;\n    // call enter callback now\n    if (isDef(el._enterCb)) {\n        el._enterCb.cancelled = true;\n        el._enterCb();\n    }\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data) || el.nodeType !== 1) {\n        return rm();\n    }\n    /* istanbul ignore if */\n    if (isDef(el._leaveCb)) {\n        return;\n    }\n    var css = data.css, type = data.type, leaveClass = data.leaveClass, leaveToClass = data.leaveToClass, leaveActiveClass = data.leaveActiveClass, beforeLeave = data.beforeLeave, leave = data.leave, afterLeave = data.afterLeave, leaveCancelled = data.leaveCancelled, delayLeave = data.delayLeave, duration = data.duration;\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n    if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n        checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n    var cb = (el._leaveCb = once(function () {\n        if (el.parentNode && el.parentNode._pending) {\n            el.parentNode._pending[vnode.key] = null;\n        }\n        if (expectsCSS) {\n            removeTransitionClass(el, leaveToClass);\n            removeTransitionClass(el, leaveActiveClass);\n        }\n        // @ts-expect-error\n        if (cb.cancelled) {\n            if (expectsCSS) {\n                removeTransitionClass(el, leaveClass);\n            }\n            leaveCancelled && leaveCancelled(el);\n        }\n        else {\n            rm();\n            afterLeave && afterLeave(el);\n        }\n        el._leaveCb = null;\n    }));\n    if (delayLeave) {\n        delayLeave(performLeave);\n    }\n    else {\n        performLeave();\n    }\n    function performLeave() {\n        // the delayed leave may have already been cancelled\n        // @ts-expect-error\n        if (cb.cancelled) {\n            return;\n        }\n        // record leaving element\n        if (!vnode.data.show && el.parentNode) {\n            (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =\n                vnode;\n        }\n        beforeLeave && beforeLeave(el);\n        if (expectsCSS) {\n            addTransitionClass(el, leaveClass);\n            addTransitionClass(el, leaveActiveClass);\n            nextFrame(function () {\n                removeTransitionClass(el, leaveClass);\n                // @ts-expect-error\n                if (!cb.cancelled) {\n                    addTransitionClass(el, leaveToClass);\n                    if (!userWantsControl) {\n                        if (isValidDuration(explicitLeaveDuration)) {\n                            setTimeout(cb, explicitLeaveDuration);\n                        }\n                        else {\n                            whenTransitionEnds(el, type, cb);\n                        }\n                    }\n                }\n            });\n        }\n        leave && leave(el, cb);\n        if (!expectsCSS && !userWantsControl) {\n            cb();\n        }\n    }\n}\n// only used in dev mode\nfunction checkDuration(val, name, vnode) {\n    if (typeof val !== 'number') {\n        warn(\"<transition> explicit \".concat(name, \" duration is not a valid number - \") +\n            \"got \".concat(JSON.stringify(val), \".\"), vnode.context);\n    }\n    else if (isNaN(val)) {\n        warn(\"<transition> explicit \".concat(name, \" duration is NaN - \") +\n            'the duration expression might be incorrect.', vnode.context);\n    }\n}\nfunction isValidDuration(val) {\n    return typeof val === 'number' && !isNaN(val);\n}\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength(fn) {\n    if (isUndef(fn)) {\n        return false;\n    }\n    // @ts-expect-error\n    var invokerFns = fn.fns;\n    if (isDef(invokerFns)) {\n        // invoker\n        return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n    }\n    else {\n        // @ts-expect-error\n        return (fn._length || fn.length) > 1;\n    }\n}\nfunction _enter(_, vnode) {\n    if (vnode.data.show !== true) {\n        enter(vnode);\n    }\n}\nvar transition = inBrowser\n    ? {\n        create: _enter,\n        activate: _enter,\n        remove: function (vnode, rm) {\n            /* istanbul ignore else */\n            if (vnode.data.show !== true) {\n                // @ts-expect-error\n                leave(vnode, rm);\n            }\n            else {\n                rm();\n            }\n        }\n    }\n    : {};\n\nvar platformModules = [attrs, klass, events, domProps, style, transition];\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n/* istanbul ignore if */\nif (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n        var el = document.activeElement;\n        // @ts-expect-error\n        if (el && el.vmodel) {\n            trigger(el, 'input');\n        }\n    });\n}\nvar directive = {\n    inserted: function (el, binding, vnode, oldVnode) {\n        if (vnode.tag === 'select') {\n            // #6903\n            if (oldVnode.elm && !oldVnode.elm._vOptions) {\n                mergeVNodeHook(vnode, 'postpatch', function () {\n                    directive.componentUpdated(el, binding, vnode);\n                });\n            }\n            else {\n                setSelected(el, binding, vnode.context);\n            }\n            el._vOptions = [].map.call(el.options, getValue);\n        }\n        else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n            el._vModifiers = binding.modifiers;\n            if (!binding.modifiers.lazy) {\n                el.addEventListener('compositionstart', onCompositionStart);\n                el.addEventListener('compositionend', onCompositionEnd);\n                // Safari < 10.2 & UIWebView doesn't fire compositionend when\n                // switching focus before confirming composition choice\n                // this also fixes the issue where some browsers e.g. iOS Chrome\n                // fires \"change\" instead of \"input\" on autocomplete.\n                el.addEventListener('change', onCompositionEnd);\n                /* istanbul ignore if */\n                if (isIE9) {\n                    el.vmodel = true;\n                }\n            }\n        }\n    },\n    componentUpdated: function (el, binding, vnode) {\n        if (vnode.tag === 'select') {\n            setSelected(el, binding, vnode.context);\n            // in case the options rendered by v-for have changed,\n            // it's possible that the value is out-of-sync with the rendered options.\n            // detect such cases and filter out values that no longer has a matching\n            // option in the DOM.\n            var prevOptions_1 = el._vOptions;\n            var curOptions_1 = (el._vOptions = [].map.call(el.options, getValue));\n            if (curOptions_1.some(function (o, i) { return !looseEqual(o, prevOptions_1[i]); })) {\n                // trigger change event if\n                // no matching option found for at least one value\n                var needReset = el.multiple\n                    ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions_1); })\n                    : binding.value !== binding.oldValue &&\n                        hasNoMatchingOption(binding.value, curOptions_1);\n                if (needReset) {\n                    trigger(el, 'change');\n                }\n            }\n        }\n    }\n};\nfunction setSelected(el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n    if (isIE || isEdge) {\n        setTimeout(function () {\n            actuallySetSelected(el, binding, vm);\n        }, 0);\n    }\n}\nfunction actuallySetSelected(el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n    if (isMultiple && !Array.isArray(value)) {\n        process.env.NODE_ENV !== 'production' &&\n            warn(\"<select multiple v-model=\\\"\".concat(binding.expression, \"\\\"> \") +\n                \"expects an Array value for its binding, but got \".concat(Object.prototype.toString\n                    .call(value)\n                    .slice(8, -1)), vm);\n        return;\n    }\n    var selected, option;\n    for (var i = 0, l = el.options.length; i < l; i++) {\n        option = el.options[i];\n        if (isMultiple) {\n            selected = looseIndexOf(value, getValue(option)) > -1;\n            if (option.selected !== selected) {\n                option.selected = selected;\n            }\n        }\n        else {\n            if (looseEqual(getValue(option), value)) {\n                if (el.selectedIndex !== i) {\n                    el.selectedIndex = i;\n                }\n                return;\n            }\n        }\n    }\n    if (!isMultiple) {\n        el.selectedIndex = -1;\n    }\n}\nfunction hasNoMatchingOption(value, options) {\n    return options.every(function (o) { return !looseEqual(o, value); });\n}\nfunction getValue(option) {\n    return '_value' in option ? option._value : option.value;\n}\nfunction onCompositionStart(e) {\n    e.target.composing = true;\n}\nfunction onCompositionEnd(e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing)\n        return;\n    e.target.composing = false;\n    trigger(e.target, 'input');\n}\nfunction trigger(el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n}\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode(vnode) {\n    // @ts-expect-error\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n        ? locateNode(vnode.componentInstance._vnode)\n        : vnode;\n}\nvar show = {\n    bind: function (el, _a, vnode) {\n        var value = _a.value;\n        vnode = locateNode(vnode);\n        var transition = vnode.data && vnode.data.transition;\n        var originalDisplay = (el.__vOriginalDisplay =\n            el.style.display === 'none' ? '' : el.style.display);\n        if (value && transition) {\n            vnode.data.show = true;\n            enter(vnode, function () {\n                el.style.display = originalDisplay;\n            });\n        }\n        else {\n            el.style.display = value ? originalDisplay : 'none';\n        }\n    },\n    update: function (el, _a, vnode) {\n        var value = _a.value, oldValue = _a.oldValue;\n        /* istanbul ignore if */\n        if (!value === !oldValue)\n            return;\n        vnode = locateNode(vnode);\n        var transition = vnode.data && vnode.data.transition;\n        if (transition) {\n            vnode.data.show = true;\n            if (value) {\n                enter(vnode, function () {\n                    el.style.display = el.__vOriginalDisplay;\n                });\n            }\n            else {\n                leave(vnode, function () {\n                    el.style.display = 'none';\n                });\n            }\n        }\n        else {\n            el.style.display = value ? el.__vOriginalDisplay : 'none';\n        }\n    },\n    unbind: function (el, binding, vnode, oldVnode, isDestroy) {\n        if (!isDestroy) {\n            el.style.display = el.__vOriginalDisplay;\n        }\n    }\n};\n\nvar platformDirectives = {\n    model: directive,\n    show: show\n};\n\n// Provides transition support for a single element/component.\nvar transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n};\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild(vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n    if (compOptions && compOptions.Ctor.options.abstract) {\n        return getRealChild(getFirstComponentChild(compOptions.children));\n    }\n    else {\n        return vnode;\n    }\n}\nfunction extractTransitionData(comp) {\n    var data = {};\n    var options = comp.$options;\n    // props\n    for (var key in options.propsData) {\n        data[key] = comp[key];\n    }\n    // events.\n    // extract listeners and pass them directly to the transition methods\n    var listeners = options._parentListeners;\n    for (var key in listeners) {\n        data[camelize(key)] = listeners[key];\n    }\n    return data;\n}\nfunction placeholder(h, rawChild) {\n    // @ts-expect-error\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n        return h('keep-alive', {\n            props: rawChild.componentOptions.propsData\n        });\n    }\n}\nfunction hasParentTransition(vnode) {\n    while ((vnode = vnode.parent)) {\n        if (vnode.data.transition) {\n            return true;\n        }\n    }\n}\nfunction isSameChild(child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag;\n}\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\nvar isVShowDirective = function (d) { return d.name === 'show'; };\nvar Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n    render: function (h) {\n        var _this = this;\n        var children = this.$slots.default;\n        if (!children) {\n            return;\n        }\n        // filter out text nodes (possible whitespaces)\n        children = children.filter(isNotTextNode);\n        /* istanbul ignore if */\n        if (!children.length) {\n            return;\n        }\n        // warn multiple elements\n        if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n            warn('<transition> can only be used on a single element. Use ' +\n                '<transition-group> for lists.', this.$parent);\n        }\n        var mode = this.mode;\n        // warn invalid mode\n        if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {\n            warn('invalid <transition> mode: ' + mode, this.$parent);\n        }\n        var rawChild = children[0];\n        // if this is a component root node and the component's\n        // parent container node also has transition, skip.\n        if (hasParentTransition(this.$vnode)) {\n            return rawChild;\n        }\n        // apply transition data to child\n        // use getRealChild() to ignore abstract components e.g. keep-alive\n        var child = getRealChild(rawChild);\n        /* istanbul ignore if */\n        if (!child) {\n            return rawChild;\n        }\n        if (this._leaving) {\n            return placeholder(h, rawChild);\n        }\n        // ensure a key that is unique to the vnode type and to this transition\n        // component instance. This key will be used to remove pending leaving nodes\n        // during entering.\n        var id = \"__transition-\".concat(this._uid, \"-\");\n        child.key =\n            child.key == null\n                ? child.isComment\n                    ? id + 'comment'\n                    : id + child.tag\n                : isPrimitive(child.key)\n                    ? String(child.key).indexOf(id) === 0\n                        ? child.key\n                        : id + child.key\n                    : child.key;\n        var data = ((child.data || (child.data = {})).transition =\n            extractTransitionData(this));\n        var oldRawChild = this._vnode;\n        var oldChild = getRealChild(oldRawChild);\n        // mark v-show\n        // so that the transition module can hand over the control to the directive\n        if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n            child.data.show = true;\n        }\n        if (oldChild &&\n            oldChild.data &&\n            !isSameChild(child, oldChild) &&\n            !isAsyncPlaceholder(oldChild) &&\n            // #6687 component root is a comment node\n            !(oldChild.componentInstance &&\n                oldChild.componentInstance._vnode.isComment)) {\n            // replace old child transition data with fresh one\n            // important for dynamic transitions!\n            var oldData = (oldChild.data.transition = extend({}, data));\n            // handle transition mode\n            if (mode === 'out-in') {\n                // return placeholder node and queue update when leave finishes\n                this._leaving = true;\n                mergeVNodeHook(oldData, 'afterLeave', function () {\n                    _this._leaving = false;\n                    _this.$forceUpdate();\n                });\n                return placeholder(h, rawChild);\n            }\n            else if (mode === 'in-out') {\n                if (isAsyncPlaceholder(child)) {\n                    return oldRawChild;\n                }\n                var delayedLeave_1;\n                var performLeave = function () {\n                    delayedLeave_1();\n                };\n                mergeVNodeHook(data, 'afterEnter', performLeave);\n                mergeVNodeHook(data, 'enterCancelled', performLeave);\n                mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n                    delayedLeave_1 = leave;\n                });\n            }\n        }\n        return rawChild;\n    }\n};\n\n// Provides transition support for list items.\nvar props = extend({\n    tag: String,\n    moveClass: String\n}, transitionProps);\ndelete props.mode;\nvar TransitionGroup = {\n    props: props,\n    beforeMount: function () {\n        var _this = this;\n        var update = this._update;\n        this._update = function (vnode, hydrating) {\n            var restoreActiveInstance = setActiveInstance(_this);\n            // force removing pass\n            _this.__patch__(_this._vnode, _this.kept, false, // hydrating\n            true // removeOnly (!important, avoids unnecessary moves)\n            );\n            _this._vnode = _this.kept;\n            restoreActiveInstance();\n            update.call(_this, vnode, hydrating);\n        };\n    },\n    render: function (h) {\n        var tag = this.tag || this.$vnode.data.tag || 'span';\n        var map = Object.create(null);\n        var prevChildren = (this.prevChildren = this.children);\n        var rawChildren = this.$slots.default || [];\n        var children = (this.children = []);\n        var transitionData = extractTransitionData(this);\n        for (var i = 0; i < rawChildren.length; i++) {\n            var c = rawChildren[i];\n            if (c.tag) {\n                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n                    children.push(c);\n                    map[c.key] = c;\n                    (c.data || (c.data = {})).transition = transitionData;\n                }\n                else if (process.env.NODE_ENV !== 'production') {\n                    var opts = c.componentOptions;\n                    var name_1 = opts\n                        ? getComponentName(opts.Ctor.options) || opts.tag || ''\n                        : c.tag;\n                    warn(\"<transition-group> children must be keyed: <\".concat(name_1, \">\"));\n                }\n            }\n        }\n        if (prevChildren) {\n            var kept = [];\n            var removed = [];\n            for (var i = 0; i < prevChildren.length; i++) {\n                var c = prevChildren[i];\n                c.data.transition = transitionData;\n                // @ts-expect-error .getBoundingClientRect is not typed in Node\n                c.data.pos = c.elm.getBoundingClientRect();\n                if (map[c.key]) {\n                    kept.push(c);\n                }\n                else {\n                    removed.push(c);\n                }\n            }\n            this.kept = h(tag, null, kept);\n            this.removed = removed;\n        }\n        return h(tag, null, children);\n    },\n    updated: function () {\n        var children = this.prevChildren;\n        var moveClass = this.moveClass || (this.name || 'v') + '-move';\n        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n            return;\n        }\n        // we divide the work into three loops to avoid mixing DOM reads and writes\n        // in each iteration - which helps prevent layout thrashing.\n        children.forEach(callPendingCbs);\n        children.forEach(recordPosition);\n        children.forEach(applyTranslation);\n        // force reflow to put everything in position\n        // assign to this to avoid being removed in tree-shaking\n        // $flow-disable-line\n        this._reflow = document.body.offsetHeight;\n        children.forEach(function (c) {\n            if (c.data.moved) {\n                var el_1 = c.elm;\n                var s = el_1.style;\n                addTransitionClass(el_1, moveClass);\n                s.transform = s.WebkitTransform = s.transitionDuration = '';\n                el_1.addEventListener(transitionEndEvent, (el_1._moveCb = function cb(e) {\n                    if (e && e.target !== el_1) {\n                        return;\n                    }\n                    if (!e || /transform$/.test(e.propertyName)) {\n                        el_1.removeEventListener(transitionEndEvent, cb);\n                        el_1._moveCb = null;\n                        removeTransitionClass(el_1, moveClass);\n                    }\n                }));\n            }\n        });\n    },\n    methods: {\n        hasMove: function (el, moveClass) {\n            /* istanbul ignore if */\n            if (!hasTransition) {\n                return false;\n            }\n            /* istanbul ignore if */\n            if (this._hasMove) {\n                return this._hasMove;\n            }\n            // Detect whether an element with the move class applied has\n            // CSS transitions. Since the element may be inside an entering\n            // transition at this very moment, we make a clone of it and remove\n            // all other transition classes applied to ensure only the move class\n            // is applied.\n            var clone = el.cloneNode();\n            if (el._transitionClasses) {\n                el._transitionClasses.forEach(function (cls) {\n                    removeClass(clone, cls);\n                });\n            }\n            addClass(clone, moveClass);\n            clone.style.display = 'none';\n            this.$el.appendChild(clone);\n            var info = getTransitionInfo(clone);\n            this.$el.removeChild(clone);\n            return (this._hasMove = info.hasTransform);\n        }\n    }\n};\nfunction callPendingCbs(c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n        c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n    if (c.elm._enterCb) {\n        c.elm._enterCb();\n    }\n}\nfunction recordPosition(c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n}\nfunction applyTranslation(c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n    if (dx || dy) {\n        c.data.moved = true;\n        var s = c.elm.style;\n        s.transform = s.WebkitTransform = \"translate(\".concat(dx, \"px,\").concat(dy, \"px)\");\n        s.transitionDuration = '0s';\n    }\n}\n\nvar platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n};\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement;\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents);\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop;\n// public mount method\nVue.prototype.$mount = function (el, hydrating) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating);\n};\n// devtools global hook\n/* istanbul ignore next */\nif (inBrowser) {\n    setTimeout(function () {\n        if (config.devtools) {\n            if (devtools) {\n                devtools.emit('init', Vue);\n            }\n            else if (process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {\n                // @ts-expect-error\n                console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' +\n                    'https://github.com/vuejs/vue-devtools');\n            }\n        }\n        if (process.env.NODE_ENV !== 'production' &&\n            process.env.NODE_ENV !== 'test' &&\n            config.productionTip !== false &&\n            typeof console !== 'undefined') {\n            // @ts-expect-error\n            console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" +\n                \"Make sure to turn on production mode when deploying for production.\\n\" +\n                \"See more tips at https://vuejs.org/guide/deployment.html\");\n        }\n    }, 0);\n}\n\nexport { EffectScope, computed, customRef, Vue as default, defineAsyncComponent, defineComponent, del, effectScope, getCurrentInstance, getCurrentScope, h, inject, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, mergeDefaults, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onScopeDispose, onServerPrefetch, onUnmounted, onUpdated, provide, proxyRefs, reactive, readonly, ref$1 as ref, set, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref, useAttrs, useCssModule, useCssVars, useListeners, useSlots, version, watch, watchEffect, watchPostEffect, watchSyncEffect };\n","/**\n  * vue-class-component v7.2.6\n  * (c) 2015-present Evan You\n  * @license MIT\n  */\nimport Vue from 'vue';\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\n// The rational behind the verbose Reflect-feature check below is the fact that there are polyfills\n// which add an implementation for Reflect.defineMetadata but not for Reflect.getOwnMetadataKeys.\n// Without this check consumers will encounter hard to track down runtime errors.\nfunction reflectionIsSupported() {\n  return typeof Reflect !== 'undefined' && Reflect.defineMetadata && Reflect.getOwnMetadataKeys;\n}\nfunction copyReflectionMetadata(to, from) {\n  forwardMetadata(to, from);\n  Object.getOwnPropertyNames(from.prototype).forEach(function (key) {\n    forwardMetadata(to.prototype, from.prototype, key);\n  });\n  Object.getOwnPropertyNames(from).forEach(function (key) {\n    forwardMetadata(to, from, key);\n  });\n}\n\nfunction forwardMetadata(to, from, propertyKey) {\n  var metaKeys = propertyKey ? Reflect.getOwnMetadataKeys(from, propertyKey) : Reflect.getOwnMetadataKeys(from);\n  metaKeys.forEach(function (metaKey) {\n    var metadata = propertyKey ? Reflect.getOwnMetadata(metaKey, from, propertyKey) : Reflect.getOwnMetadata(metaKey, from);\n\n    if (propertyKey) {\n      Reflect.defineMetadata(metaKey, metadata, to, propertyKey);\n    } else {\n      Reflect.defineMetadata(metaKey, metadata, to);\n    }\n  });\n}\n\nvar fakeArray = {\n  __proto__: []\n};\nvar hasProto = fakeArray instanceof Array;\nfunction createDecorator(factory) {\n  return function (target, key, index) {\n    var Ctor = typeof target === 'function' ? target : target.constructor;\n\n    if (!Ctor.__decorators__) {\n      Ctor.__decorators__ = [];\n    }\n\n    if (typeof index !== 'number') {\n      index = undefined;\n    }\n\n    Ctor.__decorators__.push(function (options) {\n      return factory(options, key, index);\n    });\n  };\n}\nfunction mixins() {\n  for (var _len = arguments.length, Ctors = new Array(_len), _key = 0; _key < _len; _key++) {\n    Ctors[_key] = arguments[_key];\n  }\n\n  return Vue.extend({\n    mixins: Ctors\n  });\n}\nfunction isPrimitive(value) {\n  var type = _typeof(value);\n\n  return value == null || type !== 'object' && type !== 'function';\n}\nfunction warn(message) {\n  if (typeof console !== 'undefined') {\n    console.warn('[vue-class-component] ' + message);\n  }\n}\n\nfunction collectDataFromConstructor(vm, Component) {\n  // override _init to prevent to init as Vue instance\n  var originalInit = Component.prototype._init;\n\n  Component.prototype._init = function () {\n    var _this = this;\n\n    // proxy to actual vm\n    var keys = Object.getOwnPropertyNames(vm); // 2.2.0 compat (props are no longer exposed as self properties)\n\n    if (vm.$options.props) {\n      for (var key in vm.$options.props) {\n        if (!vm.hasOwnProperty(key)) {\n          keys.push(key);\n        }\n      }\n    }\n\n    keys.forEach(function (key) {\n      Object.defineProperty(_this, key, {\n        get: function get() {\n          return vm[key];\n        },\n        set: function set(value) {\n          vm[key] = value;\n        },\n        configurable: true\n      });\n    });\n  }; // should be acquired class property values\n\n\n  var data = new Component(); // restore original _init to avoid memory leak (#209)\n\n  Component.prototype._init = originalInit; // create plain data object\n\n  var plainData = {};\n  Object.keys(data).forEach(function (key) {\n    if (data[key] !== undefined) {\n      plainData[key] = data[key];\n    }\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!(Component.prototype instanceof Vue) && Object.keys(plainData).length > 0) {\n      warn('Component class must inherit Vue or its descendant class ' + 'when class property is used.');\n    }\n  }\n\n  return plainData;\n}\n\nvar $internalHooks = ['data', 'beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeDestroy', 'destroyed', 'beforeUpdate', 'updated', 'activated', 'deactivated', 'render', 'errorCaptured', 'serverPrefetch' // 2.6\n];\nfunction componentFactory(Component) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options.name = options.name || Component._componentTag || Component.name; // prototype props.\n\n  var proto = Component.prototype;\n  Object.getOwnPropertyNames(proto).forEach(function (key) {\n    if (key === 'constructor') {\n      return;\n    } // hooks\n\n\n    if ($internalHooks.indexOf(key) > -1) {\n      options[key] = proto[key];\n      return;\n    }\n\n    var descriptor = Object.getOwnPropertyDescriptor(proto, key);\n\n    if (descriptor.value !== void 0) {\n      // methods\n      if (typeof descriptor.value === 'function') {\n        (options.methods || (options.methods = {}))[key] = descriptor.value;\n      } else {\n        // typescript decorated data\n        (options.mixins || (options.mixins = [])).push({\n          data: function data() {\n            return _defineProperty({}, key, descriptor.value);\n          }\n        });\n      }\n    } else if (descriptor.get || descriptor.set) {\n      // computed properties\n      (options.computed || (options.computed = {}))[key] = {\n        get: descriptor.get,\n        set: descriptor.set\n      };\n    }\n  });\n  (options.mixins || (options.mixins = [])).push({\n    data: function data() {\n      return collectDataFromConstructor(this, Component);\n    }\n  }); // decorate options\n\n  var decorators = Component.__decorators__;\n\n  if (decorators) {\n    decorators.forEach(function (fn) {\n      return fn(options);\n    });\n    delete Component.__decorators__;\n  } // find super\n\n\n  var superProto = Object.getPrototypeOf(Component.prototype);\n  var Super = superProto instanceof Vue ? superProto.constructor : Vue;\n  var Extended = Super.extend(options);\n  forwardStaticMembers(Extended, Component, Super);\n\n  if (reflectionIsSupported()) {\n    copyReflectionMetadata(Extended, Component);\n  }\n\n  return Extended;\n}\nvar reservedPropertyNames = [// Unique id\n'cid', // Super Vue constructor\n'super', // Component options that will be used by the component\n'options', 'superOptions', 'extendOptions', 'sealedOptions', // Private assets\n'component', 'directive', 'filter'];\nvar shouldIgnore = {\n  prototype: true,\n  arguments: true,\n  callee: true,\n  caller: true\n};\n\nfunction forwardStaticMembers(Extended, Original, Super) {\n  // We have to use getOwnPropertyNames since Babel registers methods as non-enumerable\n  Object.getOwnPropertyNames(Original).forEach(function (key) {\n    // Skip the properties that should not be overwritten\n    if (shouldIgnore[key]) {\n      return;\n    } // Some browsers does not allow reconfigure built-in properties\n\n\n    var extendedDescriptor = Object.getOwnPropertyDescriptor(Extended, key);\n\n    if (extendedDescriptor && !extendedDescriptor.configurable) {\n      return;\n    }\n\n    var descriptor = Object.getOwnPropertyDescriptor(Original, key); // If the user agent does not support `__proto__` or its family (IE <= 10),\n    // the sub class properties may be inherited properties from the super class in TypeScript.\n    // We need to exclude such properties to prevent to overwrite\n    // the component options object which stored on the extended constructor (See #192).\n    // If the value is a referenced value (object or function),\n    // we can check equality of them and exclude it if they have the same reference.\n    // If it is a primitive value, it will be forwarded for safety.\n\n    if (!hasProto) {\n      // Only `cid` is explicitly exluded from property forwarding\n      // because we cannot detect whether it is a inherited property or not\n      // on the no `__proto__` environment even though the property is reserved.\n      if (key === 'cid') {\n        return;\n      }\n\n      var superDescriptor = Object.getOwnPropertyDescriptor(Super, key);\n\n      if (!isPrimitive(descriptor.value) && superDescriptor && superDescriptor.value === descriptor.value) {\n        return;\n      }\n    } // Warn if the users manually declare reserved properties\n\n\n    if (process.env.NODE_ENV !== 'production' && reservedPropertyNames.indexOf(key) >= 0) {\n      warn(\"Static property name '\".concat(key, \"' declared on class '\").concat(Original.name, \"' \") + 'conflicts with reserved property name of Vue internal. ' + 'It may cause unexpected behavior of the component. Consider renaming the property.');\n    }\n\n    Object.defineProperty(Extended, key, descriptor);\n  });\n}\n\nfunction Component(options) {\n  if (typeof options === 'function') {\n    return componentFactory(options);\n  }\n\n  return function (Component) {\n    return componentFactory(Component, options);\n  };\n}\n\nComponent.registerHooks = function registerHooks(keys) {\n  $internalHooks.push.apply($internalHooks, _toConsumableArray(keys));\n};\n\nexport default Component;\nexport { createDecorator, mixins };\n","/** vue-property-decorator verson 8.5.1 MIT LICENSE copyright 2020 kaorun343 */\n/// <reference types='reflect-metadata'/>\n'use strict';\nimport Vue from 'vue';\nimport Component, { createDecorator, mixins } from 'vue-class-component';\nexport { Component, Vue, mixins as Mixins };\n/** Used for keying reactive provide/inject properties */\nvar reactiveInjectKey = '__reactiveInject__';\n/**\n * decorator of an inject\n * @param from key\n * @return PropertyDecorator\n */\nexport function Inject(options) {\n    return createDecorator(function (componentOptions, key) {\n        if (typeof componentOptions.inject === 'undefined') {\n            componentOptions.inject = {};\n        }\n        if (!Array.isArray(componentOptions.inject)) {\n            componentOptions.inject[key] = options || key;\n        }\n    });\n}\n/**\n * decorator of a reactive inject\n * @param from key\n * @return PropertyDecorator\n */\nexport function InjectReactive(options) {\n    return createDecorator(function (componentOptions, key) {\n        if (typeof componentOptions.inject === 'undefined') {\n            componentOptions.inject = {};\n        }\n        if (!Array.isArray(componentOptions.inject)) {\n            var fromKey_1 = !!options ? options.from || options : key;\n            var defaultVal_1 = (!!options && options.default) || undefined;\n            if (!componentOptions.computed)\n                componentOptions.computed = {};\n            componentOptions.computed[key] = function () {\n                var obj = this[reactiveInjectKey];\n                return obj ? obj[fromKey_1] : defaultVal_1;\n            };\n            componentOptions.inject[reactiveInjectKey] = reactiveInjectKey;\n        }\n    });\n}\nfunction produceProvide(original) {\n    var provide = function () {\n        var _this = this;\n        var rv = typeof original === 'function' ? original.call(this) : original;\n        rv = Object.create(rv || null);\n        // set reactive services (propagates previous services if necessary)\n        rv[reactiveInjectKey] = this[reactiveInjectKey] || {};\n        for (var i in provide.managed) {\n            rv[provide.managed[i]] = this[i];\n        }\n        var _loop_1 = function (i) {\n            rv[provide.managedReactive[i]] = this_1[i]; // Duplicates the behavior of `@Provide`\n            Object.defineProperty(rv[reactiveInjectKey], provide.managedReactive[i], {\n                enumerable: true,\n                get: function () { return _this[i]; },\n            });\n        };\n        var this_1 = this;\n        for (var i in provide.managedReactive) {\n            _loop_1(i);\n        }\n        return rv;\n    };\n    provide.managed = {};\n    provide.managedReactive = {};\n    return provide;\n}\nfunction needToProduceProvide(original) {\n    return (typeof original !== 'function' ||\n        (!original.managed && !original.managedReactive));\n}\n/**\n * decorator of a provide\n * @param key key\n * @return PropertyDecorator | void\n */\nexport function Provide(key) {\n    return createDecorator(function (componentOptions, k) {\n        var provide = componentOptions.provide;\n        if (needToProduceProvide(provide)) {\n            provide = componentOptions.provide = produceProvide(provide);\n        }\n        provide.managed[k] = key || k;\n    });\n}\n/**\n * decorator of a reactive provide\n * @param key key\n * @return PropertyDecorator | void\n */\nexport function ProvideReactive(key) {\n    return createDecorator(function (componentOptions, k) {\n        var provide = componentOptions.provide;\n        // inject parent reactive services (if any)\n        if (!Array.isArray(componentOptions.inject)) {\n            componentOptions.inject = componentOptions.inject || {};\n            componentOptions.inject[reactiveInjectKey] = {\n                from: reactiveInjectKey,\n                default: {},\n            };\n        }\n        if (needToProduceProvide(provide)) {\n            provide = componentOptions.provide = produceProvide(provide);\n        }\n        provide.managedReactive[k] = key || k;\n    });\n}\n/** @see {@link https://github.com/vuejs/vue-class-component/blob/master/src/reflect.ts} */\nvar reflectMetadataIsSupported = typeof Reflect !== 'undefined' && typeof Reflect.getMetadata !== 'undefined';\nfunction applyMetadata(options, target, key) {\n    if (reflectMetadataIsSupported) {\n        if (!Array.isArray(options) &&\n            typeof options !== 'function' &&\n            typeof options.type === 'undefined') {\n            var type = Reflect.getMetadata('design:type', target, key);\n            if (type !== Object) {\n                options.type = type;\n            }\n        }\n    }\n}\n/**\n * decorator of model\n * @param  event event name\n * @param options options\n * @return PropertyDecorator\n */\nexport function Model(event, options) {\n    if (options === void 0) { options = {}; }\n    return function (target, key) {\n        applyMetadata(options, target, key);\n        createDecorator(function (componentOptions, k) {\n            ;\n            (componentOptions.props || (componentOptions.props = {}))[k] = options;\n            componentOptions.model = { prop: k, event: event || k };\n        })(target, key);\n    };\n}\n/**\n * decorator of a prop\n * @param  options the options for the prop\n * @return PropertyDecorator | void\n */\nexport function Prop(options) {\n    if (options === void 0) { options = {}; }\n    return function (target, key) {\n        applyMetadata(options, target, key);\n        createDecorator(function (componentOptions, k) {\n            ;\n            (componentOptions.props || (componentOptions.props = {}))[k] = options;\n        })(target, key);\n    };\n}\n/**\n * decorator of a synced prop\n * @param propName the name to interface with from outside, must be different from decorated property\n * @param options the options for the synced prop\n * @return PropertyDecorator | void\n */\nexport function PropSync(propName, options) {\n    if (options === void 0) { options = {}; }\n    // @ts-ignore\n    return function (target, key) {\n        applyMetadata(options, target, key);\n        createDecorator(function (componentOptions, k) {\n            ;\n            (componentOptions.props || (componentOptions.props = {}))[propName] = options;\n            (componentOptions.computed || (componentOptions.computed = {}))[k] = {\n                get: function () {\n                    return this[propName];\n                },\n                set: function (value) {\n                    // @ts-ignore\n                    this.$emit(\"update:\" + propName, value);\n                },\n            };\n        })(target, key);\n    };\n}\n/**\n * decorator of a watch function\n * @param  path the path or the expression to observe\n * @param  WatchOption\n * @return MethodDecorator\n */\nexport function Watch(path, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.deep, deep = _a === void 0 ? false : _a, _b = options.immediate, immediate = _b === void 0 ? false : _b;\n    return createDecorator(function (componentOptions, handler) {\n        if (typeof componentOptions.watch !== 'object') {\n            componentOptions.watch = Object.create(null);\n        }\n        var watch = componentOptions.watch;\n        if (typeof watch[path] === 'object' && !Array.isArray(watch[path])) {\n            watch[path] = [watch[path]];\n        }\n        else if (typeof watch[path] === 'undefined') {\n            watch[path] = [];\n        }\n        watch[path].push({ handler: handler, deep: deep, immediate: immediate });\n    });\n}\n// Code copied from Vue/src/shared/util.js\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = function (str) { return str.replace(hyphenateRE, '-$1').toLowerCase(); };\n/**\n * decorator of an event-emitter function\n * @param  event The name of the event\n * @return MethodDecorator\n */\nexport function Emit(event) {\n    return function (_target, propertyKey, descriptor) {\n        var key = hyphenate(propertyKey);\n        var original = descriptor.value;\n        descriptor.value = function emitter() {\n            var _this = this;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var emit = function (returnValue) {\n                var emitName = event || key;\n                if (returnValue === undefined) {\n                    if (args.length === 0) {\n                        _this.$emit(emitName);\n                    }\n                    else if (args.length === 1) {\n                        _this.$emit(emitName, args[0]);\n                    }\n                    else {\n                        _this.$emit.apply(_this, [emitName].concat(args));\n                    }\n                }\n                else {\n                    if (args.length === 0) {\n                        _this.$emit(emitName, returnValue);\n                    }\n                    else if (args.length === 1) {\n                        _this.$emit(emitName, returnValue, args[0]);\n                    }\n                    else {\n                        _this.$emit.apply(_this, [emitName, returnValue].concat(args));\n                    }\n                }\n            };\n            var returnValue = original.apply(this, args);\n            if (isPromise(returnValue)) {\n                returnValue.then(emit);\n            }\n            else {\n                emit(returnValue);\n            }\n            return returnValue;\n        };\n    };\n}\n/**\n * decorator of a ref prop\n * @param refKey the ref key defined in template\n */\nexport function Ref(refKey) {\n    return createDecorator(function (options, key) {\n        options.computed = options.computed || {};\n        options.computed[key] = {\n            cache: false,\n            get: function () {\n                return this.$refs[refKey || key];\n            },\n        };\n    });\n}\nfunction isPromise(obj) {\n    return obj instanceof Promise || (obj && typeof obj.then === 'function');\n}\n","import { PropsWithType } from './types';\n\n/**\n * Returns if the given array is `null`, `undefined`, or has no elements.\n *\n * @param array - The array to check if it is empty.\n * @returns `true` if the array is `null`, `undefined`, or has no elements. `false` otherwise.\n * @public\n */\nexport function isArrayEmpty(array: unknown[] | undefined | null): array is undefined | null | [] {\n  return array == null || array.length === 0;\n}\n\n/**\n * Reduce an array of strings to an object which properties names are the value of each string,\n * and the value under that property are also the string.\n *\n * @param array - Array of strings that will be used to create the object.\n *\n * @returns New object which properties object[key] contains object of each iteration in the\n * array.\n *\n * @example Converting an array to an object:\n *         arrayToObject(['a', 'b', 'c']) === \\{a: 'a', b: 'b', c: 'c'\\}\n *\n * @public\n */\nexport function arrayToObject(array: string[]): Record<string, string>;\n/**\n * Reduce an array of objects to an object which properties names are the value of each object[key],\n * and the value under that property are each object. 'key' is the the parameter passed to this\n * function.\n *\n * @param array - Array of objects that contains objects which have object[key] string as a property\n * value.\n * @param key - Key used to access to each object[key] value, used for each property name in the new\n * object.\n *\n * @returns New object which properties object[key] contains object of each iteration in the array.\n *\n * @public\n */\nexport function arrayToObject<ArrayType>(\n  array: ArrayType[],\n  key: PropsWithType<ArrayType, string | number>\n): Record<string, ArrayType>;\n/**\n * Reduce an array to an object. The type of the object returned depends on the type of the params.\n * If the 'key' is passed then the function returns an object which properties names are the value\n * of each object[key] and the value under that property are each object.\n * If the 'key' is not passed then the function returns an object which properties names are each\n * array item, and the value is also the array item.\n *\n * @param array - Array from which to create an object.\n * @param key - Key used to access to each object[key] value, used for each property name in the\n * new object.\n *\n * @returns New object which properties object[key] contains each item in the array and the key is\n * either the item of the array or a property of each item designated by 'key' param.\n *\n * @public\n */\nexport function arrayToObject<ArrayType>(\n  array: ArrayType[],\n  key?: PropsWithType<ArrayType, string | number>\n): Record<string, ArrayType> {\n  return array.reduce<Record<string, ArrayType>>((accumulator, current) => {\n    if (key) {\n      accumulator[current[key] as any] = current;\n    } else if (typeof current === 'string') {\n      accumulator[current] = current;\n    }\n    return accumulator;\n  }, {});\n}\n\n/**\n * Groups the array items based on the provided `groupBy` function.\n *\n * @param array - The array to iterate, grouping its items in different arrays based on the\n * `groupBy` function.\n * @param groupBy - A function to determine the group name of a single item.\n * @returns The items grouped in a dictionary.\n *\n * @public\n */\nexport function groupItemsBy<ArrayType, ReturnType extends string | number>(\n  array: ArrayType[],\n  groupBy: (item: ArrayType, index: number) => ReturnType\n): Record<ReturnType, ArrayType[]> {\n  return array.reduce<Record<ReturnType, ArrayType[]>>((accumulator, current, index) => {\n    const keyValue = groupBy(current, index);\n    if (!accumulator[keyValue]) {\n      accumulator[keyValue] = [];\n    }\n    accumulator[keyValue].push(current);\n    return accumulator;\n  }, {} as Record<ReturnType, ArrayType[]>);\n}\n\n/**\n * Filters an array with all elements that pass the test implemented by the given filter\n * function. If an item has another list of items in the `childrenKey` property it recursively\n * filters that new list, adding it to the returned one.\n *\n * @param array - Array to be filtered.\n * @param condition - Predicate function to test each element of the array. It should return `true`\n * to keep the element; or `false` otherwise.\n * @param childrenKey - Property name within the array used to perform a recursive call.\n *\n * @example\n * Input - Output example\n *\n * ```\n * const hierarchicalFilters: Filter[] = [\n *   {\n *     id: 'filter1'\n *     selected: true,\n *     children: [\n *       {\n *         id: 'filter1-1'\n *         selected: true,\n *         children: []\n *       },\n *       {\n *         id: 'filter1-2'\n *         selected: false,\n *         children: []\n *       }\n *     ]\n *   },\n *   {\n *     id: 'filter2',\n *     selected: false,\n *     children: [\n *      {\n *        id: 'filter2-1',\n *        selected: true // not should happen\n *      }\n *     ]\n *   }\n * ]\n *\n *  const filteredArray: Filter[] = deepFilterArray(\n *    hierarchicalFilters,\n *    filter => filter.selected,\n *    'children'\n *  )\n *\n *  /*\n *    filteredArray = [\n *      {\n *        id: 'filter1'\n *        selected: true,\n *        children: [\n *          {\n *            id: 'filter1-1'\n *            selected: true,\n *            children: []\n *          },\n *          {\n *            id: 'filter1-2'\n *            selected: false,\n *            children: []\n *          }\n *        ]\n *      },\n *      {\n *        id: 'filter1-1'\n *        selected: true,\n *        children: []\n *      }\n *    ]\n * ```\n *\n * @returns A new array with the elements that pass the condition, or an empty array if no one\n * pass the test.\n *\n * @public\n */\nexport function deepFilter<Item extends { [key in Key]?: Item[] }, Key extends keyof Item>(\n  array: Item[],\n  condition: (item: Item) => boolean,\n  childrenKey: Key\n): Item[] {\n  return array.reduce<Item[]>(function filter(filteredArray, item) {\n    if (condition(item)) {\n      filteredArray.push(item);\n      item[childrenKey]?.reduce(filter, filteredArray);\n    }\n    return filteredArray;\n  }, []);\n}\n\n/**\n * Flat an `Item[]` deeply using the given `childrenKey` to access to his children.\n *\n * @param array - The list of items to flat. Each item may have another list of items of\n * the same type to flat.\n * @param childrenKey - Property name where each of the items of the given array may have another\n * list of items to be flattened.\n *\n * @returns A flat list with all the found items.\n *\n * @public\n */\nexport function deepFlat<Item extends { [key in Key]?: Item[] }, Key extends keyof Item>(\n  array: Item[],\n  childrenKey: Key\n): Item[] {\n  return array.reduce<Item[]>(function flat(flattenedArray, item) {\n    flattenedArray.push(item);\n    item[childrenKey]?.reduce(flat, flattenedArray);\n    return flattenedArray;\n  }, []);\n}\n\n/**\n * Creates an Emitter filter function to compare two arrays and filter those that are equal.\n *\n * @param comparator - String with the name of the field of the arrays items to compare, or function\n * to compare items directly.\n * @returns The comparator function that receives two arrays to compare them.\n *\n * @internal\n */\nexport function createEmitterArrayFilter<T>(\n  comparator: keyof T | ((item1: T, item2: T) => boolean)\n): (newCollection: Array<T>, oldCollection: Array<T>) => boolean {\n  const comparatorFn =\n    typeof comparator === 'function'\n      ? comparator\n      : (newItem: T, oldItem: T) => newItem[comparator] === oldItem[comparator];\n  return function (newCollection: Array<T>, oldCollection: Array<T>): boolean {\n    return (\n      newCollection.length !== oldCollection.length ||\n      newCollection.some(newItem => !oldCollection.find(oldItem => comparatorFn(newItem, oldItem)))\n    );\n  };\n}\n","import Vue, { ComponentOptions } from 'vue';\nimport { createDecorator } from 'vue-class-component';\nimport { arrayToObject } from '../../utils/array';\nimport { DecoratorFor } from '../../utils/types';\n\n/**\n * The type of the Vue Component provide configuration, narrowed to the object type.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype ProvideObjectConfig = Exclude<ComponentOptions<Vue>['provide'], (() => object) | undefined>;\n\n/**\n * The type of the Vue Component inject configuration, narrowed to the object type.\n *\n * @internal\n */\ntype InjectObjectConfig = Exclude<ComponentOptions<Vue>['inject'], string[] | undefined>;\n\n/**\n * Type of the key passed to {@link XProvide} and {@link XInject} to be type-safe. With this type\n * you can declare the type of the injected value directly in the injection key.\n *\n * @example\n * `const myKey: XInjectKey<Filter> = 'myFilter';`\n * `@XInject(myKey)`\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface XInjectKey<Type> extends String {}\n\n/**\n * The union type for the different functions in this module.\n *\n * @internal\n */\ntype AnyInjectKey<Type> = XInjectKey<Type> | string;\n\n/**\n * Generates a provide function that returns an object with the injectable value returned in a\n * getter to keep its reactivity, using the default\n * {@link https://vuejs.org/v2/api/#provide-inject | Vue inject}. It overrides the provide key if\n * the parent provides the same key.\n *\n * @remarks The decorated property needs to be public for type inference to work.\n *\n * @param provideKey - The key used to provide. This key can be a 'string' or a 'XInject<Type>'.\n * This last type is to support type-safe injection. When this decorator is used, it is possible\n * to specify the type of the injected value. Take a look to the example below.\n * @returns Decorator with the provide configuration.\n *\n * @example\n * Type unsafe injection (but allowed):\n *     \\@XProvide('myKey')\n *\n * Type safe injection (recommended):\n *     const myKey: XInjectKey<Date> = 'myKey';\n *     \\@XProvide(myKey)\n *\n * This last one, you are specifying that the injected value with the key 'myKey' has the Date\n * type.\n *\n * @public\n */\nexport function XProvide<Type>(provideKey: AnyInjectKey<Type>): DecoratorFor<Type> {\n  return createDecorator((options, componentKey) => {\n    const previousProvide = options.provide;\n    options.provide = function <ComponentInstance extends Vue>(this: ComponentInstance) {\n      const previousProvideObject = getPreviousProvideObject(previousProvide, this);\n      const newProvideObject = getNewProvideObject(provideKey, componentKey, this);\n      return Object.assign(previousProvideObject, newProvideObject);\n    };\n  });\n}\n\n/**\n * Generates an inject configuration object to inject a value provided by {@link XProvide}.\n * This function injects the value into a private property of the component instance using the\n * default {@link https://vuejs.org/v2/api/#provide-inject | Vue inject}. This private property\n * is named as the decorated property but prefixed with `_x-inject_`.\n *\n * Why is this private property necessary? Well, the {@link XProvide} decorator, provides an object\n * with the shape \\{ value: any \\} being that value a getter to keep reactivity of the injected\n * value. This private property is to \"shortcut\" that object and directly inject the value itself.\n * Otherwise, you should access to the actual value using `.value`.\n *\n * The final step is done by a computed property. This has the same name as the decorated property.\n * This computed returns the inner value getter of the injected object. This way the decorated\n * property has finally the initial injected value.\n *\n * @remarks The decorated property needs to be public for type inference to work.\n *\n * @param injectKey - The key used to inject. This key can be a 'string' or a 'XInject<Type>'.\n * This last type is to support type-safe injection. When this decorator is used, it is possible\n * to specify the type of the injected value. Take a look to the example below.\n * @returns Decorator with the provide configuration.\n *\n * @param defaultValue - The default value to use if there is not value provided.\n *\n * @example\n * Type unsafe injection (but allowed):\n *     \\@XInject('myKey')\n *\n * Type safe injection (recommended):\n *     const myKey: XInjectKey<Date> = 'myKey';\n *     \\@XInject(myKey)\n *\n * @public\n */\nexport function XInject<Type>(\n  injectKey: AnyInjectKey<Type>,\n  defaultValue?: Type\n): DecoratorFor<Type> {\n  return createDecorator((options, componentKey) => {\n    const privateComponentKey = `_x-inject_${componentKey}`;\n    const previousInjectObject = getPreviousInjectObject(options.inject);\n    const newInjectObject = getNewInjectObject(injectKey, privateComponentKey, defaultValue);\n    options.inject = Object.assign(previousInjectObject, newInjectObject);\n    const computedToPrivateProperty = getComputedProperty(componentKey, privateComponentKey);\n    options.computed = Object.assign(options.computed ?? {}, computedToPrivateProperty);\n  });\n}\n\n/**\n * This function receives the previous provide of the component instance.\n * If the provide is a function, then returns it as an object invoking it with the component\n * instance.\n * If the provide is an object then it is returned directly.\n * If the provide is undefined, then an empty object returned.\n *\n * @param previousProvide - The {@link ComponentOptions.provide } configuration that exist before\n * applying this decorator.\n * @param componentInstance - A Vue Component instance to invoke the provide function.\n *\n * @returns {@link ProvideObjectConfig} With the provide configuration as an object.\n */\nfunction getPreviousProvideObject<ComponentInstance extends Vue>(\n  previousProvide: ComponentOptions<Vue>['provide'],\n  componentInstance: ComponentInstance\n): ProvideObjectConfig {\n  if (isProvideFunction(previousProvide)) {\n    return previousProvide.call(componentInstance);\n  } else {\n    return previousProvide ?? {};\n  }\n}\n\n/**\n * This function creates a new provide configuration, wrapping the value to provide inside a getter\n * called `value`. This is done to keep the reactivity of the injected value.\n *\n * @param provideKey - The key of the provide value.\n * @param componentKey - The name of the property decorated with {@link XProvide}.\n * @param componentInstance - The {@link Vue} instance of the component to invoke the provide\n * function.\n *\n * @returns {@link ProvideObjectConfig} The object with the key of the provideKey and the `value`\n * getter.\n */\nfunction getNewProvideObject<ComponentInstance extends Vue>(\n  provideKey: AnyInjectKey<unknown>,\n  componentKey: string,\n  componentInstance: ComponentInstance\n): ProvideObjectConfig {\n  return {\n    [provideKey as string]: {\n      get value() {\n        return componentInstance[componentKey as keyof ComponentInstance];\n      }\n    }\n  };\n}\n\n/**\n * This function returns the previous inject config as an object. This will be used to merge it with\n * the new inject configuration.\n * If the previous inject config of the component instance is an Array, then it converts it into an\n * object.\n * If the previous inject config of the component instance is an object, then it returns it\n * directly.\n * If the previous inject config of the component instance is undefined, then an empty object is\n * returned.\n *\n * @param previousInject - The previous inject configuration of the component instance.\n *\n * @returns {@link InjectObjectConfig} The object with the previous inject config in form of object.\n */\nfunction getPreviousInjectObject(\n  previousInject: ComponentOptions<Vue>['inject']\n): InjectObjectConfig {\n  if (Array.isArray(previousInject)) {\n    return arrayToObject(previousInject);\n  } else {\n    return previousInject ?? {};\n  }\n}\n\n/**\n * This function returns the new inject configuration. This will be merged with the previous inject\n * configuration.\n * It returns an object with the key and a string if no `defaultValue` is passed. Otherwise it\n * returns an object with `from` and `default` keys.\n *\n * @param injectKey - The key of the injected value.\n * @param componentKey - The name of the component key where the value will be injected.\n * @param defaultValue - The default value of the injection if the `injectKey` has no provide.\n *\n * @returns The object with the inject configuration.\n */\nfunction getNewInjectObject<DefaultValue>(\n  injectKey: AnyInjectKey<unknown>,\n  componentKey: string,\n  defaultValue?: DefaultValue\n): InjectObjectConfig {\n  return { [componentKey]: { from: injectKey as string, default: { value: defaultValue } } };\n}\n\n/**\n * This function returns the computed configuration for bypass the `value` of the provide\n * of {@link XProvide}. This will be used to override the property decorated with {@link XInject}\n * with the computed.\n *\n * @param computedKey - The key used for the computed.\n * @param privateComponentKey - The \"private\" component property where the value is actually\n * injected.\n *\n * @returns The computed config to assign/merge with the component options.\n */\nfunction getComputedProperty(\n  computedKey: string,\n  privateComponentKey: string\n): ComponentOptions<Vue>['computed'] {\n  return {\n    [computedKey]: function (): unknown {\n      return (this as unknown as Record<string, { value: unknown }>)[privateComponentKey].value;\n    }\n  };\n}\n\n/**\n * Type guard to check if a provide configuration is a function.\n *\n * @param provide - The provide configuration.\n * @returns A boolean indicating if the passed provide is a function.\n */\nfunction isProvideFunction(\n  provide: ComponentOptions<Vue>['provide']\n): provide is (this: Vue) => ProvideObjectConfig {\n  return typeof provide === 'function';\n}\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n};\n","export interface Logger {\n  consoleLevel: LogLevel;\n  serverLevel: LogLevel;\n  error: LogFn;\n  warn: LogFn;\n  info: LogFn;\n  debug: LogFn;\n  trace: LogFn;\n  child: (...args: any[]) => Logger;\n}\n\nexport type LogFn = (...args: any[]) => void;\n\nexport enum LogLevel {\n  silent = 0,\n  error = 1,\n  warn = 2,\n  info = 3,\n  debug = 4,\n  trace = 5\n}\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.push(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.push(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","import { Logger, LogLevel } from './logger.interfaces';\n\nexport class SimpleLogger implements Logger {\n  private static commonConsoleLevel: LogLevel = LogLevel.warn;\n  private static commonServerLevel: LogLevel = LogLevel.error;\n  private readonly instanceTags: any[] = [];\n\n  public constructor(...args: any[]) {\n    this.instanceTags = args;\n  }\n\n  public set consoleLevel(level: LogLevel) {\n    SimpleLogger.commonConsoleLevel = level;\n  }\n\n  public get consoleLevel(): LogLevel {\n    return SimpleLogger.commonConsoleLevel;\n  }\n\n  public set serverLevel(level: LogLevel) {\n    SimpleLogger.commonServerLevel = level;\n  }\n\n  public get serverLevel(): LogLevel {\n    return SimpleLogger.commonServerLevel;\n  }\n\n  error(...args: any[]): void {\n    this.log(LogLevel.error, args);\n  }\n\n  warn(...args: any[]): void {\n    this.log(LogLevel.warn, args);\n  }\n\n  info(...args: any[]): void {\n    this.log(LogLevel.info, args);\n  }\n\n  debug(...args: any[]): void {\n    this.log(LogLevel.debug, args);\n  }\n\n  trace(...args: any[]): void {\n    this.log(LogLevel.trace, args);\n  }\n\n  child(...args: any[]): Logger {\n    return new SimpleLogger(...this.instanceTags, ...args);\n  }\n\n  private log(level: LogLevel, args: any[]): void {\n    if (this.consoleLevel >= level) {\n      this.sendLogToConsole(level, ...this.instanceTags.concat(args));\n    }\n    if (this.serverLevel >= level) {\n      this.sendLogToServer(level, ...this.instanceTags.concat(args));\n    }\n  }\n\n  private sendLogToConsole(level: LogLevel, ...args: any[]): void {\n    const consoleFunctionName = LogLevel[level] as Exclude<keyof typeof LogLevel, 'silent'>;\n    // To prevent failure on old browsers\n    if (console[consoleFunctionName]) {\n      console[consoleFunctionName](...args);\n    } else {\n      console.log(...args);\n    }\n  }\n\n  private sendLogToServer(level: LogLevel, ...args: any[]): void {\n    console.log(LogLevel[level], 'sending to server...', ...args);\n  }\n}\n","import { Logger, LogLevel } from './logger.interfaces';\nimport { SimpleLogger } from './simple-logger';\n\nexport const logger: Logger = new SimpleLogger();\nlogger.serverLevel = LogLevel.silent;\n","import { Logger, logger } from '@empathyco/x-logger';\nimport { StorageService } from './storage-service';\n\n/**\n * In browser implementation of the storage service.\n *\n * @public\n */\nexport class BrowserStorageService implements StorageService {\n  protected logger: Logger;\n\n  public constructor(private storage: Storage = localStorage, private prefix: string = 'empathy') {\n    this.logger = logger.child(`[StorageService][${prefix}]`);\n  }\n\n  /**\n   * Adds a new item in the browser storage.\n   *\n   * @param key - The key of the item.\n   * @param item - The item to save.\n   * @param ttlInMs - The TTL in ms of the item in the browser storage.\n   *\n   * @public\n   */\n  setItem(key: string, item: any, ttlInMs?: number): void {\n    if (item === undefined) {\n      this.logger.warn(`Tried to store an undefined object with key ${key}`);\n    } else {\n      const prefixedKey = this.prefixKey(key);\n      const expirableItem = this.createExpirableItem(item, ttlInMs);\n      const serializedItem = JSON.stringify(expirableItem);\n      this.storage.setItem(prefixedKey, serializedItem);\n    }\n  }\n\n  /**\n   * Retrieves an item by its key.\n   *\n   * @param key - The key of the item.\n   * @returns The founded item or null.\n   *\n   * @public\n   */\n  getItem<Item = any>(key: string): Item | null {\n    this.removeExpiredItems();\n    const prefixedKey = this.prefixKey(key);\n    const serializedItem = this.storage.getItem(prefixedKey);\n    if (serializedItem) {\n      const item = JSON.parse(serializedItem);\n      return this.getItemValue(item);\n    }\n    return null;\n  }\n\n  /**\n   * Removes an item by its key.\n   *\n   * @param key - The key of the item.\n   * @returns The removed item or null.\n   *\n   * @public\n   */\n  removeItem<Item = any>(key: string): Item | null {\n    const item = this.getItem(key);\n    const prefixedKey = this.prefixKey(key);\n    this.storage.removeItem(prefixedKey);\n    return item;\n  }\n\n  /**\n   * Clears the storage..\n   *\n   * @returns The number of removed items.\n   *\n   * @public\n   */\n  clear(): number {\n    return this.getOwnKeys().reduce((removedCount, key) => {\n      this.storage.removeItem(key);\n      return ++removedCount;\n    }, 0);\n  }\n\n  protected prefixKey(key: string): string {\n    return `${this.prefix}-${key}`;\n  }\n\n  protected createExpirableItem(item: any, ttlInMs?: number): any {\n    return {\n      ...(!!ttlInMs && { ttl: ttlInMs + this.currentTimestamp() }),\n      value: item\n    };\n  }\n\n  protected currentTimestamp(): number {\n    return Date.now();\n  }\n\n  protected getItemValue(item: any): any {\n    return item.value;\n  }\n\n  protected getOwnKeys(): string[] {\n    return Object.keys(this.storage).filter(key => key.startsWith(`${this.prefix}-`));\n  }\n\n  protected removeExpiredItems(): void {\n    this.getOwnKeys().forEach(key => {\n      const serializedItem = this.storage.getItem(key);\n      if (serializedItem) {\n        try {\n          const item = JSON.parse(serializedItem);\n          if (item.ttl && item.ttl <= this.currentTimestamp()) {\n            this.storage.removeItem(key);\n          }\n        } catch {\n          this.logger.warn(\n            // eslint-disable-next-line max-len\n            `Item for key ${key} has been removed from storage because it had an invalid JSON value: \"${serializedItem}\"`\n          );\n          this.storage.removeItem(key);\n        }\n      }\n    });\n  }\n}\n","import { StorageService } from './storage-service';\n\n/**\n * In memory implementation of the storage service.\n *\n * @public\n */\nexport class InMemoryStorageService implements StorageService {\n  protected storage: Record<string, any> = {};\n\n  /**\n   * Adds a new item in the storage.\n   *\n   * @param key - The key of the item.\n   * @param item - The item to save.\n   *\n   * @public\n   */\n  setItem(key: string, item: any): void {\n    this.storage[key] = item;\n  }\n\n  /**\n   * Retrieves an item by its key.\n   *\n   * @param key - The key of the item.\n   * @returns The founded item or null.\n   *\n   * @public\n   */\n  getItem<Item = any>(key: string): Item | null {\n    return this.storage[key] ?? null;\n  }\n\n  /**\n   * Removes an item by its key.\n   *\n   * @param key - The key of the item.\n   * @returns The removed item or null.\n   *\n   * @public\n   */\n  removeItem<Item = any>(key: string): Item | null {\n    const item = this.storage[key];\n    delete this.storage[key];\n    return item;\n  }\n\n  /**\n   * Clears the storage..\n   *\n   * @returns The number of removed items.\n   *\n   * @public\n   */\n  clear(): number {\n    const numberOfRemovedItems = Object.keys(this.storage).length;\n    this.storage = {};\n    return numberOfRemovedItems;\n  }\n}\n","import Vue, { CreateElement, VNode } from 'vue';\n\n/**\n * The purpose of this Component is to use as default value for props that receive a Component that\n * doesn't render any DOM element. For example the animations with `Transition` component.\n *\n * @internal\n */\nexport const NoElement = Vue.extend({\n  render(h: CreateElement): VNode {\n    return this.$slots.default?.[0] ?? h();\n  }\n});\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","/**\n * Returns true if the object is a function.\n * @param value The value to check\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n","/**\n * Used to create Error subclasses until the community moves away from ES5.\n *\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\n *\n * @param createImpl A factory function to create the actual constructor implementation. The returned\n * function should be a named function that calls `_super` internally.\n */\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\n  const _super = (instance: any) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (errors: any[]): UnsubscriptionError;\n}\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = createErrorClass(\n  (_super) =>\n    function UnsubscriptionErrorImpl(this: any, errors: (Error | string)[]) {\n      _super(this);\n      this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n      this.name = 'UnsubscriptionError';\n      this.errors = errors;\n    }\n);\n","/**\n * Removes an item from an array, mutating it.\n * @param arr The array to remove the item from\n * @param item The item to remove\n */\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\nimport { arrRemove } from './util/arrRemove';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n  })();\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   */\n  public closed = false;\n\n  private _parentage: Subscription[] | Subscription | null = null;\n\n  /**\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\n   * list occurs in the {@link #add} and {@link #remove} methods.\n   */\n  private _finalizers: Exclude<TeardownLogic, void>[] | null = null;\n\n  /**\n   * @param initialTeardown A function executed first as part of the finalization\n   * process that is kicked off when {@link #unsubscribe} is called.\n   */\n  constructor(private initialTeardown?: () => void) {}\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let errors: any[] | undefined;\n\n    if (!this.closed) {\n      this.closed = true;\n\n      // Remove this from it's parents.\n      const { _parentage } = this;\n      if (_parentage) {\n        this._parentage = null;\n        if (Array.isArray(_parentage)) {\n          for (const parent of _parentage) {\n            parent.remove(this);\n          }\n        } else {\n          _parentage.remove(this);\n        }\n      }\n\n      const { initialTeardown: initialFinalizer } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n\n      const { _finalizers } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors ?? [];\n            if (err instanceof UnsubscriptionError) {\n              errors = [...errors, ...err.errors];\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n\n  /**\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\n   *\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\n   * subscription to a any subscription will result in no operation. (A noop).\n   *\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\n   * operation at all. (A noop).\n   *\n   * `Subscription` instances that are added to this instance will automatically remove themselves\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\n   * will need to be removed manually with {@link #remove}\n   *\n   * @param teardown The finalization logic to add to this subscription.\n   */\n  add(teardown: TeardownLogic): void {\n    // Only add the finalizer if it's not undefined\n    // and don't add a subscription to itself.\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        // If this subscription is already closed,\n        // execute whatever finalizer is handed to it automatically.\n        execFinalizer(teardown);\n      } else {\n        if (teardown instanceof Subscription) {\n          // We don't add closed subscriptions, and we don't add the same subscription\n          // twice. Subscription unsubscribe is idempotent.\n          if (teardown.closed || teardown._hasParent(this)) {\n            return;\n          }\n          teardown._addParent(this);\n        }\n        (this._finalizers = this._finalizers ?? []).push(teardown);\n      }\n    }\n  }\n\n  /**\n   * Checks to see if a this subscription already has a particular parent.\n   * This will signal that this subscription has already been added to the parent in question.\n   * @param parent the parent to check for\n   */\n  private _hasParent(parent: Subscription) {\n    const { _parentage } = this;\n    return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n  }\n\n  /**\n   * Adds a parent to this subscription so it can be removed from the parent if it\n   * unsubscribes on it's own.\n   *\n   * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.\n   * @param parent The parent subscription to add\n   */\n  private _addParent(parent: Subscription) {\n    const { _parentage } = this;\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n  }\n\n  /**\n   * Called on a child when it is removed via {@link #remove}.\n   * @param parent The parent to remove\n   */\n  private _removeParent(parent: Subscription) {\n    const { _parentage } = this;\n    if (_parentage === parent) {\n      this._parentage = null;\n    } else if (Array.isArray(_parentage)) {\n      arrRemove(_parentage, parent);\n    }\n  }\n\n  /**\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\n   *\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\n   * is not a common thing and should be used thoughtfully.\n   *\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subscription` instance\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\n   *\n   * All finalizer instances are removed to free up memory upon unsubscription.\n   *\n   * @param teardown The finalizer to remove from this subscription\n   */\n  remove(teardown: Exclude<TeardownLogic, void>): void {\n    const { _finalizers } = this;\n    _finalizers && arrRemove(_finalizers, teardown);\n\n    if (teardown instanceof Subscription) {\n      teardown._removeParent(this);\n    }\n  }\n}\n\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\n\nexport function isSubscription(value: any): value is Subscription {\n  return (\n    value instanceof Subscription ||\n    (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe))\n  );\n}\n\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { ObservableNotification } from './types';\n\n/**\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\n * like how to react on unhandled errors.\n */\nexport const config: GlobalConfig = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: undefined,\n  useDeprecatedSynchronousErrorHandling: false,\n  useDeprecatedNextContext: false,\n};\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like how to react on unhandled errors. Accessible via {@link config}\n * object.\n */\nexport interface GlobalConfig {\n  /**\n   * A registration point for unhandled errors from RxJS. These are errors that\n   * cannot were not handled by consuming code in the usual subscription path. For\n   * example, if you have this configured, and you subscribe to an observable without\n   * providing an error handler, errors from that subscription will end up here. This\n   * will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onUnhandledError: ((err: any) => void) | null;\n\n  /**\n   * A registration point for notifications that cannot be sent to subscribers because they\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\n   * might want a different behavior. For example, with sources that attempt to report errors\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\n\n  /**\n   * The promise constructor used by default for {@link Observable#toPromise toPromise} and {@link Observable#forEach forEach}\n   * methods.\n   *\n   * @deprecated As of version 8, RxJS will no longer support this sort of injection of a\n   * Promise constructor. If you need a Promise implementation other than native promises,\n   * please polyfill/patch Promise as you see appropriate. Will be removed in v8.\n   */\n  Promise?: PromiseConstructorLike;\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BUY TIME\n   * FOR MIGRATION REASONS.\n   *\n   * @deprecated As of version 8, RxJS will no longer support synchronous throwing\n   * of unhandled errors. All errors will be thrown on a separate call stack to prevent bad\n   * behaviors described above. Will be removed in v8.\n   */\n  useDeprecatedSynchronousErrorHandling: boolean;\n\n  /**\n   * If true, enables an as-of-yet undocumented feature from v5: The ability to access\n   * `unsubscribe()` via `this` context in `next` functions created in observers passed\n   * to `subscribe`.\n   *\n   * This is being removed because the performance was severely problematic, and it could also cause\n   * issues when types other than POJOs are passed to subscribe as subscribers, as they will likely have\n   * their `this` context overwritten.\n   *\n   * @deprecated As of version 8, RxJS will no longer support altering the\n   * context of next functions provided as part of an observer to Subscribe. Instead,\n   * you will have access to a subscription or a signal or token that will allow you to do things like\n   * unsubscribe and test closed status. Will be removed in v8.\n   */\n  useDeprecatedNextContext: boolean;\n}\n","import type { TimerHandle } from './timerHandle';\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\n  },\n  delegate: undefined,\n};\n","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\n/**\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\n *\n * This should be called whenever there is an error that is out-of-band with the subscription\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\n *\n * @param err the error to report\n */\nexport function reportUnhandledError(err: any) {\n  timeoutProvider.setTimeout(() => {\n    const { onUnhandledError } = config;\n    if (onUnhandledError) {\n      // Execute the user-configured error handler.\n      onUnhandledError(err);\n    } else {\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\n      throw err;\n    }\n  });\n}\n","/* tslint:disable:no-empty */\nexport function noop() { }\n","import { CompleteNotification, NextNotification, ErrorNotification } from './types';\n\n/**\n * A completion object optimized for memory use and created to be the\n * same \"shape\" as other notifications in v8.\n * @internal\n */\nexport const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined) as CompleteNotification)();\n\n/**\n * Internal use only. Creates an optimized error notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function errorNotification(error: any): ErrorNotification {\n  return createNotification('E', undefined, error) as any;\n}\n\n/**\n * Internal use only. Creates an optimized next notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function nextNotification<T>(value: T) {\n  return createNotification('N', value, undefined) as NextNotification<T>;\n}\n\n/**\n * Ensures that all notifications created internally have the same \"shape\" in v8.\n *\n * TODO: This is only exported to support a crazy legacy test in `groupBy`.\n * @internal\n */\nexport function createNotification(kind: 'N' | 'E' | 'C', value: any, error: any) {\n  return {\n    kind,\n    value,\n    error,\n  };\n}\n","import { config } from '../config';\n\nlet context: { errorThrown: boolean; error: any } | null = null;\n\n/**\n * Handles dealing with errors for super-gross mode. Creates a context, in which\n * any synchronously thrown errors will be passed to {@link captureError}. Which\n * will record the error such that it will be rethrown after the call back is complete.\n * TODO: Remove in v8\n * @param cb An immediately executed function.\n */\nexport function errorContext(cb: () => void) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    const isRoot = !context;\n    if (isRoot) {\n      context = { errorThrown: false, error: null };\n    }\n    cb();\n    if (isRoot) {\n      const { errorThrown, error } = context!;\n      context = null;\n      if (errorThrown) {\n        throw error;\n      }\n    }\n  } else {\n    // This is the general non-deprecated path for everyone that\n    // isn't crazy enough to use super-gross mode (useDeprecatedSynchronousErrorHandling)\n    cb();\n  }\n}\n\n/**\n * Captures errors only in super-gross mode.\n * @param err the error to capture\n */\nexport function captureError(err: any) {\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\n    context.errorThrown = true;\n    context.error = err;\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: (observerOrNext ?? undefined) as (((value: T) => void) | undefined),\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent\n * @param subscriber The stopped subscriber\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n","/**\n * Symbol.observable or a string \"@@observable\". Used for interop\n *\n * @deprecated We will no longer be exporting this symbol in upcoming versions of RxJS.\n * Instead polyfill and use Symbol.observable directly *or* use https://www.npmjs.com/package/symbol-observable\n */\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n","/**\n * This function takes one parameter and just returns it. Simply put,\n * this is like `<T>(x: T): T => x`.\n *\n * ## Examples\n *\n * This is useful in some cases when using things like `mergeMap`\n *\n * ```ts\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\n *\n * const source$ = interval(1000).pipe(take(5));\n *\n * const result$ = source$.pipe(\n *   map(i => range(i)),\n *   mergeMap(identity) // same as mergeMap(x => x)\n * );\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * Or when you want to selectively apply an operator\n *\n * ```ts\n * import { interval, take, identity } from 'rxjs';\n *\n * const shouldLimit = () => Math.random() < 0.5;\n *\n * const source$ = interval(1000);\n *\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * @param x Any value that is returned by this function\n * @returns The value passed as the first parameter to this function\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n","import { identity } from './identity';\nimport { UnaryFunction } from '../types';\n\nexport function pipe(): typeof identity;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>\n): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>\n): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>\n): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>\n): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>\n): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>\n): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>,\n  ...fns: UnaryFunction<any, any>[]\n): UnaryFunction<T, unknown>;\n\n/**\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\n * and uses it to return a value.\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\n * passes the result to the next one, passes that result to the next one, and so on.  \n */\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (fns.length === 0) {\n    return identity as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","import { Operator } from './Operator';\nimport { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription, Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, Subscribable, Observer } from './types';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  source: Observable<any> | undefined;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  operator: Operator<any, T> | undefined;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new Observable by calling the Observable constructor\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new observable\n   * @nocollapse\n   * @deprecated Use `new Observable()` instead. Will be removed in v8.\n   */\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable instance as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param operator the operator defining the operation to take on the observable\n   * @return a new observable with the Operator applied\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * If you have implemented an operator using `lift`, it is recommended that you create an\n   * operator by simply returning `new Observable()` directly. See \"Creating new operators from\n   * scratch\" section here: https://rxjs.dev/guide/operators\n   */\n  lift<R>(operator?: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void)): Subscription;\n  /** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\n   * an `error` method to avoid missing thrown errors.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\n   *\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * #### Examples\n   *\n   * Subscribe with an {@link guide/observer Observer}\n   *\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\n   *\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Cancel a subscription\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe({\n   *   next(num) {\n   *     console.log(num)\n   *   },\n   *   complete() {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * });\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // 'unsubscribed!' after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   * or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   * Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   * the error will be thrown asynchronously as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {Subscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((error: any) => void) | null,\n    complete?: (() => void) | null\n  ): Subscription {\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n\n    errorContext(() => {\n      const { operator, source } = this;\n      subscriber.add(\n        operator\n          ? // We're dealing with a subscription in the\n            // operator chain to one of our lifted operators.\n            operator.call(subscriber, source)\n          : source\n          ? // If `source` has a value, but `operator` does not, something that\n            // had intimate knowledge of our API, like our `Subject`, must have\n            // set it. We're going to just call `_subscribe` directly.\n            this._subscribe(subscriber)\n          : // In all other cases, we're likely wrapping a user-provided initializer\n            // function, so we need to catch errors and handle them appropriately.\n            this._trySubscribe(subscriber)\n      );\n    });\n\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      // We don't need to return anything in this case,\n      // because it's just going to try to `add()` to a subscription\n      // above.\n      sink.error(err);\n    }\n  }\n\n  /**\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * #### Example\n   *\n   * ```ts\n   * import { interval, take } from 'rxjs';\n   *\n   * const source$ = interval(1000).pipe(take(4));\n   *\n   * async function getTotal() {\n   *   let total = 0;\n   *\n   *   await source$.forEach(value => {\n   *     total += value;\n   *     console.log('observable -> ' + value);\n   *   });\n   *\n   *   return total;\n   * }\n   *\n   * getTotal().then(\n   *   total => console.log('Total: ' + total)\n   * );\n   *\n   * // Expected:\n   * // 'observable -> 0'\n   * // 'observable -> 1'\n   * // 'observable -> 2'\n   * // 'observable -> 3'\n   * // 'Total: 6'\n   * ```\n   *\n   * @param next a handler for each value emitted by the observable\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void): Promise<void>;\n\n  /**\n   * @param next a handler for each value emitted by the observable\n   * @param promiseCtor a constructor function used to instantiate the Promise\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   * @deprecated Passing a Promise constructor will no longer be available\n   * in upcoming versions of RxJS. This is because it adds weight to the library, for very\n   * little benefit. If you need this functionality, it is recommended that you either\n   * polyfill Promise, or you create an adapter to convert the returned native promise\n   * to whatever promise implementation you wanted. Will be removed in v8.\n   */\n  forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;\n\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      const subscriber = new SafeSubscriber<T>({\n        next: (value) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve,\n      });\n      this.subscribe(subscriber);\n    }) as Promise<void>;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source?.subscribe(subscriber);\n  }\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>\n  ): Observable<D>;\n  pipe<A, B, C, D, E>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>\n  ): Observable<E>;\n  pipe<A, B, C, D, E, F>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>\n  ): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>\n  ): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>\n  ): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>\n  ): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>,\n    ...operations: OperatorFunction<any, any>[]\n  ): Observable<unknown>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, filter, map, scan } from 'rxjs';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Subscribe to this Observable and get a Promise resolving on\n   * `complete` with the last emission (if any).\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * @method toPromise\n   * @param [promiseCtor] a constructor function used to instantiate\n   * the Promise\n   * @return A Promise that resolves with the last value emit, or\n   * rejects on an error. If there were no emissions, Promise\n   * resolves with undefined.\n   * @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise\n   */\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: T | undefined;\n      this.subscribe(\n        (x: T) => (value = x),\n        (err: any) => reject(err),\n        () => resolve(value)\n      );\n    }) as Promise<T | undefined>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  return promiseCtor ?? config.Promise ?? Promise;\n}\n\nfunction isObserver<T>(value: any): value is Observer<T> {\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\n\nfunction isSubscriber<T>(value: any): value is Subscriber<T> {\n  return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n","import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\nimport { isFunction } from './isFunction';\n\n/**\n * Used to determine if an object is an Observable with a lift function.\n */\nexport function hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\n  return isFunction(source?.lift);\n}\n\n/**\n * Creates an `OperatorFunction`. Used to define operators throughout the library in a concise way.\n * @param init The logic to connect the liftedSource to the subscriber at the moment of subscription.\n */\nexport function operate<T, R>(\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\n): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    if (hasLift(source)) {\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\n        try {\n          return init(liftedSource, this);\n        } catch (err) {\n          this.error(err);\n        }\n      });\n    }\n    throw new TypeError('Unable to lift unknown Observable type');\n  };\n}\n","import { Subscriber } from '../Subscriber';\n\n/**\n * Creates an instance of an `OperatorSubscriber`.\n * @param destination The downstream subscriber.\n * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n * and send to the `destination` error handler.\n * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n * this handler are sent to the `destination` error handler.\n * @param onFinalize Additional teardown logic here. This will only be called on teardown if the\n * subscriber itself is not already closed. This is called after all other teardown logic is executed.\n */\nexport function createOperatorSubscriber<T>(\n  destination: Subscriber<any>,\n  onNext?: (value: T) => void,\n  onComplete?: () => void,\n  onError?: (err: any) => void,\n  onFinalize?: () => void\n): Subscriber<T> {\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\n\n/**\n * A generic helper for allowing operators to be created with a Subscriber and\n * use closures to capture necessary state from the operator function itself.\n */\nexport class OperatorSubscriber<T> extends Subscriber<T> {\n  /**\n   * Creates an instance of an `OperatorSubscriber`.\n   * @param destination The downstream subscriber.\n   * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n   * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n   * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n   * and send to the `destination` error handler.\n   * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n   * this handler are sent to the `destination` error handler.\n   * @param onFinalize Additional finalization logic here. This will only be called on finalization if the\n   * subscriber itself is not already closed. This is called after all other finalization logic is executed.\n   * @param shouldUnsubscribe An optional check to see if an unsubscribe call should truly unsubscribe.\n   * NOTE: This currently **ONLY** exists to support the strange behavior of {@link groupBy}, where unsubscription\n   * to the resulting observable does not actually disconnect from the source if there are active subscriptions\n   * to any grouped observable. (DO NOT EXPOSE OR USE EXTERNALLY!!!)\n   */\n  constructor(\n    destination: Subscriber<any>,\n    onNext?: (value: T) => void,\n    onComplete?: () => void,\n    onError?: (err: any) => void,\n    private onFinalize?: () => void,\n    private shouldUnsubscribe?: () => boolean\n  ) {\n    // It's important - for performance reasons - that all of this class's\n    // members are initialized and that they are always initialized in the same\n    // order. This will ensure that all OperatorSubscriber instances have the\n    // same hidden class in V8. This, in turn, will help keep the number of\n    // hidden classes involved in property accesses within the base class as\n    // low as possible. If the number of hidden classes involved exceeds four,\n    // the property accesses will become megamorphic and performance penalties\n    // will be incurred - i.e. inline caches won't be used.\n    //\n    // The reasons for ensuring all instances have the same hidden class are\n    // further discussed in this blog post from Benedikt Meurer:\n    // https://benediktmeurer.de/2018/03/23/impact-of-polymorphism-on-component-based-frameworks-like-react/\n    super(destination);\n    this._next = onNext\n      ? function (this: OperatorSubscriber<T>, value: T) {\n          try {\n            onNext(value);\n          } catch (err) {\n            destination.error(err);\n          }\n        }\n      : super._next;\n    this._error = onError\n      ? function (this: OperatorSubscriber<T>, err: any) {\n          try {\n            onError(err);\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._error;\n    this._complete = onComplete\n      ? function (this: OperatorSubscriber<T>) {\n          try {\n            onComplete();\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._complete;\n  }\n\n  unsubscribe() {\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      const { closed } = this;\n      super.unsubscribe();\n      // Execute additional teardown if we have any and we didn't already do so.\n      !closed && this.onFinalize?.();\n    }\n  }\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface ObjectUnsubscribedError extends Error {}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ObjectUnsubscribedError;\n}\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\n  (_super) =>\n    function ObjectUnsubscribedErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ObjectUnsubscribedError';\n      this.message = 'object unsubscribed';\n    }\n);\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  closed = false;\n\n  private currentObservers: Observer<T>[] | null = null;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  observers: Observer<T>[] = [];\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  isStopped = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  /**\n   * Creates a \"subject\" by basically gluing an observer to an observable.\n   *\n   * @nocollapse\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\n   */\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  };\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = operator as any;\n    return subject as any;\n  }\n\n  /** @internal */\n  protected _throwIfClosed() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n  }\n\n  next(value: T) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        if (!this.currentObservers) {\n          this.currentObservers = Array.from(this.observers);\n        }\n        for (const observer of this.currentObservers) {\n          observer.next(value);\n        }\n      }\n    });\n  }\n\n  error(err: any) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.hasError = this.isStopped = true;\n        this.thrownError = err;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.error(err);\n        }\n      }\n    });\n  }\n\n  complete() {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.isStopped = true;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.complete();\n        }\n      }\n    });\n  }\n\n  unsubscribe() {\n    this.isStopped = this.closed = true;\n    this.observers = this.currentObservers = null!;\n  }\n\n  get observed() {\n    return this.observers?.length > 0;\n  }\n\n  /** @internal */\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    this._throwIfClosed();\n    return super._trySubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    const { hasError, isStopped, observers } = this;\n    if (hasError || isStopped) {\n      return EMPTY_SUBSCRIPTION;\n    }\n    this.currentObservers = null;\n    observers.push(subscriber);\n    return new Subscription(() => {\n      this.currentObservers = null;\n      arrRemove(observers, subscriber);\n    });\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, isStopped } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return {Observable} Observable that the Subject casts to\n   */\n  asObservable(): Observable<T> {\n    const observable: any = new Observable<T>();\n    observable.source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n    public destination?: Observer<T>,\n    source?: Observable<T>\n  ) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    this.destination?.next?.(value);\n  }\n\n  error(err: any) {\n    this.destination?.error?.(err);\n  }\n\n  complete() {\n    this.destination?.complete?.();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\n  }\n}\n","import { TimestampProvider } from '../types';\n\ninterface DateTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const dateTimestampProvider: DateTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (dateTimestampProvider.delegate || Date).now();\n  },\n  delegate: undefined,\n};\n","import { Subject } from './Subject';\nimport { TimestampProvider } from './types';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * A variant of {@link Subject} that \"replays\" old values to new subscribers by emitting them when they first subscribe.\n *\n * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,\n * `ReplaySubject` \"observes\" values by having them passed to its `next` method. When it observes a value, it will store that\n * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.\n *\n * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in\n * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will\n * error if it has observed an error.\n *\n * There are two main configuration items to be concerned with:\n *\n * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.\n * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.\n *\n * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values\n * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.\n *\n * ### Differences with BehaviorSubject\n *\n * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple of exceptions:\n *\n * 1. `BehaviorSubject` comes \"primed\" with a single value upon construction.\n * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n * @see {@link shareReplay}\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _buffer: (T | number)[] = [];\n  private _infiniteTimeWindow = true;\n\n  /**\n   * @param bufferSize The size of the buffer to replay on subscription\n   * @param windowTime The amount of time the buffered items will stay buffered\n   * @param timestampProvider An object with a `now()` method that provides the current timestamp. This is used to\n   * calculate the amount of time something has been buffered.\n   */\n  constructor(\n    private _bufferSize = Infinity,\n    private _windowTime = Infinity,\n    private _timestampProvider: TimestampProvider = dateTimestampProvider\n  ) {\n    super();\n    this._infiniteTimeWindow = _windowTime === Infinity;\n    this._bufferSize = Math.max(1, _bufferSize);\n    this._windowTime = Math.max(1, _windowTime);\n  }\n\n  next(value: T): void {\n    const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n    if (!isStopped) {\n      _buffer.push(value);\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n    }\n    this._trimBuffer();\n    super.next(value);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._trimBuffer();\n\n    const subscription = this._innerSubscribe(subscriber);\n\n    const { _infiniteTimeWindow, _buffer } = this;\n    // We use a copy here, so reentrant code does not mutate our array while we're\n    // emitting it to a new subscriber.\n    const copy = _buffer.slice();\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n      subscriber.next(copy[i] as T);\n    }\n\n    this._checkFinalizedStatuses(subscriber);\n\n    return subscription;\n  }\n\n  private _trimBuffer() {\n    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n    // If we don't have an infinite buffer size, and we're over the length,\n    // use splice to truncate the old buffer values off. Note that we have to\n    // double the size for instances where we're not using an infinite time window\n    // because we're storing the values and the timestamps in the same array.\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n\n    // Now, if we're not in an infinite time window, remove all values where the time is\n    // older than what is allowed.\n    if (!_infiniteTimeWindow) {\n      const now = _timestampProvider.now();\n      let last = 0;\n      // Search the array for the first timestamp that isn't expired and\n      // truncate the buffer up to that point.\n      for (let i = 1; i < _buffer.length && (_buffer[i] as number) <= now; i += 2) {\n        last = i;\n      }\n      last && _buffer.splice(0, last + 1);\n    }\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import type { TimerHandle } from './timerHandle';\ntype SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearIntervalFunction = (handle: TimerHandle) => void;\n\ninterface IntervalProvider {\n  setInterval: SetIntervalFunction;\n  clearInterval: ClearIntervalFunction;\n  delegate:\n    | {\n        setInterval: SetIntervalFunction;\n        clearInterval: ClearIntervalFunction;\n      }\n    | undefined;\n}\n\nexport const intervalProvider: IntervalProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setInterval(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = intervalProvider;\n    if (delegate?.setInterval) {\n      return delegate.setInterval(handler, timeout, ...args);\n    }\n    return setInterval(handler, timeout, ...args);\n  },\n  clearInterval(handle) {\n    const { delegate } = intervalProvider;\n    return (delegate?.clearInterval || clearInterval)(handle as any);\n  },\n  delegate: undefined,\n};\n","import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncAction<T> extends Action<T> {\n  public id: TimerHandle | undefined;\n  public state?: T;\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: TimerHandle, delay: number = 0): TimerHandle {\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id?: TimerHandle, delay: number | null = 0): TimerHandle | undefined {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    if (id != null) {\n      intervalProvider.clearInterval(id);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, _delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\n      // return here, we can't have it return \"\" or 0 or false.\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      const { id, scheduler } = this;\n      const { actions } = scheduler;\n\n      this.work = this.state = this.scheduler = null!;\n      this.pending = false;\n\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null!;\n      super.unsubscribe();\n    }\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}. Will be made internal in v8.\n */\nexport class Scheduler implements SchedulerLike {\n  public static now: () => number = dateTimestampProvider.now;\n\n  constructor(private schedulerActionCtor: typeof Action, now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @internal\n   */\n  public _active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @internal\n   */\n  public _scheduled: TimerHandle | undefined;\n\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\n\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n\n/**\n * @deprecated Renamed to {@link asyncScheduler}. Will be removed in v8.\n */\nexport const async = asyncScheduler;\n","export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n","import { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { ObservableInput, ObservedValueOf, ReadableStreamLike } from '../types';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { Subscriber } from '../Subscriber';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function innerFrom<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\nexport function innerFrom<T>(input: ObservableInput<T>): Observable<T> {\n  if (input instanceof Observable) {\n    return input;\n  }\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return fromInteropObservable(input);\n    }\n    if (isArrayLike(input)) {\n      return fromArrayLike(input);\n    }\n    if (isPromise(input)) {\n      return fromPromise(input);\n    }\n    if (isAsyncIterable(input)) {\n      return fromAsyncIterable(input);\n    }\n    if (isIterable(input)) {\n      return fromIterable(input);\n    }\n    if (isReadableStreamLike(input)) {\n      return fromReadableStreamLike(input);\n    }\n  }\n\n  throw createInvalidObservableTypeError(input);\n}\n\n/**\n * Creates an RxJS Observable from an object that implements `Symbol.observable`.\n * @param obj An object that properly implements `Symbol.observable`.\n */\nexport function fromInteropObservable<T>(obj: any) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    const obs = obj[Symbol_observable]();\n    if (isFunction(obs.subscribe)) {\n      return obs.subscribe(subscriber);\n    }\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  });\n}\n\n/**\n * Synchronously emits the values of an array like and completes.\n * This is exported because there are creation functions and operators that need to\n * make direct use of the same logic, and there's no reason to make them run through\n * `from` conditionals because we *know* they're dealing with an array.\n * @param array The array to emit values from\n */\nexport function fromArrayLike<T>(array: ArrayLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    // Loop over the array and emit each value. Note two things here:\n    // 1. We're making sure that the subscriber is not closed on each loop.\n    //    This is so we don't continue looping over a very large array after\n    //    something like a `take`, `takeWhile`, or other synchronous unsubscription\n    //    has already unsubscribed.\n    // 2. In this form, reentrant code can alter that array we're looping over.\n    //    This is a known issue, but considered an edge case. The alternative would\n    //    be to copy the array before executing the loop, but this has\n    //    performance implications.\n    for (let i = 0; i < array.length && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromPromise<T>(promise: PromiseLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    promise\n      .then(\n        (value) => {\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        },\n        (err: any) => subscriber.error(err)\n      )\n      .then(null, reportUnhandledError);\n  });\n}\n\nexport function fromIterable<T>(iterable: Iterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    for (const value of iterable) {\n      subscriber.next(value);\n      if (subscriber.closed) {\n        return;\n      }\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromAsyncIterable<T>(asyncIterable: AsyncIterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n  });\n}\n\nexport function fromReadableStreamLike<T>(readableStream: ReadableStreamLike<T>) {\n  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\n\nasync function process<T>(asyncIterable: AsyncIterable<T>, subscriber: Subscriber<T>) {\n  for await (const value of asyncIterable) {\n    subscriber.next(value);\n    // A side-effect may have closed our subscriber,\n    // check before the next iteration.\n    if (subscriber.closed) {\n      return;\n    }\n  }\n  subscriber.complete();\n}\n","import { InteropObservable } from '../types';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport function isInteropObservable(input: any): input is InteropObservable<any> {\n  return isFunction(input[Symbol_observable]);\n}\n","export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number' && typeof x !== 'function');","import { isFunction } from \"./isFunction\";\n\n/**\n * Tests to see if the object is \"thennable\".\n * @param value the object to test\n */\nexport function isPromise(value: any): value is PromiseLike<any> {\n  return isFunction(value?.then);\n}\n","import { isFunction } from './isFunction';\n\nexport function isAsyncIterable<T>(obj: any): obj is AsyncIterable<T> {\n  return Symbol.asyncIterator && isFunction(obj?.[Symbol.asyncIterator]);\n}\n","import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return isFunction(input?.[Symbol_iterator]);\n}\n","import { ReadableStreamLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport async function* readableStreamLikeToAsyncGenerator<T>(readableStream: ReadableStreamLike<T>): AsyncGenerator<T> {\n  const reader = readableStream.getReader();\n  try {\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value!;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function isReadableStreamLike<T>(obj: any): obj is ReadableStreamLike<T> {\n  // We don't want to use instanceof checks because they would return\n  // false for instances from another Realm, like an <iframe>.\n  return isFunction(obj?.getReader);\n}\n","/**\n * Creates the TypeError to throw if an invalid object is passed to `from` or `scheduled`.\n * @param input The object that was passed.\n */\nexport function createInvalidObservableTypeError(input: any) {\n  // TODO: We should create error codes that can be looked up, so this can be less verbose.\n  return new TypeError(\n    `You provided ${\n      input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`\n    } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`\n  );\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function map<T, R, A>(project: (this: A, value: T, index: number) => R, thisArg: A): OperatorFunction<T, R>;\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n *\n * Map every click to the `clientX` position of that click\n *\n * ```ts\n * import { fromEvent, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n *\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return A function that returns an Observable that emits the values from the\n * source Observable transformed by the given `project` function.\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return operate((source, subscriber) => {\n    // The index of the value from the source. Used with projection.\n    let index = 0;\n    // Subscribe to the source, all errors and completions are sent along\n    // to the consumer.\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value: T) => {\n        // Call the projection function with the appropriate this context,\n        // and send the resulting value to the consumer.\n        subscriber.next(project.call(thisArg, value, index++));\n      })\n    );\n  });\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { async as asyncScheduler } from '../scheduler/async';\nimport { isScheduler } from '../util/isScheduler';\nimport { isValidDate } from '../util/isDate';\n\n/**\n * Creates an observable that will wait for a specified time period, or exact date, before\n * emitting the number 0.\n *\n * <span class=\"informal\">Used to emit a notification after a delay.</span>\n *\n * This observable is useful for creating delays in code, or racing against other values\n * for ad-hoc timeouts.\n *\n * The `delay` is specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Examples\n *\n * Wait 3 seconds and start another observable\n *\n * You might want to use `timer` to delay subscription to an\n * observable by a set amount of time. Here we use a timer with\n * {@link concatMapTo} or {@link concatMap} in order to wait\n * a few seconds and start a subscription to a source.\n *\n * ```ts\n * import { of, timer, concatMap } from 'rxjs';\n *\n * // This could be any observable\n * const source = of(1, 2, 3);\n *\n * timer(3000)\n *   .pipe(concatMap(() => source))\n *   .subscribe(console.log);\n * ```\n *\n * Take all values until the start of the next minute\n *\n * Using a `Date` as the trigger for the first emission, you can\n * do things like wait until midnight to fire an event, or in this case,\n * wait until a new minute starts (chosen so the example wouldn't take\n * too long to run) in order to stop watching a stream. Leveraging\n * {@link takeUntil}.\n *\n * ```ts\n * import { interval, takeUntil, timer } from 'rxjs';\n *\n * // Build a Date object that marks the\n * // next minute.\n * const currentDate = new Date();\n * const startOfNextMinute = new Date(\n *   currentDate.getFullYear(),\n *   currentDate.getMonth(),\n *   currentDate.getDate(),\n *   currentDate.getHours(),\n *   currentDate.getMinutes() + 1\n * );\n *\n * // This could be any observable stream\n * const source = interval(1000);\n *\n * const result = source.pipe(\n *   takeUntil(timer(startOfNextMinute))\n * );\n *\n * result.subscribe(console.log);\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `dueTime`.\n *\n * @param due If a `number`, the amount of time in milliseconds to wait before emitting.\n * If a `Date`, the exact time at which to emit.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(due: number | Date, scheduler?: SchedulerLike): Observable<0>;\n\n/**\n * Creates an observable that starts an interval after a specified delay, emitting incrementing numbers -- starting at `0` --\n * on each interval after words.\n *\n * The `delay` and `intervalDuration` are specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Example\n *\n * ### Start an interval that starts right away\n *\n * Since {@link interval} waits for the passed delay before starting,\n * sometimes that's not ideal. You may want to start an interval immediately.\n * `timer` works well for this. Here we have both side-by-side so you can\n * see them in comparison.\n *\n * Note that this observable will never complete.\n *\n * ```ts\n * import { timer, interval } from 'rxjs';\n *\n * timer(0, 1000).subscribe(n => console.log('timer', n));\n * interval(1000).subscribe(n => console.log('interval', n));\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `startDue`.\n * @param startDue If a `number`, is the time to wait before starting the interval.\n * If a `Date`, is the exact time at which to start the interval.\n * @param intervalDuration The delay between each value emitted in the interval. Passing a\n * negative number here will result in immediate completion after the first value is emitted, as though\n * no `intervalDuration` was passed at all.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(startDue: number | Date, intervalDuration: number, scheduler?: SchedulerLike): Observable<number>;\n\n/**\n * @deprecated The signature allowing `undefined` to be passed for `intervalDuration` will be removed in v8. Use the `timer(dueTime, scheduler?)` signature instead.\n */\nexport function timer(dueTime: number | Date, unused: undefined, scheduler?: SchedulerLike): Observable<0>;\n\nexport function timer(\n  dueTime: number | Date = 0,\n  intervalOrScheduler?: number | SchedulerLike,\n  scheduler: SchedulerLike = asyncScheduler\n): Observable<number> {\n  // Since negative intervalDuration is treated as though no\n  // interval was specified at all, we start with a negative number.\n  let intervalDuration = -1;\n\n  if (intervalOrScheduler != null) {\n    // If we have a second argument, and it's a scheduler,\n    // override the scheduler we had defaulted. Otherwise,\n    // it must be an interval.\n    if (isScheduler(intervalOrScheduler)) {\n      scheduler = intervalOrScheduler;\n    } else {\n      // Note that this *could* be negative, in which case\n      // it's like not passing an intervalDuration at all.\n      intervalDuration = intervalOrScheduler;\n    }\n  }\n\n  return new Observable((subscriber) => {\n    // If a valid date is passed, calculate how long to wait before\n    // executing the first value... otherwise, if it's a number just schedule\n    // that many milliseconds (or scheduler-specified unit size) in the future.\n    let due = isValidDate(dueTime) ? +dueTime - scheduler!.now() : dueTime;\n\n    if (due < 0) {\n      // Ensure we don't schedule in the future.\n      due = 0;\n    }\n\n    // The incrementing value we emit.\n    let n = 0;\n\n    // Start the timer.\n    return scheduler.schedule(function () {\n      if (!subscriber.closed) {\n        // Emit the next value and increment.\n        subscriber.next(n++);\n\n        if (0 <= intervalDuration) {\n          // If we have a interval after the initial timer,\n          // reschedule with the period.\n          this.schedule(undefined, intervalDuration);\n        } else {\n          // We didn't have an interval. So just complete.\n          subscriber.complete();\n        }\n      }\n    }, due);\n  });\n}\n","import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && isFunction(value.schedule);\n}\n","/**\n * Checks to see if a value is not only a `Date` object,\n * but a *valid* `Date` object that can be converted to a\n * number. For example, `new Date('blah')` is indeed an\n * `instanceof Date`, however it cannot be converted to a\n * number.\n */\nexport function isValidDate(value: any): value is Date {\n  return value instanceof Date && !isNaN(value as any);\n}\n","const { isArray } = Array;\n\n/**\n * Used in operators and functions that accept either a list of arguments, or an array of arguments\n * as a single argument.\n */\nexport function argsOrArgArray<T>(args: (T | T[])[]): T[] {\n  return args.length === 1 && isArray(args[0]) ? args[0] : (args as T[]);\n}\n","import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, S extends T, A>(predicate: (this: A, value: T, index: number) => value is S, thisArg: A): OperatorFunction<T, S>;\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function filter<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, A>(predicate: (this: A, value: T, index: number) => boolean, thisArg: A): MonoTypeOperatorFunction<T>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * ![](filter.png)\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * ## Example\n *\n * Emit only click events whose target was a DIV element\n *\n * ```ts\n * import { fromEvent, filter } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksOnDivs = clicks.pipe(filter(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * clicksOnDivs.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param thisArg An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return A function that returns an Observable that emits items from the\n * source Observable that satisfy the specified `predicate`.\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    // An index passed to our predicate function on each call.\n    let index = 0;\n\n    // Subscribe to the source, all errors and completions are\n    // forwarded to the consumer.\n    source.subscribe(\n      // Call the predicate with the appropriate `this` context,\n      // if the predicate returns `true`, then send the value\n      // to the consumer.\n      createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value))\n    );\n  });\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, ObservableInputTuple } from '../types';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { Subscriber } from '../Subscriber';\n\nexport function race<T extends readonly unknown[]>(inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\nexport function race<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\n\n/**\n * Returns an observable that mirrors the first source observable to emit an item.\n *\n * ![](race.png)\n *\n * `race` returns an observable, that when subscribed to, subscribes to all source observables immediately.\n * As soon as one of the source observables emits a value, the result unsubscribes from the other sources.\n * The resulting observable will forward all notifications, including error and completion, from the \"winning\"\n * source observable.\n *\n * If one of the used source observable throws an errors before a first notification\n * the race operator will also throw an error, no matter if another source observable\n * could potentially win the race.\n *\n * `race` can be useful for selecting the response from the fastest network connection for\n * HTTP or WebSockets. `race` can also be useful for switching observable context based on user\n * input.\n *\n * ## Example\n *\n * Subscribes to the observable that was the first to start emitting.\n *\n * ```ts\n * import { interval, map, race } from 'rxjs';\n *\n * const obs1 = interval(7000).pipe(map(() => 'slow one'));\n * const obs2 = interval(3000).pipe(map(() => 'fast one'));\n * const obs3 = interval(5000).pipe(map(() => 'medium one'));\n *\n * race(obs1, obs2, obs3)\n *   .subscribe(winner => console.log(winner));\n *\n * // Outputs\n * // a series of 'fast one'\n * ```\n *\n * @param {...Observables} ...observables sources used to race for which Observable emits first.\n * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.\n */\nexport function race<T>(...sources: (ObservableInput<T> | ObservableInput<T>[])[]): Observable<any> {\n  sources = argsOrArgArray(sources);\n  // If only one source was passed, just return it. Otherwise return the race.\n  return sources.length === 1 ? innerFrom(sources[0] as ObservableInput<T>) : new Observable<T>(raceInit(sources as ObservableInput<T>[]));\n}\n\n/**\n * An observable initializer function for both the static version and the\n * operator version of race.\n * @param sources The sources to race\n */\nexport function raceInit<T>(sources: ObservableInput<T>[]) {\n  return (subscriber: Subscriber<T>) => {\n    let subscriptions: Subscription[] = [];\n\n    // Subscribe to all of the sources. Note that we are checking `subscriptions` here\n    // Is is an array of all actively \"racing\" subscriptions, and it is `null` after the\n    // race has been won. So, if we have racer that synchronously \"wins\", this loop will\n    // stop before it subscribes to any more.\n    for (let i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {\n      subscriptions.push(\n        innerFrom(sources[i] as ObservableInput<T>).subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            if (subscriptions) {\n              // We're still racing, but we won! So unsubscribe\n              // all other subscriptions that we have, except this one.\n              for (let s = 0; s < subscriptions.length; s++) {\n                s !== i && subscriptions[s].unsubscribe();\n              }\n              subscriptions = null!;\n            }\n            subscriber.next(value);\n          })\n        )\n      );\n    }\n  };\n}\n","import { AnyFunction } from '@empathyco/x-utils';\nimport { Observable, Subscription } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport Vue, { WatchOptions } from 'vue';\nimport { createDecorator } from 'vue-class-component';\nimport { EventPayload, SubjectPayload } from '@empathyco/x-bus';\nimport { clone } from '../../utils/clone';\nimport { DecoratorFor } from '../../utils/types';\nimport { XEvent, XEventPayload, XEventsTypes } from '../../wiring/events.types';\nimport { WireMetadata } from '../../wiring/wiring.types';\n\n/**\n * Creates a subscription to an {@link XEvent}, an array of {@link XEvent} or a component property (\n * reacting to its changes via a watcher) filtering out the passed metadata, if any, and\n * un-subscribes on the beforeDestroy hook.\n *\n * @remarks\n * The decorated property needs to be public for type inference to work.\n *\n * @param xEvent - The {@link XEvent}, an array of {@link XEvent} or a component property.\n * @param metadataFilteringOptions - The {@link WireMetadata} options to filter out a callback\n * execution.\n * @returns Decorator that creates a subscription to an {@link XEvent} and un-subscribes on the\n * beforeDestroy hook.\n * @public\n */\nexport function XOn<Event extends XEvent>(\n  xEvent: Event | Event[] | ((component: Vue) => Event | Event[]),\n  metadataFilteringOptions: Partial<WireMetadata> = {}\n): DecoratorFor<(payload: XEventPayload<Event>, metadata: WireMetadata) => void> {\n  return createDecorator((options, key) => {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const originalCreated = options.created;\n    Object.assign(options, {\n      created(this: Vue) {\n        originalCreated?.apply(this);\n        const componentCreateSubscription = createSubscription.bind(this);\n        const subscriptionMetadata: SubscriptionMetadata<Event> = {\n          event: [],\n          callback: (this as any)[key], // `this` isn't correctly typed here\n          metadataFilteringOptions\n        };\n\n        let subscription: Subscription;\n        if (typeof xEvent === 'function') {\n          this.$watch(\n            () => xEvent(this),\n            newEvents => {\n              subscription?.unsubscribe();\n              subscriptionMetadata.event = newEvents;\n              subscription = componentCreateSubscription(subscriptionMetadata);\n            },\n            { immediate: true }\n          );\n        } else {\n          subscriptionMetadata.event = xEvent;\n          subscription = componentCreateSubscription(subscriptionMetadata);\n        }\n\n        this.$on('hook:beforeDestroy', () => subscription.unsubscribe()); // Using Vue\n        // bus to subscribe to the lifecycle hook 'beforeDestroy' instead of 'capturing' the\n        // original component's 'beforeDestroy' method to override it plus calling\n        // originalBeforeDestroy.apply(this) to preserve the existing original hook functionality\n      }\n    });\n  });\n}\n\n/**\n * Create a subscription for the given events executing the passed callback and filtering out based\n * on the passed metadata options.\n *\n * @param this - The vue component.\n * @param subscriptionMetadata - The {@link SubscriptionMetadata}.\n * @returns A\n * {@link https://www.learnrxjs.io/learn-rxjs/concepts/rxjs-primer#subscription | subscription}.\n * @internal\n */\nfunction createSubscription<Event extends XEvent>(\n  this: Vue,\n  subscriptionMetadata: SubscriptionMetadata<Event>\n): Subscription {\n  const { event, callback, metadataFilteringOptions } = subscriptionMetadata;\n  const eventArray = Array.isArray(event) ? event : [event];\n  const subscription = new Subscription();\n  eventArray.forEach(xEvent => {\n    subscription.add(\n      (\n        this.$x.on(xEvent, true) as unknown as Observable<\n          SubjectPayload<EventPayload<XEventsTypes, Event>, WireMetadata>\n        >\n      )\n        .pipe(filter(({ metadata }) => filterMetadataOptions(metadataFilteringOptions, metadata)))\n        .subscribe(({ eventPayload, metadata }) => callback(eventPayload, metadata))\n    );\n  });\n  return subscription;\n}\n\n/**\n * Checks if the metadata options passed to the decorator match the metadata of the emitted event.\n *\n * @param filteringOptions - The decorator options.\n * @param eventOptions - The emitted event metadata.\n * @returns True if options are empty or match the metadata.\n * @internal\n */\nfunction filterMetadataOptions<WireMetadataKey extends keyof WireMetadata>(\n  filteringOptions: Partial<WireMetadata>,\n  eventOptions: WireMetadata\n): boolean {\n  return (Object.keys(filteringOptions) as WireMetadataKey[])\n    .filter(key => filteringOptions[key] !== undefined)\n    .every(key => filteringOptions[key] === eventOptions[key]);\n}\n\n/**\n * The subscription metadata containing an/a list of {@link XEvent}, the callback function to\n * execute and the metadataOptions to filter out the execution of the callback.\n *\n * @internal\n */\ninterface SubscriptionMetadata<Event extends XEvent> {\n  /**\n   * An {@link XEvent} or a list of them.\n   */\n  event: Event | Event[];\n  /**\n   * A callback function to execute in the subscription.\n   */\n  callback: AnyFunction;\n  /**\n   * The metadataFilteringOptions to filter out the execution of the callback.\n   */\n  metadataFilteringOptions: Partial<WireMetadata>;\n}\n\n/**\n * Emits the provided event whenever the decorated property changes.\n *\n * @param xEvent - The event to emit.\n * @param watcherOptions - Options for Vue's watcher.\n * @returns Decorator that makes the component emit an event when the decorated property changes.\n * @public\n */\nexport function XEmit<Event extends XEvent>(\n  xEvent: Event,\n  { immediate = true, deep = false }: WatchOptions = {}\n): DecoratorFor<XEventPayload<Event> | undefined> {\n  return createDecorator((options, key) => {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const originalCreated = options.created;\n    options.created = function (this: Vue) {\n      originalCreated?.apply(this);\n      if ((this as any)[key] !== undefined) {\n        this.$watch(\n          key,\n          newValue => {\n            this.$x.emit(\n              xEvent,\n              typeof newValue === 'object' && newValue !== null ? clone(newValue) : newValue\n            );\n          },\n          { immediate, deep }\n        );\n      }\n    };\n  });\n}\n","/**\n * Deeply clones an object or an array.\n *\n * @param something - The object to clone.\n * @returns A deep clone of the provided value.\n *\n * @public\n */\nexport function clone<Something>(something: Something): Something {\n  return JSON.parse(JSON.stringify(something));\n}\n","import { ExtractGetters, XModuleName } from '../x-modules/x-modules.types';\nimport { XPluginOptions } from './x-plugin.types';\n\n/**\n * Asserts that the passed options object is valid, providing helpful error messages.\n *\n * @param options - The options to check if they are valid.\n * @public\n */\nexport function assertXPluginOptionsAreValid(\n  options: XPluginOptions | undefined\n): asserts options is XPluginOptions {\n  if (!options) {\n    throw new Error(\n      // eslint-disable-next-line max-len\n      'XPlugin needs to be installed with an options object containing at least an adapter. Please provide a valid object'\n    );\n  }\n\n  if (options.adapter == null) {\n    throw new Error(\n      // eslint-disable-next-line max-len\n      \"The options object doesn't seem to have an adapter. Please, create one and pass it through the options object\"\n    );\n  }\n}\n\n/**\n * Generates a getter path string with the module and getter name.\n *\n * @param moduleName - The module name the getter belongs to.\n * @param getterName - The getter name.\n * @returns A string representing the getter path.\n * @public\n */\nexport function getGetterPath<ModuleName extends XModuleName>(\n  moduleName: ModuleName,\n  getterName: keyof ExtractGetters<ModuleName>\n): string {\n  return `x/${moduleName}/${getterName as string}`;\n}\n","import Vue, { ComponentOptions } from 'vue';\nimport { createDecorator } from 'vue-class-component';\nimport { getGetterPath } from '../../plugins/x-plugin.utils';\nimport { DecoratorFor } from '../../utils/index';\nimport { ExtractGetters, ExtractState, XModuleName } from '../../x-modules/x-modules.types';\n\n/**\n * Generates a computed property which returns the selected state.\n *\n * The decorated property needs to be public for type inference to work.\n *\n * @param module - The {@link XModuleName} of the getter.\n * @param path - The state path.\n * @returns Decorator with the state properties of the module.\n * @public\n */\nexport function State<Module extends XModuleName, Path extends keyof ExtractState<Module>>(\n  module: Module,\n  path: Path\n): DecoratorFor<ExtractState<Module>[Path]> {\n  return createDecorator((options, key) => {\n    if (!options.computed) {\n      options.computed = {};\n    }\n    Object.assign(options.computed, {\n      [key]() {\n        return this.$store.state.x[module][path];\n      }\n    } as ThisType<Vue>);\n  });\n}\n\n/**\n * Generates a computed property which returns the selected getter value.\n *\n * The decorated property needs to be public for type inference to work.\n *\n * @param module - The {@link XModuleName} of the getter.\n * @param getter - The getter name.\n * @returns Decorator with the getters of the module.\n * @public\n */\nexport function Getter<Module extends XModuleName, GetterName extends keyof ExtractGetters<Module>>(\n  module: Module,\n  getter: GetterName\n): DecoratorFor<ExtractGetters<Module>[GetterName]> {\n  return createDecorator((options: ComponentOptions<Vue>, key: string) => {\n    if (!options.computed) {\n      options.computed = {};\n    }\n    const getterPath = getGetterPath(module, getter);\n    Object.assign(options.computed, {\n      [key]() {\n        return this.$store.getters[getterPath];\n      }\n    } as ThisType<Vue>);\n  });\n}\n","import { ExtractType, ExtractPath } from './types';\n\n/**\n * Safely searches for a chain of properties in an object.\n *\n * @param obj - The object to safe search in for the chain of properties.\n * @param propertyChain - The chain of properties, separated by a dot, to search for.\n * @param defaultReturn - The value to return if any of the intermediate or the final value is not\n * defined.\n * @remarks The `defaultReturn` parameter has been left here for retro-compatibility. We recommend\n * to use coalescing operator (`??`) instead.\n *\n * @returns The value of the chain of properties, or `undefined` if any of the intermediate values\n * is not defined.\n */\nexport function getSafePropertyChain<SomeObject, Path extends ExtractPath<SomeObject>>(\n  obj: SomeObject,\n  propertyChain: Path,\n  defaultReturn?: ExtractType<SomeObject, Path>\n): ExtractType<SomeObject, Path> | undefined;\n/**\n * Safely searches for a chain of properties in an object.\n *\n * @param obj - The object to safe search in for the chain of properties.\n * @param propertyChain - The chain of properties, separated by a dot, to search for.\n * @param defaultReturn - The value to return if any of the intermediate or the final value is not\n * defined.\n * @remarks The `defaultReturn` parameter has been left here for retro-compatibility. We recommend\n * to use coalescing operator (`??`) instead.\n *\n * @returns The value of the chain of properties, or the default return if any of the intermediate\n * values is not defined.\n */\nexport function getSafePropertyChain<SomeObject>(\n  obj: SomeObject,\n  propertyChain: '',\n  defaultReturn?: SomeObject\n): SomeObject;\n/**\n * Safely searches for a chain of properties in an object.\n *\n * @param obj - The object to safe search in for the chain of properties.\n * @param propertyChain - The chain of properties, separated by a dot, to search for.\n * @param defaultReturn - The value to return if any of the intermediate or the final value is not\n * defined.\n *\n * @returns The value of the chain of properties, or the default return if any of the intermediate\n * values is not defined.\n */\nexport function getSafePropertyChain<SomeObject, Path extends ExtractPath<SomeObject>>(\n  obj: SomeObject,\n  propertyChain: Path | '',\n  defaultReturn?: ExtractType<SomeObject, Path>\n): ExtractType<SomeObject, Path> {\n  const resolved = getChain(obj, ...propertyChain.split('.'));\n  return resolved === undefined ? defaultReturn : resolved;\n}\n\n/**\n * Searches for the value of a list of property names inside the object.\n *\n * @param obj - The object to search in.\n * @param property - The current property to search for.\n * @param propertyChain - The remaining properties to search for.\n * @returns The value to search for, or `undefined` if any of the intermediate values is not\n * defined.\n */\nfunction getChain<T = any>(obj: any, property = '', ...propertyChain: string[]): T | undefined {\n  return obj == null && property\n    ? undefined\n    : !property\n    ? obj\n    : getChain(obj[property], ...propertyChain);\n}\n","import { AnyFunction } from './types/utils.types';\nimport { ExtractPath } from './types/paths.types';\nimport { getSafePropertyChain } from './get-safe-property-chain';\n\n/**\n * Determines whether the passed value is an Array.\n *\n * @remarks It can be used to narrow the Array's type passing the desired type to the generic.\n *\n * @param value - The value to be checked.\n *\n * @returns True if the value is an Array; otherwise, false.\n *\n * @public\n */\nexport function isArray<Type>(value: Type | Type[]): value is Type[] {\n  return Array.isArray(value);\n}\n\n/**\n * Determines whether the passed value is a Function.\n *\n * @param value - The value to be checked.\n *\n * @returns True if the value is a Function; otherwise, false.\n *\n * @public\n */\nexport function isFunction(value: any): value is AnyFunction {\n  return Boolean(value) && typeof value === 'function';\n}\n\n/**\n * Determines whether the passed value is an Object.\n *\n * @param value - The value to be checked.\n *\n * @returns True if the value is an Object; otherwise, false.\n *\n * @public\n */\nexport function isObject(value: any): value is Record<string, unknown> {\n  return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\n\n/**\n * Determines whether the passed path is a valid property path of the passed object.\n *\n * @param obj - The object to check the path against.\n * @param path - The path to be checked.\n *\n * @returns `true` if `path` is a valid path of `obj`; otherwise, `false`.\n *\n * @public\n */\nexport function isPath<SomeObject, Path extends ExtractPath<SomeObject>>(\n  obj: SomeObject,\n  path: string\n): path is Path {\n  return getSafePropertyChain(obj, path as Path) !== undefined;\n}\n","import { isArray, isObject } from './typeguards';\nimport { Dictionary } from './types';\n\n/**\n * Iterates over every non-undefined property of the object calling the callback passed as\n * parameter.\n *\n * @param obj - The object to iterate through each property.\n * @param callbackFn - The callback function to call for each property.\n * @public\n */\nexport function forEach<T extends Dictionary>(\n  obj: T | undefined | null,\n  callbackFn: (key: keyof T, value: Exclude<T[keyof T], undefined>, index: number) => void\n): void {\n  if (obj == null) {\n    return;\n  }\n\n  let index = 0;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key) && obj[key] !== undefined) {\n      callbackFn(key, obj[key], index++);\n    }\n  }\n}\n\n/**\n * Iterates through the obj properties calling the reducer function.\n *\n * @param obj - The object to iterate through each property.\n * @param reducer - A function that will be called for each property, modifying the initialValue\n * object.\n * @param initialValue - The initial value of the accumulator property of the reducer function.\n * @returns Result of the reducer function.\n * @public\n */\nexport function reduce<T extends Dictionary, V>(\n  obj: T | undefined | null,\n  reducer: (\n    accumulator: V,\n    key: keyof T,\n    value: Exclude<T[keyof T], undefined>,\n    index: number\n  ) => V,\n  initialValue: V\n): V {\n  let accumulator = initialValue;\n  forEach(obj, (key, value, index) => {\n    accumulator = reducer(accumulator, key, value, index);\n  });\n  return accumulator;\n}\n\n/**\n * Creates an object from another object transforming each property value.\n *\n * @param obj - The object to transform each property value.\n * @param mapper - The mapper function which will transform each value.\n * @returns A record with the result of the mapper.\n * @public\n */\nexport function map<T extends Dictionary, W>(\n  obj: T | undefined | null,\n  mapper: (key: keyof T, value: Exclude<T[keyof T], undefined>, index: number) => W\n): Record<keyof T, W> {\n  return reduce(\n    obj,\n    (accumulator, key, value, index) => {\n      accumulator[key] = mapper(key, value, index);\n      return accumulator;\n    },\n    {} as Record<keyof T, W>\n  );\n}\n\n/**\n * Creates an object picking only the not undefined properties.\n *\n * @param obj - The object from whom pick the values.\n * @returns A new object with the not undefined properties of the source object.\n * @public\n */\nexport function cleanUndefined<T>(obj: T): T {\n  return typeof obj !== 'object' || obj === null || Array.isArray(obj)\n    ? obj\n    : reduce(\n        obj,\n        (pickedObject, key, value) => {\n          pickedObject[key] = cleanUndefined(value);\n          return pickedObject;\n        },\n        {} as T\n      );\n}\n\n/**\n * Creates an object picking only the properties whose values are not:\n * - `undefined`.\n * - `null`.\n * - an empty string.\n * - an empty array.\n * - an empty object.\n *\n * @param obj - The object from whom pick the values.\n * @returns A new object with the not empty properties of the source object.\n * @public\n */\nexport function cleanEmpty<SomeObject extends Record<string, unknown>>(\n  obj: SomeObject\n): SomeObject {\n  return reduce(\n    obj,\n    (pickedObject, key, value) => {\n      // FIXME: Clean nested empty arrays too\n      if (isObject(value)) {\n        pickedObject[key] = cleanEmpty(value);\n        if (Object.keys(pickedObject[key] as typeof value).length === 0) {\n          delete pickedObject[key];\n        }\n      } else if (value !== null && value !== '' && !(isArray(value) && value.length === 0)) {\n        pickedObject[key] = value;\n      }\n      return pickedObject;\n    },\n    {} as SomeObject\n  );\n}\n\n/**\n * Creates an object picking only the ones that pass the test implemented by the\n * provided function isIncluded.\n *\n * @param obj - T object to be filtered.\n * @param isIncluded - Test function that every obj item must pass.\n * @returns A filtered object.\n * @public\n */\nexport function objectFilter<T extends Dictionary>(\n  obj: T | undefined | null,\n  isIncluded: (key: keyof T, value: Exclude<T[keyof T], undefined>, index: number) => boolean\n): T {\n  return reduce(\n    obj,\n    (accumulator, key, value, index) => {\n      if (isIncluded(key, value, index)) {\n        accumulator[key] = value;\n      }\n      return accumulator;\n    },\n    {} as T\n  );\n}\n\n/**\n * Compares two objects of the same type, checking the values of their keys and retrieving\n * those that were not present in the old value and/or those whose value has changed.\n *\n * @param newValue - The new object value.\n * @param oldValue - The old object value.\n *\n * @returns An array of keys.\n * @public\n */\nexport function getNewAndUpdatedKeys<ObjectType extends Dictionary>(\n  newValue: ObjectType | undefined,\n  oldValue: ObjectType | undefined\n): (keyof ObjectType)[] {\n  if (newValue === oldValue || !newValue || !oldValue) {\n    return [];\n  }\n\n  return Object.keys(newValue).filter(key => !(key in oldValue) || newValue[key] !== oldValue[key]);\n}\n\n/**\n * Ensures that the given condition is met in all the non-undefined entries of the object.\n *\n * @param object - The object to check if every item meets the given condition.\n * @param condition - The condition to check in each one of the entries of the object.\n *\n * @returns True when all the entries pass the condition. False otherwise.\n * @public\n */\nexport function every<ObjectType extends Dictionary>(\n  object: ObjectType,\n  condition: (\n    key: keyof ObjectType,\n    value: Exclude<ObjectType[keyof ObjectType], undefined>,\n    index: number\n  ) => boolean\n): boolean {\n  return Object.entries(object)\n    .filter(([, value]) => value !== undefined)\n    .every(([key, value], index) => condition(key, value, index));\n}\n\n/**\n * Flattens recursively the passed object to a one level object.\n *\n * @param object - The object to flatten.\n * @returns The flattened object.\n * @public\n */\nexport function flatObject(object: Dictionary): Dictionary {\n  const flattenedObject: Dictionary = {};\n  forEach(object, (key, value) => {\n    if (isObject(value)) {\n      Object.assign(flattenedObject, flatObject(value));\n    } else {\n      flattenedObject[key] = value;\n    }\n  });\n  return flattenedObject;\n}\n\n/**\n * Renames the keys of an object adding a prefix, a suffix, or both.\n *\n * @param object - The object to rename its keys.\n * @param pattern - The options to rename with: a prefix and a suffix.\n * @returns A new object with the keys renamed following the pattern.\n * @public\n */\nexport function rename<\n  SomeObject extends Dictionary,\n  Prefix extends string = '',\n  Suffix extends string = ''\n>(\n  object: SomeObject,\n  { prefix, suffix }: RenameOptions<Prefix, Suffix>\n): Rename<SomeObject, Prefix, Suffix> {\n  return reduce(\n    object,\n    (renamed, key, value) => {\n      renamed[\n        `${prefix ?? ''}${key as string}${suffix ?? ''}` as keyof Rename<SomeObject, Prefix, Suffix>\n      ] = value;\n      return renamed;\n    },\n    {} as Rename<SomeObject, Prefix, Suffix>\n  );\n}\n\n/**\n * Renames the keys of the given object prefixing and suffixing them.\n *\n * @public\n */\nexport type Rename<SomeObject, Prefix extends string, Suffix extends string> = {\n  [Key in keyof SomeObject as `${Prefix}${Key & string}${Suffix}`]: SomeObject[Key];\n};\n\n/**\n * An optional prefix and suffix.\n *\n * @public\n */\ninterface RenameOptions<Prefix, Suffix> {\n  prefix?: Prefix;\n  suffix?: Suffix;\n}\n","import { nanoid } from 'nanoid';\nimport {\n  BrowserStorageService,\n  InMemoryStorageService,\n  StorageService\n} from '@empathyco/x-storage-service';\nimport { SessionService } from './service.types';\n\n/**\n * Default implementation for the {@link SessionService}.\n *\n * @public\n */\nexport class DefaultSessionService implements SessionService {\n  /**\n   * Session id key to use as key in the storage.\n   *\n   * @public\n   */\n  public static readonly SESSION_ID_KEY = 'session-id';\n\n  /**\n   * Global instance of the {@link SessionService}.\n   */\n  public static instance: SessionService = new DefaultSessionService();\n\n  public constructor(\n    protected storageService: StorageService = typeof localStorage !== 'undefined'\n      ? new BrowserStorageService(localStorage, 'x')\n      : new InMemoryStorageService(),\n    protected ttlMs = 1800000 // 30m * 60s * 1000 = 1800_000ms\n  ) {}\n\n  /**\n   * Returns the session id of the storage.\n   *\n   * @returns The current session id.\n   *\n   * @public\n   */\n  getSessionId(): string {\n    const sessionId = this.storageService.getItem(DefaultSessionService.SESSION_ID_KEY) ?? nanoid();\n    this.storageService.setItem(DefaultSessionService.SESSION_ID_KEY, sessionId, this.ttlMs);\n    return sessionId;\n  }\n\n  /**\n   * Removes the session if from the storage.\n   *\n   * @public\n   */\n  clearSessionId(): void {\n    this.storageService.removeItem(DefaultSessionService.SESSION_ID_KEY);\n  }\n}\n","import { urlAlphabet } from './url-alphabet/index.js'\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nlet nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","import { isObject } from '@empathyco/x-utils';\n\nenum Behaviour {\n  Replace = 'replace',\n  DeepMerge = 'deep-merge'\n}\n\n/**\n * Clones deeply all of the sources objects values into the target, except the arrays,\n * which only generates a new one, but keeping the references of the sources one.\n *\n * TODO Make it work with circular references.\n *\n * @param target - The object which will be used as the base to clone all the sources into.\n * @param sources - One or more objects to clone to the target.\n *\n * @returns The target modified.\n */\nexport function deepMerge(target: any, ...sources: any[]): any {\n  return sources.reduce(cloneSourcesProperties, target || {});\n}\n\nconst behaviourMap = new WeakMap();\n\n/**\n * When setting replace behaviour to an object, target properties will not be used,\n * only the source ones.\n *\n * @param obj - The object to set its merge behavior.\n * @example\n * ```ts\n * const target = { children: { a: 1, b: 2, c: 3 } };\n * const firstSource = { children: replaceBehaviour({ c: 4, d: 5 }) };\n * deepMerge(target, firstSource);\n * // `target` is now { children: { c: 4, d: 5 } }\n * ```\n *\n * @returns The same object with the new behaviour.\n */\nexport function replaceBehaviour<T extends Record<string, unknown>>(obj: T): T {\n  behaviourMap.set(obj, Behaviour.Replace);\n  return obj;\n}\n\n/**\n * When setting deep merge behaviour, target and source properties will be used. This is the default\n * behavior.\n *\n * @param obj - The object to set its merge behavior.\n *\n * @returns The same object with the new behaviour.\n */\nexport function deepMergeBehaviour<T extends Record<string, unknown>>(obj: T): T {\n  behaviourMap.set(obj, Behaviour.DeepMerge);\n  return obj;\n}\n\n/**\n * A function which clones the properties of two sources.\n *\n * @param target - The target object to clone in.\n * @param source - The source objet to clone.\n *\n * @returns The union of the target and source.\n */\nfunction cloneSourcesProperties(target: any, source: any): (source: any) => void {\n  if (source) {\n    return Object.entries(source).reduce(cloneObjectProperties, target);\n  } else {\n    return target || {};\n  }\n}\n\n/**\n * A function which clones the properties of two object.\n *\n * @param target - The target object to clone in.\n * @param source - Key-Value to clone into the target object.\n *\n * @returns The target object updated with the entry parameter.\n */\nfunction cloneObjectProperties(target: any, [key, value]: any): any {\n  if (value === undefined) {\n    delete target[key];\n  } else if (isObject(value)) {\n    mergeObject(target, [key, value]);\n  } else if (Array.isArray(value)) {\n    target[key] = [...value];\n  } else {\n    target[key] = value;\n  }\n  return target;\n}\n\n/**\n * A function which merges two sources.\n *\n * @param target - The target object to clone in.\n * @param source - Key-Value to clone into the target object.\n *\n */\nfunction mergeObject(target: any, [key, value]: any): void {\n  const mergeBehaviour = getMergeBehaviour(target[key], value);\n  if (mergeBehaviour === Behaviour.Replace) {\n    target[key] = deepMerge({}, value);\n    replaceBehaviour(target[key]);\n  } else if (mergeBehaviour === Behaviour.DeepMerge) {\n    target[key] = deepMerge(target[key] || {}, value);\n    deepMergeBehaviour(target[key]);\n  } else {\n    target[key] = deepMerge(isObject(target[key]) ? target[key] : {}, value);\n  }\n}\n\n/**\n * A function which detects the merge behaviour.\n *\n * @param targetValue - The target object.\n * @param sourceValue - The source objet.\n *\n * @returns The correct behaviour.\n */\nfunction getMergeBehaviour(targetValue: any, sourceValue: any): Behaviour {\n  return behaviourMap.get(sourceValue) || behaviourMap.get(targetValue);\n}\n","/*!\n * vuex v3.6.2\n * (c) 2021 Evan You\n * @license MIT\n */\nfunction applyMixin (Vue) {\n  var version = Number(Vue.version.split('.')[0]);\n\n  if (version >= 2) {\n    Vue.mixin({ beforeCreate: vuexInit });\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    var _init = Vue.prototype._init;\n    Vue.prototype._init = function (options) {\n      if ( options === void 0 ) options = {};\n\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit;\n      _init.call(this, options);\n    };\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit () {\n    var options = this.$options;\n    // store injection\n    if (options.store) {\n      this.$store = typeof options.store === 'function'\n        ? options.store()\n        : options.store;\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store;\n    }\n  }\n}\n\nvar target = typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n    ? global\n    : {};\nvar devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\nfunction devtoolPlugin (store) {\n  if (!devtoolHook) { return }\n\n  store._devtoolHook = devtoolHook;\n\n  devtoolHook.emit('vuex:init', store);\n\n  devtoolHook.on('vuex:travel-to-state', function (targetState) {\n    store.replaceState(targetState);\n  });\n\n  store.subscribe(function (mutation, state) {\n    devtoolHook.emit('vuex:mutation', mutation, state);\n  }, { prepend: true });\n\n  store.subscribeAction(function (action, state) {\n    devtoolHook.emit('vuex:action', action, state);\n  }, { prepend: true });\n}\n\n/**\n * Get the first item that pass the test\n * by second argument function\n *\n * @param {Array} list\n * @param {Function} f\n * @return {*}\n */\nfunction find (list, f) {\n  return list.filter(f)[0]\n}\n\n/**\n * Deep copy the given object considering circular structure.\n * This function caches all nested objects and its copies.\n * If it detects circular structure, use cached copy to avoid infinite loop.\n *\n * @param {*} obj\n * @param {Array<Object>} cache\n * @return {*}\n */\nfunction deepCopy (obj, cache) {\n  if ( cache === void 0 ) cache = [];\n\n  // just return if obj is immutable value\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  // if obj is hit, it is in circular structure\n  var hit = find(cache, function (c) { return c.original === obj; });\n  if (hit) {\n    return hit.copy\n  }\n\n  var copy = Array.isArray(obj) ? [] : {};\n  // put the copy into cache at first\n  // because we want to refer it in recursive deepCopy\n  cache.push({\n    original: obj,\n    copy: copy\n  });\n\n  Object.keys(obj).forEach(function (key) {\n    copy[key] = deepCopy(obj[key], cache);\n  });\n\n  return copy\n}\n\n/**\n * forEach for object\n */\nfunction forEachValue (obj, fn) {\n  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });\n}\n\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nfunction isPromise (val) {\n  return val && typeof val.then === 'function'\n}\n\nfunction assert (condition, msg) {\n  if (!condition) { throw new Error((\"[vuex] \" + msg)) }\n}\n\nfunction partial (fn, arg) {\n  return function () {\n    return fn(arg)\n  }\n}\n\n// Base data struct for store's module, package with some attribute and method\nvar Module = function Module (rawModule, runtime) {\n  this.runtime = runtime;\n  // Store some children item\n  this._children = Object.create(null);\n  // Store the origin module object which passed by programmer\n  this._rawModule = rawModule;\n  var rawState = rawModule.state;\n\n  // Store the origin module's state\n  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};\n};\n\nvar prototypeAccessors = { namespaced: { configurable: true } };\n\nprototypeAccessors.namespaced.get = function () {\n  return !!this._rawModule.namespaced\n};\n\nModule.prototype.addChild = function addChild (key, module) {\n  this._children[key] = module;\n};\n\nModule.prototype.removeChild = function removeChild (key) {\n  delete this._children[key];\n};\n\nModule.prototype.getChild = function getChild (key) {\n  return this._children[key]\n};\n\nModule.prototype.hasChild = function hasChild (key) {\n  return key in this._children\n};\n\nModule.prototype.update = function update (rawModule) {\n  this._rawModule.namespaced = rawModule.namespaced;\n  if (rawModule.actions) {\n    this._rawModule.actions = rawModule.actions;\n  }\n  if (rawModule.mutations) {\n    this._rawModule.mutations = rawModule.mutations;\n  }\n  if (rawModule.getters) {\n    this._rawModule.getters = rawModule.getters;\n  }\n};\n\nModule.prototype.forEachChild = function forEachChild (fn) {\n  forEachValue(this._children, fn);\n};\n\nModule.prototype.forEachGetter = function forEachGetter (fn) {\n  if (this._rawModule.getters) {\n    forEachValue(this._rawModule.getters, fn);\n  }\n};\n\nModule.prototype.forEachAction = function forEachAction (fn) {\n  if (this._rawModule.actions) {\n    forEachValue(this._rawModule.actions, fn);\n  }\n};\n\nModule.prototype.forEachMutation = function forEachMutation (fn) {\n  if (this._rawModule.mutations) {\n    forEachValue(this._rawModule.mutations, fn);\n  }\n};\n\nObject.defineProperties( Module.prototype, prototypeAccessors );\n\nvar ModuleCollection = function ModuleCollection (rawRootModule) {\n  // register root module (Vuex.Store options)\n  this.register([], rawRootModule, false);\n};\n\nModuleCollection.prototype.get = function get (path) {\n  return path.reduce(function (module, key) {\n    return module.getChild(key)\n  }, this.root)\n};\n\nModuleCollection.prototype.getNamespace = function getNamespace (path) {\n  var module = this.root;\n  return path.reduce(function (namespace, key) {\n    module = module.getChild(key);\n    return namespace + (module.namespaced ? key + '/' : '')\n  }, '')\n};\n\nModuleCollection.prototype.update = function update$1 (rawRootModule) {\n  update([], this.root, rawRootModule);\n};\n\nModuleCollection.prototype.register = function register (path, rawModule, runtime) {\n    var this$1 = this;\n    if ( runtime === void 0 ) runtime = true;\n\n  if ((process.env.NODE_ENV !== 'production')) {\n    assertRawModule(path, rawModule);\n  }\n\n  var newModule = new Module(rawModule, runtime);\n  if (path.length === 0) {\n    this.root = newModule;\n  } else {\n    var parent = this.get(path.slice(0, -1));\n    parent.addChild(path[path.length - 1], newModule);\n  }\n\n  // register nested modules\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, function (rawChildModule, key) {\n      this$1.register(path.concat(key), rawChildModule, runtime);\n    });\n  }\n};\n\nModuleCollection.prototype.unregister = function unregister (path) {\n  var parent = this.get(path.slice(0, -1));\n  var key = path[path.length - 1];\n  var child = parent.getChild(key);\n\n  if (!child) {\n    if ((process.env.NODE_ENV !== 'production')) {\n      console.warn(\n        \"[vuex] trying to unregister module '\" + key + \"', which is \" +\n        \"not registered\"\n      );\n    }\n    return\n  }\n\n  if (!child.runtime) {\n    return\n  }\n\n  parent.removeChild(key);\n};\n\nModuleCollection.prototype.isRegistered = function isRegistered (path) {\n  var parent = this.get(path.slice(0, -1));\n  var key = path[path.length - 1];\n\n  if (parent) {\n    return parent.hasChild(key)\n  }\n\n  return false\n};\n\nfunction update (path, targetModule, newModule) {\n  if ((process.env.NODE_ENV !== 'production')) {\n    assertRawModule(path, newModule);\n  }\n\n  // update target module\n  targetModule.update(newModule);\n\n  // update nested modules\n  if (newModule.modules) {\n    for (var key in newModule.modules) {\n      if (!targetModule.getChild(key)) {\n        if ((process.env.NODE_ENV !== 'production')) {\n          console.warn(\n            \"[vuex] trying to add a new module '\" + key + \"' on hot reloading, \" +\n            'manual reload is needed'\n          );\n        }\n        return\n      }\n      update(\n        path.concat(key),\n        targetModule.getChild(key),\n        newModule.modules[key]\n      );\n    }\n  }\n}\n\nvar functionAssert = {\n  assert: function (value) { return typeof value === 'function'; },\n  expected: 'function'\n};\n\nvar objectAssert = {\n  assert: function (value) { return typeof value === 'function' ||\n    (typeof value === 'object' && typeof value.handler === 'function'); },\n  expected: 'function or object with \"handler\" function'\n};\n\nvar assertTypes = {\n  getters: functionAssert,\n  mutations: functionAssert,\n  actions: objectAssert\n};\n\nfunction assertRawModule (path, rawModule) {\n  Object.keys(assertTypes).forEach(function (key) {\n    if (!rawModule[key]) { return }\n\n    var assertOptions = assertTypes[key];\n\n    forEachValue(rawModule[key], function (value, type) {\n      assert(\n        assertOptions.assert(value),\n        makeAssertionMessage(path, key, type, value, assertOptions.expected)\n      );\n    });\n  });\n}\n\nfunction makeAssertionMessage (path, key, type, value, expected) {\n  var buf = key + \" should be \" + expected + \" but \\\"\" + key + \".\" + type + \"\\\"\";\n  if (path.length > 0) {\n    buf += \" in module \\\"\" + (path.join('.')) + \"\\\"\";\n  }\n  buf += \" is \" + (JSON.stringify(value)) + \".\";\n  return buf\n}\n\nvar Vue; // bind on install\n\nvar Store = function Store (options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  // Auto install if it is not done yet and `window` has `Vue`.\n  // To allow users to avoid auto-installation in some cases,\n  // this code should be placed here. See #731\n  if (!Vue && typeof window !== 'undefined' && window.Vue) {\n    install(window.Vue);\n  }\n\n  if ((process.env.NODE_ENV !== 'production')) {\n    assert(Vue, \"must call Vue.use(Vuex) before creating a store instance.\");\n    assert(typeof Promise !== 'undefined', \"vuex requires a Promise polyfill in this browser.\");\n    assert(this instanceof Store, \"store must be called with the new operator.\");\n  }\n\n  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];\n  var strict = options.strict; if ( strict === void 0 ) strict = false;\n\n  // store internal state\n  this._committing = false;\n  this._actions = Object.create(null);\n  this._actionSubscribers = [];\n  this._mutations = Object.create(null);\n  this._wrappedGetters = Object.create(null);\n  this._modules = new ModuleCollection(options);\n  this._modulesNamespaceMap = Object.create(null);\n  this._subscribers = [];\n  this._watcherVM = new Vue();\n  this._makeLocalGettersCache = Object.create(null);\n\n  // bind commit and dispatch to self\n  var store = this;\n  var ref = this;\n  var dispatch = ref.dispatch;\n  var commit = ref.commit;\n  this.dispatch = function boundDispatch (type, payload) {\n    return dispatch.call(store, type, payload)\n  };\n  this.commit = function boundCommit (type, payload, options) {\n    return commit.call(store, type, payload, options)\n  };\n\n  // strict mode\n  this.strict = strict;\n\n  var state = this._modules.root.state;\n\n  // init root module.\n  // this also recursively registers all sub-modules\n  // and collects all module getters inside this._wrappedGetters\n  installModule(this, state, [], this._modules.root);\n\n  // initialize the store vm, which is responsible for the reactivity\n  // (also registers _wrappedGetters as computed properties)\n  resetStoreVM(this, state);\n\n  // apply plugins\n  plugins.forEach(function (plugin) { return plugin(this$1); });\n\n  var useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools;\n  if (useDevtools) {\n    devtoolPlugin(this);\n  }\n};\n\nvar prototypeAccessors$1 = { state: { configurable: true } };\n\nprototypeAccessors$1.state.get = function () {\n  return this._vm._data.$$state\n};\n\nprototypeAccessors$1.state.set = function (v) {\n  if ((process.env.NODE_ENV !== 'production')) {\n    assert(false, \"use store.replaceState() to explicit replace store state.\");\n  }\n};\n\nStore.prototype.commit = function commit (_type, _payload, _options) {\n    var this$1 = this;\n\n  // check object-style commit\n  var ref = unifyObjectStyle(_type, _payload, _options);\n    var type = ref.type;\n    var payload = ref.payload;\n    var options = ref.options;\n\n  var mutation = { type: type, payload: payload };\n  var entry = this._mutations[type];\n  if (!entry) {\n    if ((process.env.NODE_ENV !== 'production')) {\n      console.error((\"[vuex] unknown mutation type: \" + type));\n    }\n    return\n  }\n  this._withCommit(function () {\n    entry.forEach(function commitIterator (handler) {\n      handler(payload);\n    });\n  });\n\n  this._subscribers\n    .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe\n    .forEach(function (sub) { return sub(mutation, this$1.state); });\n\n  if (\n    (process.env.NODE_ENV !== 'production') &&\n    options && options.silent\n  ) {\n    console.warn(\n      \"[vuex] mutation type: \" + type + \". Silent option has been removed. \" +\n      'Use the filter functionality in the vue-devtools'\n    );\n  }\n};\n\nStore.prototype.dispatch = function dispatch (_type, _payload) {\n    var this$1 = this;\n\n  // check object-style dispatch\n  var ref = unifyObjectStyle(_type, _payload);\n    var type = ref.type;\n    var payload = ref.payload;\n\n  var action = { type: type, payload: payload };\n  var entry = this._actions[type];\n  if (!entry) {\n    if ((process.env.NODE_ENV !== 'production')) {\n      console.error((\"[vuex] unknown action type: \" + type));\n    }\n    return\n  }\n\n  try {\n    this._actionSubscribers\n      .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe\n      .filter(function (sub) { return sub.before; })\n      .forEach(function (sub) { return sub.before(action, this$1.state); });\n  } catch (e) {\n    if ((process.env.NODE_ENV !== 'production')) {\n      console.warn(\"[vuex] error in before action subscribers: \");\n      console.error(e);\n    }\n  }\n\n  var result = entry.length > 1\n    ? Promise.all(entry.map(function (handler) { return handler(payload); }))\n    : entry[0](payload);\n\n  return new Promise(function (resolve, reject) {\n    result.then(function (res) {\n      try {\n        this$1._actionSubscribers\n          .filter(function (sub) { return sub.after; })\n          .forEach(function (sub) { return sub.after(action, this$1.state); });\n      } catch (e) {\n        if ((process.env.NODE_ENV !== 'production')) {\n          console.warn(\"[vuex] error in after action subscribers: \");\n          console.error(e);\n        }\n      }\n      resolve(res);\n    }, function (error) {\n      try {\n        this$1._actionSubscribers\n          .filter(function (sub) { return sub.error; })\n          .forEach(function (sub) { return sub.error(action, this$1.state, error); });\n      } catch (e) {\n        if ((process.env.NODE_ENV !== 'production')) {\n          console.warn(\"[vuex] error in error action subscribers: \");\n          console.error(e);\n        }\n      }\n      reject(error);\n    });\n  })\n};\n\nStore.prototype.subscribe = function subscribe (fn, options) {\n  return genericSubscribe(fn, this._subscribers, options)\n};\n\nStore.prototype.subscribeAction = function subscribeAction (fn, options) {\n  var subs = typeof fn === 'function' ? { before: fn } : fn;\n  return genericSubscribe(subs, this._actionSubscribers, options)\n};\n\nStore.prototype.watch = function watch (getter, cb, options) {\n    var this$1 = this;\n\n  if ((process.env.NODE_ENV !== 'production')) {\n    assert(typeof getter === 'function', \"store.watch only accepts a function.\");\n  }\n  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)\n};\n\nStore.prototype.replaceState = function replaceState (state) {\n    var this$1 = this;\n\n  this._withCommit(function () {\n    this$1._vm._data.$$state = state;\n  });\n};\n\nStore.prototype.registerModule = function registerModule (path, rawModule, options) {\n    if ( options === void 0 ) options = {};\n\n  if (typeof path === 'string') { path = [path]; }\n\n  if ((process.env.NODE_ENV !== 'production')) {\n    assert(Array.isArray(path), \"module path must be a string or an Array.\");\n    assert(path.length > 0, 'cannot register the root module by using registerModule.');\n  }\n\n  this._modules.register(path, rawModule);\n  installModule(this, this.state, path, this._modules.get(path), options.preserveState);\n  // reset store to update getters...\n  resetStoreVM(this, this.state);\n};\n\nStore.prototype.unregisterModule = function unregisterModule (path) {\n    var this$1 = this;\n\n  if (typeof path === 'string') { path = [path]; }\n\n  if ((process.env.NODE_ENV !== 'production')) {\n    assert(Array.isArray(path), \"module path must be a string or an Array.\");\n  }\n\n  this._modules.unregister(path);\n  this._withCommit(function () {\n    var parentState = getNestedState(this$1.state, path.slice(0, -1));\n    Vue.delete(parentState, path[path.length - 1]);\n  });\n  resetStore(this);\n};\n\nStore.prototype.hasModule = function hasModule (path) {\n  if (typeof path === 'string') { path = [path]; }\n\n  if ((process.env.NODE_ENV !== 'production')) {\n    assert(Array.isArray(path), \"module path must be a string or an Array.\");\n  }\n\n  return this._modules.isRegistered(path)\n};\n\nStore.prototype.hotUpdate = function hotUpdate (newOptions) {\n  this._modules.update(newOptions);\n  resetStore(this, true);\n};\n\nStore.prototype._withCommit = function _withCommit (fn) {\n  var committing = this._committing;\n  this._committing = true;\n  fn();\n  this._committing = committing;\n};\n\nObject.defineProperties( Store.prototype, prototypeAccessors$1 );\n\nfunction genericSubscribe (fn, subs, options) {\n  if (subs.indexOf(fn) < 0) {\n    options && options.prepend\n      ? subs.unshift(fn)\n      : subs.push(fn);\n  }\n  return function () {\n    var i = subs.indexOf(fn);\n    if (i > -1) {\n      subs.splice(i, 1);\n    }\n  }\n}\n\nfunction resetStore (store, hot) {\n  store._actions = Object.create(null);\n  store._mutations = Object.create(null);\n  store._wrappedGetters = Object.create(null);\n  store._modulesNamespaceMap = Object.create(null);\n  var state = store.state;\n  // init all modules\n  installModule(store, state, [], store._modules.root, true);\n  // reset vm\n  resetStoreVM(store, state, hot);\n}\n\nfunction resetStoreVM (store, state, hot) {\n  var oldVm = store._vm;\n\n  // bind store public getters\n  store.getters = {};\n  // reset local getters cache\n  store._makeLocalGettersCache = Object.create(null);\n  var wrappedGetters = store._wrappedGetters;\n  var computed = {};\n  forEachValue(wrappedGetters, function (fn, key) {\n    // use computed to leverage its lazy-caching mechanism\n    // direct inline function use will lead to closure preserving oldVm.\n    // using partial to return function with only arguments preserved in closure environment.\n    computed[key] = partial(fn, store);\n    Object.defineProperty(store.getters, key, {\n      get: function () { return store._vm[key]; },\n      enumerable: true // for local getters\n    });\n  });\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  var silent = Vue.config.silent;\n  Vue.config.silent = true;\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed: computed\n  });\n  Vue.config.silent = silent;\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store);\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // dispatch changes in all subscribed watchers\n      // to force getter re-evaluation for hot reloading.\n      store._withCommit(function () {\n        oldVm._data.$$state = null;\n      });\n    }\n    Vue.nextTick(function () { return oldVm.$destroy(); });\n  }\n}\n\nfunction installModule (store, rootState, path, module, hot) {\n  var isRoot = !path.length;\n  var namespace = store._modules.getNamespace(path);\n\n  // register in namespace map\n  if (module.namespaced) {\n    if (store._modulesNamespaceMap[namespace] && (process.env.NODE_ENV !== 'production')) {\n      console.error((\"[vuex] duplicate namespace \" + namespace + \" for the namespaced module \" + (path.join('/'))));\n    }\n    store._modulesNamespaceMap[namespace] = module;\n  }\n\n  // set state\n  if (!isRoot && !hot) {\n    var parentState = getNestedState(rootState, path.slice(0, -1));\n    var moduleName = path[path.length - 1];\n    store._withCommit(function () {\n      if ((process.env.NODE_ENV !== 'production')) {\n        if (moduleName in parentState) {\n          console.warn(\n            (\"[vuex] state field \\\"\" + moduleName + \"\\\" was overridden by a module with the same name at \\\"\" + (path.join('.')) + \"\\\"\")\n          );\n        }\n      }\n      Vue.set(parentState, moduleName, module.state);\n    });\n  }\n\n  var local = module.context = makeLocalContext(store, namespace, path);\n\n  module.forEachMutation(function (mutation, key) {\n    var namespacedType = namespace + key;\n    registerMutation(store, namespacedType, mutation, local);\n  });\n\n  module.forEachAction(function (action, key) {\n    var type = action.root ? key : namespace + key;\n    var handler = action.handler || action;\n    registerAction(store, type, handler, local);\n  });\n\n  module.forEachGetter(function (getter, key) {\n    var namespacedType = namespace + key;\n    registerGetter(store, namespacedType, getter, local);\n  });\n\n  module.forEachChild(function (child, key) {\n    installModule(store, rootState, path.concat(key), child, hot);\n  });\n}\n\n/**\n * make localized dispatch, commit, getters and state\n * if there is no namespace, just use root ones\n */\nfunction makeLocalContext (store, namespace, path) {\n  var noNamespace = namespace === '';\n\n  var local = {\n    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if ((process.env.NODE_ENV !== 'production') && !store._actions[type]) {\n          console.error((\"[vuex] unknown local action type: \" + (args.type) + \", global type: \" + type));\n          return\n        }\n      }\n\n      return store.dispatch(type, payload)\n    },\n\n    commit: noNamespace ? store.commit : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if ((process.env.NODE_ENV !== 'production') && !store._mutations[type]) {\n          console.error((\"[vuex] unknown local mutation type: \" + (args.type) + \", global type: \" + type));\n          return\n        }\n      }\n\n      store.commit(type, payload, options);\n    }\n  };\n\n  // getters and state object must be gotten lazily\n  // because they will be changed by vm update\n  Object.defineProperties(local, {\n    getters: {\n      get: noNamespace\n        ? function () { return store.getters; }\n        : function () { return makeLocalGetters(store, namespace); }\n    },\n    state: {\n      get: function () { return getNestedState(store.state, path); }\n    }\n  });\n\n  return local\n}\n\nfunction makeLocalGetters (store, namespace) {\n  if (!store._makeLocalGettersCache[namespace]) {\n    var gettersProxy = {};\n    var splitPos = namespace.length;\n    Object.keys(store.getters).forEach(function (type) {\n      // skip if the target getter is not match this namespace\n      if (type.slice(0, splitPos) !== namespace) { return }\n\n      // extract local getter type\n      var localType = type.slice(splitPos);\n\n      // Add a port to the getters proxy.\n      // Define as getter property because\n      // we do not want to evaluate the getters in this time.\n      Object.defineProperty(gettersProxy, localType, {\n        get: function () { return store.getters[type]; },\n        enumerable: true\n      });\n    });\n    store._makeLocalGettersCache[namespace] = gettersProxy;\n  }\n\n  return store._makeLocalGettersCache[namespace]\n}\n\nfunction registerMutation (store, type, handler, local) {\n  var entry = store._mutations[type] || (store._mutations[type] = []);\n  entry.push(function wrappedMutationHandler (payload) {\n    handler.call(store, local.state, payload);\n  });\n}\n\nfunction registerAction (store, type, handler, local) {\n  var entry = store._actions[type] || (store._actions[type] = []);\n  entry.push(function wrappedActionHandler (payload) {\n    var res = handler.call(store, {\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload);\n    if (!isPromise(res)) {\n      res = Promise.resolve(res);\n    }\n    if (store._devtoolHook) {\n      return res.catch(function (err) {\n        store._devtoolHook.emit('vuex:error', err);\n        throw err\n      })\n    } else {\n      return res\n    }\n  });\n}\n\nfunction registerGetter (store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    if ((process.env.NODE_ENV !== 'production')) {\n      console.error((\"[vuex] duplicate getter key: \" + type));\n    }\n    return\n  }\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    return rawGetter(\n      local.state, // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  };\n}\n\nfunction enableStrictMode (store) {\n  store._vm.$watch(function () { return this._data.$$state }, function () {\n    if ((process.env.NODE_ENV !== 'production')) {\n      assert(store._committing, \"do not mutate vuex store state outside mutation handlers.\");\n    }\n  }, { deep: true, sync: true });\n}\n\nfunction getNestedState (state, path) {\n  return path.reduce(function (state, key) { return state[key]; }, state)\n}\n\nfunction unifyObjectStyle (type, payload, options) {\n  if (isObject(type) && type.type) {\n    options = payload;\n    payload = type;\n    type = type.type;\n  }\n\n  if ((process.env.NODE_ENV !== 'production')) {\n    assert(typeof type === 'string', (\"expects string as the type, but found \" + (typeof type) + \".\"));\n  }\n\n  return { type: type, payload: payload, options: options }\n}\n\nfunction install (_Vue) {\n  if (Vue && _Vue === Vue) {\n    if ((process.env.NODE_ENV !== 'production')) {\n      console.error(\n        '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n      );\n    }\n    return\n  }\n  Vue = _Vue;\n  applyMixin(Vue);\n}\n\n/**\n * Reduce the code which written in Vue.js for getting the state.\n * @param {String} [namespace] - Module's namespace\n * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.\n * @param {Object}\n */\nvar mapState = normalizeNamespace(function (namespace, states) {\n  var res = {};\n  if ((process.env.NODE_ENV !== 'production') && !isValidMap(states)) {\n    console.error('[vuex] mapState: mapper parameter must be either an Array or an Object');\n  }\n  normalizeMap(states).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedState () {\n      var state = this.$store.state;\n      var getters = this.$store.getters;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapState', namespace);\n        if (!module) {\n          return\n        }\n        state = module.context.state;\n        getters = module.context.getters;\n      }\n      return typeof val === 'function'\n        ? val.call(this, state, getters)\n        : state[val]\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res\n});\n\n/**\n * Reduce the code which written in Vue.js for committing the mutation\n * @param {String} [namespace] - Module's namespace\n * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept another params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.\n * @return {Object}\n */\nvar mapMutations = normalizeNamespace(function (namespace, mutations) {\n  var res = {};\n  if ((process.env.NODE_ENV !== 'production') && !isValidMap(mutations)) {\n    console.error('[vuex] mapMutations: mapper parameter must be either an Array or an Object');\n  }\n  normalizeMap(mutations).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedMutation () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      // Get the commit method from store\n      var commit = this.$store.commit;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);\n        if (!module) {\n          return\n        }\n        commit = module.context.commit;\n      }\n      return typeof val === 'function'\n        ? val.apply(this, [commit].concat(args))\n        : commit.apply(this.$store, [val].concat(args))\n    };\n  });\n  return res\n});\n\n/**\n * Reduce the code which written in Vue.js for getting the getters\n * @param {String} [namespace] - Module's namespace\n * @param {Object|Array} getters\n * @return {Object}\n */\nvar mapGetters = normalizeNamespace(function (namespace, getters) {\n  var res = {};\n  if ((process.env.NODE_ENV !== 'production') && !isValidMap(getters)) {\n    console.error('[vuex] mapGetters: mapper parameter must be either an Array or an Object');\n  }\n  normalizeMap(getters).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    // The namespace has been mutated by normalizeNamespace\n    val = namespace + val;\n    res[key] = function mappedGetter () {\n      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {\n        return\n      }\n      if ((process.env.NODE_ENV !== 'production') && !(val in this.$store.getters)) {\n        console.error((\"[vuex] unknown getter: \" + val));\n        return\n      }\n      return this.$store.getters[val]\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res\n});\n\n/**\n * Reduce the code which written in Vue.js for dispatch the action\n * @param {String} [namespace] - Module's namespace\n * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.\n * @return {Object}\n */\nvar mapActions = normalizeNamespace(function (namespace, actions) {\n  var res = {};\n  if ((process.env.NODE_ENV !== 'production') && !isValidMap(actions)) {\n    console.error('[vuex] mapActions: mapper parameter must be either an Array or an Object');\n  }\n  normalizeMap(actions).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedAction () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      // get dispatch function from store\n      var dispatch = this.$store.dispatch;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);\n        if (!module) {\n          return\n        }\n        dispatch = module.context.dispatch;\n      }\n      return typeof val === 'function'\n        ? val.apply(this, [dispatch].concat(args))\n        : dispatch.apply(this.$store, [val].concat(args))\n    };\n  });\n  return res\n});\n\n/**\n * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object\n * @param {String} namespace\n * @return {Object}\n */\nvar createNamespacedHelpers = function (namespace) { return ({\n  mapState: mapState.bind(null, namespace),\n  mapGetters: mapGetters.bind(null, namespace),\n  mapMutations: mapMutations.bind(null, namespace),\n  mapActions: mapActions.bind(null, namespace)\n}); };\n\n/**\n * Normalize the map\n * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]\n * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]\n * @param {Array|Object} map\n * @return {Object}\n */\nfunction normalizeMap (map) {\n  if (!isValidMap(map)) {\n    return []\n  }\n  return Array.isArray(map)\n    ? map.map(function (key) { return ({ key: key, val: key }); })\n    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })\n}\n\n/**\n * Validate whether given map is valid or not\n * @param {*} map\n * @return {Boolean}\n */\nfunction isValidMap (map) {\n  return Array.isArray(map) || isObject(map)\n}\n\n/**\n * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.\n * @param {Function} fn\n * @return {Function}\n */\nfunction normalizeNamespace (fn) {\n  return function (namespace, map) {\n    if (typeof namespace !== 'string') {\n      map = namespace;\n      namespace = '';\n    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n      namespace += '/';\n    }\n    return fn(namespace, map)\n  }\n}\n\n/**\n * Search a special module from store by namespace. if module not exist, print error message.\n * @param {Object} store\n * @param {String} helper\n * @param {String} namespace\n * @return {Object}\n */\nfunction getModuleByNamespace (store, helper, namespace) {\n  var module = store._modulesNamespaceMap[namespace];\n  if ((process.env.NODE_ENV !== 'production') && !module) {\n    console.error((\"[vuex] module namespace not found in \" + helper + \"(): \" + namespace));\n  }\n  return module\n}\n\n// Credits: borrowed code from fcomb/redux-logger\n\nfunction createLogger (ref) {\n  if ( ref === void 0 ) ref = {};\n  var collapsed = ref.collapsed; if ( collapsed === void 0 ) collapsed = true;\n  var filter = ref.filter; if ( filter === void 0 ) filter = function (mutation, stateBefore, stateAfter) { return true; };\n  var transformer = ref.transformer; if ( transformer === void 0 ) transformer = function (state) { return state; };\n  var mutationTransformer = ref.mutationTransformer; if ( mutationTransformer === void 0 ) mutationTransformer = function (mut) { return mut; };\n  var actionFilter = ref.actionFilter; if ( actionFilter === void 0 ) actionFilter = function (action, state) { return true; };\n  var actionTransformer = ref.actionTransformer; if ( actionTransformer === void 0 ) actionTransformer = function (act) { return act; };\n  var logMutations = ref.logMutations; if ( logMutations === void 0 ) logMutations = true;\n  var logActions = ref.logActions; if ( logActions === void 0 ) logActions = true;\n  var logger = ref.logger; if ( logger === void 0 ) logger = console;\n\n  return function (store) {\n    var prevState = deepCopy(store.state);\n\n    if (typeof logger === 'undefined') {\n      return\n    }\n\n    if (logMutations) {\n      store.subscribe(function (mutation, state) {\n        var nextState = deepCopy(state);\n\n        if (filter(mutation, prevState, nextState)) {\n          var formattedTime = getFormattedTime();\n          var formattedMutation = mutationTransformer(mutation);\n          var message = \"mutation \" + (mutation.type) + formattedTime;\n\n          startMessage(logger, message, collapsed);\n          logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));\n          logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);\n          logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));\n          endMessage(logger);\n        }\n\n        prevState = nextState;\n      });\n    }\n\n    if (logActions) {\n      store.subscribeAction(function (action, state) {\n        if (actionFilter(action, state)) {\n          var formattedTime = getFormattedTime();\n          var formattedAction = actionTransformer(action);\n          var message = \"action \" + (action.type) + formattedTime;\n\n          startMessage(logger, message, collapsed);\n          logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);\n          endMessage(logger);\n        }\n      });\n    }\n  }\n}\n\nfunction startMessage (logger, message, collapsed) {\n  var startMessage = collapsed\n    ? logger.groupCollapsed\n    : logger.group;\n\n  // render\n  try {\n    startMessage.call(logger, message);\n  } catch (e) {\n    logger.log(message);\n  }\n}\n\nfunction endMessage (logger) {\n  try {\n    logger.groupEnd();\n  } catch (e) {\n    logger.log('—— log end ——');\n  }\n}\n\nfunction getFormattedTime () {\n  var time = new Date();\n  return (\" @ \" + (pad(time.getHours(), 2)) + \":\" + (pad(time.getMinutes(), 2)) + \":\" + (pad(time.getSeconds(), 2)) + \".\" + (pad(time.getMilliseconds(), 3)))\n}\n\nfunction repeat (str, times) {\n  return (new Array(times + 1)).join(str)\n}\n\nfunction pad (num, maxLength) {\n  return repeat('0', maxLength - num.toString().length) + num\n}\n\nvar index = {\n  Store: Store,\n  install: install,\n  version: '3.6.2',\n  mapState: mapState,\n  mapMutations: mapMutations,\n  mapGetters: mapGetters,\n  mapActions: mapActions,\n  createNamespacedHelpers: createNamespacedHelpers,\n  createLogger: createLogger\n};\n\nexport default index;\nexport { Store, createLogger, createNamespacedHelpers, install, mapActions, mapGetters, mapMutations, mapState };\n","import { reduce, Dictionary } from '@empathyco/x-utils';\nimport { Store } from 'vuex';\nimport { ExtractGetters, XModuleName } from '../../x-modules/x-modules.types';\nimport { AnyXStoreModule } from '../store.types';\n\ntype Getters = { [ModuleName in XModuleName]?: ExtractGetters<ModuleName> };\nlet cache: Getters = {};\n/**\n * Creates or return a proxy object of the getters of the storeModule passed.\n *\n * @param getters - The Vuex Store Getters.\n * @param moduleName - The name of the module.\n * @param storeModule - The store module.\n * @returns A {@link GettersTree} object with only the getters of the {@link XModule}.\n *\n * @internal\n *\n * @remarks This proxy will be used by the stateSelector, of the module. This is done to ensure that\n * a Vuex stateSelector can only access the getters of the {@link XModule} where it is registered.\n * This function task can be done with {@link getGettersProxy}, just without passing the\n * storeModule. But in that case every time we register emitters in a module, it will loop over all\n * the getters of all the store. This way, passing the moduleNeeded, it only loops over the getters\n * of that module. It is a performance question to have this two different implementations.\n *\n */\nexport function getGettersProxyFromModule<ModuleName extends XModuleName>(\n  getters: Pick<Store<any>, 'getters'>,\n  moduleName: ModuleName,\n  storeModule: AnyXStoreModule\n): ExtractGetters<ModuleName> {\n  /* TODO: Review why TS is not able to exclude undefined types from the Getters cache */\n  const cachedGetter = cache[moduleName];\n  if (isCacheGetterDefined<ModuleName>(cachedGetter)) {\n    return cachedGetter;\n  }\n  const modulePath = `x/${moduleName}/`;\n  const safeGetters = reduce(\n    storeModule.getters as Dictionary,\n    (safeGettersProxy, getterName) =>\n      defineGetterProxy(safeGettersProxy, getterName, `${modulePath}${getterName}`, getters),\n    {} as ExtractGetters<ModuleName>\n  );\n  cache[moduleName] = safeGetters as unknown as Getters[ModuleName];\n  return safeGetters;\n}\n\n/**\n * Creates or return a proxy object of the getters of the module with the moduleName passed.\n *\n * @param getters - The Vuex Store Getters.\n * @param moduleName - The name of the module.\n * @returns A {@link GettersTree} object with only the getters of the {@link XModule}.\n *\n * @internal\n *\n * @remarks This proxy will be used wireCommit to pass the module state and getters, to a function\n * that will return the payload to commit the mutation.\n */\nexport function getGettersProxy<ModuleName extends XModuleName>(\n  getters: Pick<Store<any>, 'getters'>,\n  moduleName: ModuleName\n): ExtractGetters<ModuleName> {\n  /* TODO: Review why TS is not able to exclude undefined types from the Getters cache */\n  const cachedGetter = cache[moduleName];\n  if (isCacheGetterDefined<ModuleName>(cachedGetter)) {\n    return cachedGetter;\n  }\n  const modulePath = `x/${moduleName}/`;\n  const getterKeys: string[] = Object.keys(getters).filter(getterKey =>\n    getterKey.startsWith(modulePath)\n  );\n  const safeGetters = getterKeys.reduce((safeGettersProxy, fullPathGetterName) => {\n    const getterName = fullPathGetterName.replace(modulePath, '');\n    return defineGetterProxy(safeGettersProxy, getterName, fullPathGetterName, getters);\n  }, {} as ExtractGetters<ModuleName>);\n  cache[moduleName] = safeGetters as unknown as Getters[ModuleName];\n  return safeGetters;\n}\n\n/**\n * Defines a JS getter in safeGettersProxy object that returns the Vuex getter value.\n *\n * @param safeGettersProxy - The object where the proxy will be defined.\n * @param getterName - The name of the Getter without path. For example: 'trimQuery'.\n * @param fullPathGetterName - The name of the getter to be accessed with the full path.\n * For example: 'x/searchBox/trimmedQuery'.\n * @param getters - The Vuex Store Getters.\n * @returns The same safeGetterProxy with new get defined.\n *\n * @internal\n */\nfunction defineGetterProxy<ModuleName extends XModuleName>(\n  safeGettersProxy: ExtractGetters<ModuleName>,\n  getterName: string,\n  fullPathGetterName: string,\n  getters: Dictionary\n): ExtractGetters<ModuleName> {\n  return Object.defineProperty(safeGettersProxy, getterName, {\n    get() {\n      return getters[fullPathGetterName];\n    },\n    enumerable: true\n  });\n}\n\n/** Clean the cache (This is for testing purpose).\n *\n * @internal\n * */\nexport function cleanGettersProxyCache(): void {\n  cache = {};\n}\n\n/**\n * Checks if the getter cached is defined.\n *\n * @param cachedGetter - The getter cached.\n * @returns If the getters is defined or not.\n *\n * @internal\n */\nfunction isCacheGetterDefined<ModuleName extends XModuleName>(\n  cachedGetter: ExtractGetters<ModuleName> | undefined | unknown\n): cachedGetter is ExtractGetters<ModuleName> {\n  return cachedGetter !== undefined;\n}\n","import { Module } from 'vuex';\nimport { RootXStoreState } from './store.types';\n\n/**\n * The type of the x module state has a property for each other sub-module assigned to `null`,\n * so we can avoid re-executing getters every time\n * the `store.registerModule` method is called.\n *\n * @internal\n */\nexport type XModuleState = { [Key in keyof RootXStoreState['x']]: null };\n\n/**\n * The main module of the X Store. All of the other {@link XModule | XModules} will be\n * registered as a sub-module of this one.\n *\n * @internal\n */\nexport const RootXStoreModule: Module<XModuleState, any> = {\n  state: () => ({\n    device: null,\n    empathize: null,\n    extraParams: null,\n    facets: null,\n    historyQueries: null,\n    identifierResults: null,\n    nextQueries: null,\n    popularSearches: null,\n    queriesPreview: null,\n    querySuggestions: null,\n    recommendations: null,\n    relatedTags: null,\n    scroll: null,\n    search: null,\n    searchBox: null,\n    semanticQueries: null,\n    tagging: null,\n    url: null\n  }),\n  namespaced: true\n};\n","import { Subject, Observable, timer, race } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { Store } from 'vuex';\nimport { XBus } from '@empathyco/x-bus';\nimport { RootXStoreState } from '../store/store.types';\nimport { MaybeArray } from '../utils/types';\nimport { XEvent, XEventsTypes } from './events.types';\nimport { TimedWireOperatorOptions, TimeSelector, WireMetadata } from './wiring.types';\n\n/**\n * Creates the observable for the events that will be racing the wire's execution.\n *\n * @param events - The events to merge its observables.\n * @param on - The on function of the {@link @empathyco/x-bus#XBus} where the events will run.\n * @returns The observable for the racing events.\n * @internal\n */\nexport function mergeEvents(\n  events: MaybeArray<XEvent>,\n  on: XBus<XEventsTypes, WireMetadata>['on']\n): Observable<void> {\n  const subject = new Subject<void>();\n  const eventsList = Array.isArray(events) ? events : [events];\n\n  /* Can't use RxJS `merge` function, as it immediately emits previously emitted values to new\n   subscriptions due to the `ReplaySubject` of the bus. With this Subject we are still receiving\n   those values immediately on subscription, but as there are no subscribers before the `return`\n   happens we are fine. */\n  eventsList.forEach(raceEvent => on(raceEvent).subscribe(() => subject.next()));\n  return subject;\n}\n\n/**\n * Checks how to retrieve the timeout time, retrieves it and returns it in ms.\n *\n * @param timeInMs - Time for the timeout in ms.\n * @param store - The store of the wire that will be timed out.\n * @returns The time in ms for the timeout.\n * @internal\n */\nexport function normalizeTime(\n  timeInMs: TimeSelector | number,\n  store: Store<RootXStoreState>\n): number {\n  return typeof timeInMs === 'function' ? timeInMs(store) : timeInMs;\n}\n\n/**\n * Creates a timer observable that depending on the provided options might be aborted or forced.\n *\n * @param durationInMs - The duration in ms for the timer.\n * @param options - Options to configure the timer, like an events to force it or cancel it.\n * @param on - The {@link XBus.on} method.\n * @returns A timer observable that can be aborted or forced depending on the provided options.\n * @internal\n */\nexport function createTimer(\n  durationInMs: number,\n  { cancelOn, forceOn }: TimedWireOperatorOptions,\n  on: XBus<XEventsTypes, WireMetadata>['on']\n): Observable<unknown> {\n  let timerObservable: Observable<unknown> = timer(durationInMs);\n  if (forceOn) {\n    timerObservable = race(timerObservable, mergeEvents(forceOn, on));\n  }\n\n  if (cancelOn) {\n    timerObservable = timerObservable.pipe(takeUntil(mergeEvents(cancelOn, on)));\n  }\n\n  return timerObservable;\n}\n","import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\n\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * ![](takeUntil.png)\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * ## Example\n *\n * Tick every second until the first click happens\n *\n * ```ts\n * import { interval, fromEvent, takeUntil } from 'rxjs';\n *\n * const source = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = source.pipe(takeUntil(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return A function that returns an Observable that emits the values from the\n * source Observable until `notifier` emits its first value.\n */\nexport function takeUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n    !subscriber.closed && source.subscribe(subscriber);\n  });\n}\n","import {\n  debounce as debounceRx,\n  filter as filterRx,\n  map,\n  throttle as throttleRx\n} from 'rxjs/operators';\nimport { XModuleName } from '../x-modules/x-modules.types';\nimport { createTimer, normalizeTime } from './wires-operators.utils';\nimport { TimedWireOperatorOptions, TimeSelector, Wire, WireParams } from './wiring.types';\n\n/**\n * Creates a {@link Wire} that is only executed whenever the condition in the filterFn is true.\n *\n * @param wire - The wire to filter.\n * @param filterFn - A function which must return a boolean and that will be executed every time\n * the wire is called.\n * @returns The Wire function filter.\n *\n * @public\n */\nexport function filter<Payload>(\n  wire: Wire<Payload>,\n  filterFn: (parameters: WireParams<Payload>) => boolean\n): Wire<Payload> {\n  return (observable, store, on) =>\n    wire(observable.pipe(filterRx(wirePayload => filterFn({ ...wirePayload, store }))), store, on);\n}\n\n/**\n * Creates a {@link Wire} that is only executed when the payload is truthy. A truthy value is\n * whatever is not a {@link https://developer.mozilla.org/en-US/docs/Glossary/Falsy | falsy value}.\n *\n * @param wire - The wire to avoid executing when the payload is falsy.\n * @returns The Wire function falsy filter.\n *\n * @public\n */\nexport function filterFalsyPayload<Payload>(\n  wire: Wire<Exclude<Payload, null | undefined | false | 0 | ''>>\n): Wire<Payload> {\n  return filter(wire, ({ eventPayload }) => !!eventPayload) as Wire<Payload>;\n}\n\n/**\n * Creates a {@link Wire} that is only executed when the payload is a\n * {@link https://developer.mozilla.org/en-US/docs/Glossary/Falsy | falsy value}.\n *\n * @param wire - The wire to avoid executing when the payload is truthy.\n * @returns The Wire function truthy filter.\n *\n * @public\n */\nexport function filterTruthyPayload<Payload>(wire: Wire<Payload>): Wire<Payload> {\n  return filter(wire, ({ eventPayload }) => !eventPayload);\n}\n\n/**\n * Creates a {@link Wire} that is only executed if the event is emitted from a {@link XModule}\n * that is included\n * in the `whitelist` array passed as parameter.\n *\n * @param wire - The wire to filter using the whitelist.\n * @param whitelist - An array of {@link XModuleName} or null.\n * @returns The Wire function with whitelisted modules filter.\n *\n * @public\n */\nexport function filterWhitelistedModules<Payload>(\n  wire: Wire<Payload>,\n  whitelist: Array<XModuleName | null>\n): Wire<Payload> {\n  const whitelistSet = new Set(whitelist);\n  return filter(wire, ({ metadata }) => whitelistSet.has(metadata.moduleName));\n}\n\n/**\n * Creates a {@link Wire} that is only executed if the event is emitted from a {@link XModule}\n * that is NOT included\n * in the `blacklist` array passed as parameter.\n *\n * @param wire - The wire to filter using the whitelist.\n * @param blacklist - An array of {@link XModuleName} or null.\n * @returns The Wire function with blacklisted modules filter.\n *\n * @public\n */\nexport function filterBlacklistedModules<Payload>(\n  wire: Wire<Payload>,\n  blacklist: Array<XModuleName | null>\n): Wire<Payload> {\n  const blacklistSet = new Set(blacklist);\n  return filter(wire, ({ metadata }) => !blacklistSet.has(metadata.moduleName));\n}\n\n/**\n * Creates a debounced {@link Wire}. Being debounced means that it will only be executed after\n * the time given by `timeInMs` has passed without invoking it.\n *\n * @param wire - The wire to debounce.\n * @param timeInMs - The time in milliseconds to debounce the wire execution or a function to\n * retrieve it from the store.\n * @param options - Options to configure this wire with, like an event to force it or cancel it.\n * @returns The Wire function with a debounced timing.\n *\n * @public\n */\nexport function debounce<Payload>(\n  wire: Wire<Payload>,\n  timeInMs: TimeSelector | number,\n  options: TimedWireOperatorOptions = {}\n): Wire<Payload> {\n  return (observable, store, on) => {\n    return wire(\n      observable.pipe(debounceRx(() => createTimer(normalizeTime(timeInMs, store), options, on))),\n      store,\n      on\n    );\n  };\n}\n\n/**\n * Creates a throttled {@link Wire}. Being throttled means that it will only be executed once\n * every couple of milliseconds given by the `timeInMs` parameter.\n *\n * @param wire - The wire to throttle.\n * @param timeInMs - The time in milliseconds to throttle the wire execution or a function to\n * retrieve it from the store.\n * @param options - Options to configure this wire with, like an event to force it or cancel it.\n * @returns The Wire function with a throttle timing.\n *\n * @public\n */\nexport function throttle<Payload>(\n  wire: Wire<Payload>,\n  timeInMs: TimeSelector | number,\n  options: TimedWireOperatorOptions = {}\n): Wire<Payload> {\n  return (observable, store, on) => {\n    return wire(\n      observable.pipe(\n        throttleRx(() => createTimer(normalizeTime(timeInMs, store), options, on), {\n          leading: true,\n          trailing: true\n        })\n      ),\n      store,\n      on\n    );\n  };\n}\n\n/**\n * Creates a {@link Wire} from other `toWire` wire. It uses `mapFn` to transform the\n * `FromPayload` received to `ToPayload` which `toWire` requires. This is\n * useful to reuse wires in different Events where the payload doesn't fit exactly.\n *\n * @param toWire - The wire which the new Wire is created from.\n * @param mapFn - Function to map the payload from `FromPayload` to `ToPayload`.\n * @returns A new {@link Wire}.\n *\n * @public\n */\nexport function mapWire<FromPayload, ToPayload>(\n  toWire: Wire<ToPayload>,\n  mapFn: (payload: FromPayload) => ToPayload\n): Wire<FromPayload> {\n  return (observable, ...restWireParams) =>\n    toWire(\n      observable.pipe(\n        map(({ eventPayload, ...restWirePayload }) => ({\n          eventPayload: mapFn(eventPayload),\n          ...restWirePayload\n        }))\n      ),\n      ...restWireParams\n    );\n}\n","import { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Emits a notification from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * ![](debounce.svg)\n *\n * `debounce` delays notifications emitted by the source Observable, but drops previous\n * pending delayed emissions if a new notification arrives on the source Observable.\n * This operator keeps track of the most recent notification from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The notification is emitted only when the duration\n * Observable emits a next notification, and if no other notification was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * notification appears before the duration Observable emits, the previous notification will\n * not be emitted and a new duration is scheduled from `durationSelector` is scheduled.\n * If the completing event happens during the scheduled duration the last cached notification\n * is emitted before the completion event is forwarded to the output observable.\n * If the error event happens during the scheduled duration or after it only the error event is\n * forwarded to the output observable. The cache notification is not emitted in this case.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * ## Example\n *\n * Emit the most recent click after a burst of clicks\n *\n * ```ts\n * import { fromEvent, scan, debounce, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   scan(i => ++i, 1),\n *   debounce(i => interval(200 * i))\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link throttle}\n * @see {@link throttleTime}\n *\n * @param durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n */\nexport function debounce<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let lastValue: T | null = null;\n    // The subscriber/subscription for the current debounce, if there is one.\n    let durationSubscriber: Subscriber<any> | null = null;\n\n    const emit = () => {\n      // Unsubscribe any current debounce subscription we have,\n      // we only cared about the first notification from it, and we\n      // want to clean that subscription up as soon as possible.\n      durationSubscriber?.unsubscribe();\n      durationSubscriber = null;\n      if (hasValue) {\n        // We have a value! Free up memory first, then emit the value.\n        hasValue = false;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Cancel any pending debounce duration. We don't\n          // need to null it out here yet tho, because we're just going\n          // to create another one in a few lines.\n          durationSubscriber?.unsubscribe();\n          hasValue = true;\n          lastValue = value;\n          // Capture our duration subscriber, so we can unsubscribe it when we're notified\n          // and we're going to emit the value.\n          durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);\n          // Subscribe to the duration.\n          innerFrom(durationSelector(value)).subscribe(durationSubscriber);\n        },\n        () => {\n          // Source completed.\n          // Emit any pending debounced values then complete\n          emit();\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer\n        undefined,\n        () => {\n          // Finalization.\n          lastValue = durationSubscriber = null;\n        }\n      )\n    );\n  });\n}\n","import { Dictionary } from '@empathyco/x-utils';\nimport { NumberComparatorFn, XPriorityQueue, XPriorityQueueNode } from './x-priority-queue.types';\n\n/**\n * Default {@link XPriorityQueueNode} implementation.\n *\n * @public\n */\nexport class BaseXPriorityQueueNode<SomeRecord extends Dictionary, SomeData extends Dictionary>\n  implements XPriorityQueueNode<SomeRecord, SomeData>\n{\n  public readonly key: keyof SomeRecord;\n  public readonly priority: number;\n  public readonly data: SomeData;\n\n  public constructor(key: keyof SomeRecord, priority: number, data = {} as SomeData) {\n    this.key = key;\n    this.priority = priority;\n    this.data = data;\n  }\n\n  /**\n   * Returns a string representation of this object. The string representation consists of: its\n   * priority, enclosed in square brackets (`[]`), followed by its key, an arrow `(->)` and the\n   * data converted to a string using JSON.stringify.\n   *\n   * @example\n   * ```\n   * [10] 1 -> { replaceable: false, randomKey: randomValue }\n   * ```\n   *\n   * @returns A string representation of this object.\n   *\n   * @public\n   */\n  toString(): string {\n    return `[${this.priority}] ${String(this.key)} -> ${JSON.stringify(this.data)}`;\n  }\n}\n\n/**.\n * Default {@link XPriorityQueue} implementation.\n *\n * Method         big-O\n * ---------------------------\n * - push         O(n)\n * - pop          O(1)\n * - peek         O(1)\n * - at           O(1)\n *\n * @public\n */\nexport class BaseXPriorityQueue<\n  SomeRecord extends Dictionary,\n  SomeData extends Dictionary = Dictionary\n> implements XPriorityQueue<SomeRecord, SomeData>\n{\n  /**\n   * The list of stored {@link XPriorityQueueNode | nodes}.\n   *\n   * @internal\n   */\n  protected nodes: XPriorityQueueNode<SomeRecord, SomeData>[] = [];\n\n  /**\n   * The comparator function to use for sorting.\n   *\n   * @internal\n   */\n  protected comparatorFn: NumberComparatorFn;\n\n  /**\n   * Creates a new {@link XPriorityQueue}.\n   *\n   * @param comparatorFn - Comparator - the comparator that will be used to order this queue.\n   * By default, the elements will be sorted in descending order (an element with priority 1 will\n   * be higher in the queue than another with priority 0).\n   */\n  public constructor(comparatorFn: NumberComparatorFn = (a: number, b: number) => a < b) {\n    this.comparatorFn = comparatorFn;\n  }\n\n  /**\n   * The `keys` property of a {@link XPriorityQueue} represents the keys of that queue. The value is\n   * an array of the parametrized `Key` type.\n   *\n   * @returns The list of keys.\n   */\n  public get keys(): (keyof SomeRecord)[] {\n    return this.nodes.map(({ key }) => key);\n  }\n\n  /**.\n   * See {@link XPriorityQueue.push}.\n   *\n   * @remarks\n   * If the optional data has a 'replaceable: true' and a similar key is already in the queue,\n   * the previous key will be removed and the new one will be inserted to the queue at the\n   * correct position based on its new priority.\n   *\n   * @param key - The key to insert.\n   * @param priority - The priority to order the element in the queue.\n   * @param data - The extra data associated to a key and priority pair.\n   */\n  push(key: keyof SomeRecord, priority: number, data?: SomeData): void {\n    const node = new BaseXPriorityQueueNode<SomeRecord, SomeData>(key, priority, data);\n\n    if (this.isEmpty()) {\n      this.nodes.push(node);\n    } else {\n      this.pushAndSort(node);\n    }\n  }\n\n  /**\n   * Inserts the node into the queue in the correct position based on the\n   * {@link comparatorFn | comparator function}.\n   *\n   * @param newNode - The {@link XPriorityQueueNode | node} to be inserted.\n   *\n   * @internal\n   */\n  private pushAndSort(newNode: XPriorityQueueNode<SomeRecord, SomeData>): void {\n    const replaceableIndex = this.nodes.findIndex(node => node.key === newNode.key);\n\n    if (replaceableIndex > -1 && this.nodes[replaceableIndex].data.replaceable) {\n      this.nodes.splice(replaceableIndex, 1);\n    }\n\n    const insertAtIndex = this.nodes.findIndex(node =>\n      this.comparatorFn(node.priority, newNode.priority)\n    );\n\n    if (insertAtIndex === -1) {\n      this.nodes.push(newNode);\n    } else {\n      this.nodes.splice(insertAtIndex, 0, newNode);\n    }\n  }\n\n  /**\n   * See {@link XPriorityQueue.pop}.\n   *\n   * @returns The head {@link XPriorityQueueNode | node} of the queue or undefined if it is empty.\n   */\n  pop(): XPriorityQueueNode<SomeRecord, SomeData> | undefined {\n    return this.nodes.shift();\n  }\n\n  /**\n   * Retrieves, but does not remove, the head {@link XPriorityQueueNode | node} of the queue.\n   *\n   * @returns The head {@link XPriorityQueueNode | node} of the queue.\n   */\n  peek(): XPriorityQueueNode<SomeRecord, SomeData> | undefined {\n    return this.nodes[0];\n  }\n\n  /**\n   * Retrieves the {@link XPriorityQueueNode | node} at a given position.\n   *\n   * @param index - The position to look at.\n   *\n   * @returns The {@link XPriorityQueueNode | node} at the passed position in the queue.\n   */\n  at(index: number): XPriorityQueueNode<SomeRecord, SomeData> | undefined {\n    return this.nodes[index];\n  }\n\n  /**\n   * Removes all the {@link XPriorityQueueNode | nodes} from the queue.\n   */\n  clear(): void {\n    this.nodes.length = 0;\n  }\n\n  /**\n   * Checks if the queue is empty.\n   *\n   * @returns True if the queue is empty, false otherwise.\n   */\n  isEmpty(): boolean {\n    return this.nodes.length === 0;\n  }\n\n  /**\n   * Retrieves the number of {@link XPriorityQueueNode | nodes} stored in the queue.\n   *\n   * @returns The number of {@link XPriorityQueueNode | nodes} stored in the queue.\n   */\n  size(): number {\n    return this.nodes.length;\n  }\n\n  /**\n   * Returns a string representation of this collection. The string representation consists of a\n   * list of the queue {@link XPriorityQueueNode | nodes} split in multiple lines, one for each\n   * one. Nodes are converted to strings as by {@link XPriorityQueueNode.toString | toString()}.\n   *\n   * @example\n   * ```\n   * [10] 1 -> { replaceable: false, a: 'b' }\n   * [20] 2 -> { replaceable: false }\n   * [30] 3 -> { replaceable: false, c: 1 }\n   * ```\n   *\n   * @returns A string representation of the queue.\n   */\n  toString(): string {\n    return this.nodes.reduce((output, node) => output.concat(node.toString(), '\\n'), '');\n  }\n}\n","import { DevtoolsPluginApi } from '@vue/devtools-api';\nimport { Dictionary } from '@empathyco/x-utils';\nimport { XEvent, XEventPayload } from '../../wiring/events.types';\nimport { WirePayload } from '../../wiring/wiring.types';\nimport { hslToHex } from './colors.utils';\n\n/**\n * Contains the devtools API.\n */\nlet devtoolsAPI: DevtoolsPluginApi<Dictionary> | undefined;\n\n/**\n * List of all the configured timeline layers for {@link XEvent}s.\n */\nconst timelineLayers = [\n  {\n    id: 'x-components-all-events',\n    regex: /^$/,\n    label: 'X events'\n  },\n  {\n    id: 'x-components-module-registered-events',\n    regex: /^ModuleRegistered$/,\n    label: 'X registered modules'\n  },\n  {\n    id: 'x-components-user-events',\n    regex: /^User/,\n    label: 'X user events'\n  },\n\n  {\n    id: 'x-components-request-events',\n    regex: /Request(?:Changed|Updated)$/,\n    label: 'X request events'\n  },\n  {\n    id: 'x-components-status-change-events',\n    regex: /Changed$/,\n    label: 'X status change events'\n  },\n  {\n    id: 'x-components-miscellanea-events',\n    regex: /.*/,\n    label: 'X miscellanea events'\n  }\n];\n\n/** Set containing the different layer ids. */\nconst layerIds = new Set(timelineLayers.map(layer => layer.id));\n\n/**\n * Retrieves the timeline layer that an {@link XEvent} belongs to.\n *\n * @param event - The {@link XEvent} to retrieve its layer id.\n * @returns The layer id for the {@link XEvent}.\n */\nfunction getTimelineLayer(event: XEvent): string {\n  return timelineLayers.find(layer => layer.regex.test(event))!.id;\n}\n\n/**\n * Configures Vue's devtools timeline with new rows for {@link XEvent}s.\n *\n * @param api - Vue's devtools API.\n * @internal\n */\nexport function setupTimelinePlugin(api: DevtoolsPluginApi<Dictionary>): void {\n  devtoolsAPI = api;\n  timelineLayers.forEach(layer =>\n    api.addTimelineLayer({\n      id: layer.id,\n      label: layer.label,\n      color: hslToHex(329, 100, 50)\n    })\n  );\n  api.on.inspectTimelineEvent(payload => {\n    if (layerIds.has(payload.layerId)) {\n      const component = (<WirePayload<unknown>>payload.event.data).metadata.component;\n      if (component) {\n        api.highlightElement(component);\n      }\n    }\n  });\n}\n\n/**\n * Sends the emission of an {@link XEvent} to the devtools.\n *\n * @param event - The emitted {@link XEvent}.\n * @param value - An object containing both the event payload and its metadata.\n * @internal\n */\nexport function logDevtoolsXEvent<Event extends XEvent>(\n  event: Event,\n  value: WirePayload<XEventPayload<Event>>\n): void {\n  if (process.env.NODE_ENV !== 'production' && devtoolsAPI) {\n    const timelineEvent = {\n      title: event,\n      data: {\n        ...value,\n        metadata: {\n          ...value.metadata,\n          // FIX-ME: copying metadata.component as it is defined as a non-enumerable property.\n          component: value.metadata.component\n        }\n      },\n      time: devtoolsAPI.now()\n    };\n    devtoolsAPI.addTimelineEvent({\n      event: timelineEvent,\n      layerId: getTimelineLayer(event)\n    });\n    devtoolsAPI.addTimelineEvent({\n      event: timelineEvent,\n      layerId: 'x-components-all-events'\n    });\n  }\n}\n","import { XPriorityBus } from '@empathyco/x-bus';\nimport { XEventsTypes } from '../wiring/events.types';\nimport { WireMetadata } from '../wiring/wiring.types';\nimport { logDevtoolsXEvent } from './devtools/timeline.devtools';\n\n/**\n * Default {@link @empathyco/x-bus#XBus} implementation.\n *\n * @public\n */\nexport const bus = new XPriorityBus<XEventsTypes, WireMetadata>({\n  priorities: {\n    Updated: 2,\n    Changed: 4,\n    FromUrl: 8,\n    User: 16,\n    External: 32,\n    Initialized: 64,\n    Provided: 128,\n    DataReceived: 256,\n    ModuleRegistered: 512\n  },\n  emitCallbacks: [logDevtoolsXEvent]\n});\n","import { BaseXPriorityQueue, XPriorityQueue } from '@empathyco/x-priority-queue';\nimport { AnyFunction, Dictionary } from '@empathyco/x-utils';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport {\n  EmittedData,\n  Emitter,\n  Emitters,\n  Priority,\n  SubjectPayload,\n  EventPayload,\n  XBus,\n  XPriorityQueueNodeData\n} from './x-bus.types';\n\n/**\n * A default {@link XBus} implementation using a\n * {@link @empathyco/x-priority-queue#XPriorityQueue | priority queue} as its data structure to\n * prioritise the emission of events. The priorities are preconfigured based on event naming.\n *\n * @public\n */\nexport class XPriorityBus<SomeEvents extends Dictionary, SomeEventMetadata extends Dictionary>\n  implements XBus<SomeEvents, SomeEventMetadata>\n{\n  /**\n   * A {@link @empathyco/x-priority-queue#XPriorityQueue | priority queue} to store the events to\n   * emit.\n   *\n   * @internal\n   */\n  protected queue: XPriorityQueue<\n    SomeEvents,\n    XPriorityQueueNodeData<SomeEvents, SomeEventMetadata>\n  >;\n\n  /**\n   * A dictionary associating a priority to a key.\n   *\n   * @example\n   * ```ts\n   * const priorities: Dictionary<number> = {\n   *   '^StartsWith': 2,\n   *   Contains: 4,\n   *   EndWith$: 8\n   * }\n   * ```\n   *\n   * @internal\n   */\n  protected priorities: Dictionary<Priority>;\n\n  /**\n   * The default value to use as priority for an event that doesn't have defined neither a custom\n   * priority nor its name doesn't match any key of the {@link priorities} dictionary.\n   *\n   * @internal\n   */\n  protected defaultEventPriority: number;\n\n  /**\n   * A list of functions to execute when an event is emitted.\n   *\n   * @internal\n   */\n  protected emitCallbacks: AnyFunction[];\n\n  /**\n   * A dictionary to store the created event emitters.\n   *\n   * @internal\n   */\n  protected emitters: Emitters<SomeEvents, SomeEventMetadata> = {};\n\n  /**\n   * A pending flush operation timeout identifier or undefined if there's none pending.\n   *\n   * @internal\n   */\n  protected pendingFlushId?: number;\n\n  /**\n   * A list of pending pop operations timeout identifiers.\n   *\n   * @internal\n   */\n  protected pendingPopsIds: number[] = [];\n\n  /**\n   * Creates a new instance of a {@link XPriorityBus}.\n   *\n   * @param config - A configuration object to initialise the bus.\n   * @param config.queue - A {@link @empathyco/x-priority-queue#XPriorityQueue | priority queue} to\n   * store the events.\n   * @param config.priorities - A {@link @empathyco/x-utils#Dictionary} defining the priorities\n   * associated to a given string.\n   @param config.emitCallbacks - A list of functions to execute when an event is emitted.\n   * @param config.defaultEventPriority -  A default priority to assigned to an event.\n   */\n  public constructor(\n    config: {\n      queue?: XPriorityQueue<SomeEvents, XPriorityQueueNodeData<SomeEvents, SomeEventMetadata>>;\n      priorities?: Dictionary<number>;\n      emitCallbacks?: AnyFunction[];\n      defaultEventPriority?: number;\n    } = {}\n  ) {\n    this.queue =\n      config.queue ??\n      new BaseXPriorityQueue<SomeEvents, XPriorityQueueNodeData<SomeEvents, SomeEventMetadata>>();\n    this.priorities = config.priorities ?? {};\n    this.emitCallbacks = config.emitCallbacks ?? [];\n    this.defaultEventPriority = config.defaultEventPriority ?? Number.MIN_SAFE_INTEGER;\n  }\n\n  /**\n   * Emits an event. See {@link XBus.(emit:2)}.\n   *\n   * @param event - Event to be emitted.\n   * @param payload - Event payload.\n   * @param metadata - Extra event data.\n   *\n   * @returns A promise that is resolved the moment the event is emitted.\n   */\n  emit<SomeEvent extends keyof SomeEvents>(\n    event: SomeEvent,\n    // TODO: Fix optional argument.\n    payload?: EventPayload<SomeEvents, SomeEvent>,\n    metadata = {} as SomeEventMetadata\n  ): Promise<EmittedData<SomeEvents, SomeEvent, SomeEventMetadata>> {\n    return new Promise(resolve => {\n      this.queue.push(event, this.getEventPriority(event, metadata), {\n        // This type assertion is done because payload is optional.\n        eventPayload: payload as EventPayload<SomeEvents, SomeEvent>,\n        eventMetadata: metadata,\n        replaceable: metadata.replaceable || false,\n        // TODO: Fix type.\n        resolve: resolve as any\n      });\n\n      this.flushQueue();\n    });\n  }\n\n  /**.\n   * Retrieves the event priority based on:\n   * - the defined event metadata priority\n   * - the priority associated to the matching preconfigured priority key\n   * - the configured {@link defaultEventPriority} is assigned (by default, the min safe integer).\n   *\n   * @param event - The event to get the priority from.\n   * @param metadata - The event metadata.\n   *\n   * @returns The priority for the given event.\n   *\n   * @internal\n   */\n  protected getEventPriority(event: keyof SomeEvents, metadata: SomeEventMetadata): Priority {\n    if (metadata.priority != null) {\n      return metadata.priority;\n    }\n\n    const matchingKey = Object.keys(this.priorities).find(key => String(event).includes(key));\n    if (matchingKey) {\n      return this.priorities[matchingKey];\n    }\n\n    return this.defaultEventPriority;\n  }\n\n  /**\n   * Processes the events stored in the\n   * {@link @empathyco/x-priority-queue#XPriorityQueue | priority queue} and resolves each event\n   * whenever it is emitted.\n   *\n   * @remarks If another 'flushQueue' operation is running, it is discarded and a new one is\n   * executed. The pending popping operations are also discarded.\n   *\n   * @internal\n   */\n  protected flushQueue(): void {\n    clearTimeout(this.pendingFlushId);\n    this.clearPendingPopsIds();\n\n    this.pendingFlushId = window.setTimeout(() => {\n      for (let i = 0; i < this.queue.size(); ++i) {\n        const popTimeoutId = window.setTimeout(() => {\n          const {\n            key,\n            data: { eventPayload, eventMetadata, resolve }\n          } = this.queue.pop()!;\n          const emitter = this.getEmitter(key);\n          const payloadObj = {\n            eventPayload,\n            metadata: eventMetadata\n          };\n\n          emitter.next(payloadObj);\n\n          this.emitCallbacks.forEach(callback => callback(key, payloadObj));\n          resolve({ event: key, ...payloadObj });\n\n          this.pendingPopsIds = this.pendingPopsIds.filter(timeoutId => timeoutId !== popTimeoutId);\n        });\n\n        this.pendingPopsIds.push(popTimeoutId);\n      }\n    });\n  }\n\n  /**\n   * Discards existing pending pop operations and empties the array.\n   *\n   * @internal\n   */\n  private clearPendingPopsIds(): void {\n    this.pendingPopsIds.forEach(clearTimeout);\n    this.pendingPopsIds.length = 0;\n  }\n\n  /**\n   * Retrieves an observable for the event. See {@link XBus.(on:3)}.\n   *\n   * @param event - Event to retrieve the observable for.\n   * @param withMetadata - Option to retrieve an observable with extra data about the event.\n   *\n   * @returns The emitter for the event passed.\n   */\n  on<SomeEvent extends keyof SomeEvents>(\n    event: SomeEvent,\n    withMetadata = false\n  ): typeof withMetadata extends true\n    ? Observable<SubjectPayload<EventPayload<SomeEvents, SomeEvent>, SomeEventMetadata>>\n    : Observable<EventPayload<SomeEvents, SomeEvent>> {\n    // TODO: This type should work, but inference isn't working as expected. Check when updating ts.\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return withMetadata\n      ? this.getEmitter(event).asObservable()\n      : this.getEmitter(event).pipe(\n          map<\n            SubjectPayload<EventPayload<SomeEvents, SomeEvent>, SomeEventMetadata>,\n            EventPayload<SomeEvents, SomeEvent>\n          >(value => value.eventPayload)\n        );\n  }\n\n  /**\n   * Retrieves an event {@link Emitter} for the given event.\n   *\n   * @param event - The event to retrieve the {@link Emitter} for.\n   *\n   * @returns The {@link Emitters} for the passed event.\n   *\n   * @internal\n   */\n  protected getEmitter<SomeEvent extends keyof SomeEvents>(\n    event: SomeEvent\n  ): Emitter<SomeEvents, SomeEvent, SomeEventMetadata> {\n    if (!this.emitters[event]) {\n      this.createEmitter(event);\n    }\n\n    return this.emitters[event]!;\n  }\n\n  /**\n   * Creates an event {@link Emitter} for the given event.\n   *\n   * @remarks The emitter is implemented with a\n   * {@Link https://www.learnrxjs.io/learn-rxjs/subjects/replaysubject | ReplaySubject} to allow any\n   * new subscriber receive the last emitted value.\n   *\n   * @param event - The event to create the {@link Emitter} for.\n   *\n   * @internal\n   */\n  protected createEmitter<SomeEvent extends keyof SomeEvents>(event: SomeEvent): void {\n    this.emitters[event] = new ReplaySubject<\n      SubjectPayload<EventPayload<SomeEvents, SomeEvent>, SomeEventMetadata>\n    >(1);\n  }\n}\n","import { XBus } from '@empathyco/x-bus';\nimport { forEach } from '@empathyco/x-utils';\nimport { Store } from 'vuex';\nimport { getGettersProxyFromModule } from '../store/utils/getters-proxy.utils';\nimport { AnySimpleStateSelector, AnyStateSelector } from '../store/utils/store-emitters.utils';\nimport { XEventPayload, XEventsTypes } from '../wiring/events.types';\nimport { WireMetadata } from '../wiring/wiring.types';\nimport { AnyXModule } from '../x-modules/x-modules.types';\n\n/**\n * Registers the store emitters, making them emit the event when the part of the state selected\n * changes.\n *\n * @param xModule - The {@link XModule} to register its Store Emitters.\n * @param bus - The {@link @empathyco/x-bus#XBus} to emit the events by the Emitters.\n * @param store - The Vuex store to access to state and getters to watch them.\n *\n * @internal\n */\nexport function registerStoreEmitters(\n  { name, storeEmitters, storeModule }: AnyXModule,\n  bus: XBus<XEventsTypes, WireMetadata>,\n  store: Store<any>\n): void {\n  const safeGettersProxy = getGettersProxyFromModule(store.getters, name, storeModule);\n  forEach(storeEmitters, (event, stateSelector: AnySimpleStateSelector | AnyStateSelector) => {\n    const { selector, immediate, filter, metadata, ...options } =\n      normalizeStateSelector(stateSelector);\n\n    const watcherSelector = (): XEventPayload<typeof event> =>\n      selector(store.state.x[name], safeGettersProxy);\n    const emit: (\n      newValue: XEventPayload<typeof event>,\n      oldValue: XEventPayload<typeof event>\n    ) => void = (newValue, oldValue) => {\n      if (filter(newValue, oldValue)) {\n        bus.emit(event, newValue, { ...metadata, moduleName: name, oldValue });\n      }\n    };\n\n    store.watch(watcherSelector, emit, options);\n\n    if (immediate) {\n      emit(watcherSelector());\n    }\n  });\n}\n\n/**\n * Transforms a {@link AnySimpleStateSelector} into a {@link AnyStateSelector}, and sets\n * default values for its properties.\n *\n * @param stateSelector - The state selector to normalize.\n * @returns A {@link AnyStateSelector} with all the properties set.\n *\n * @internal\n */\nfunction normalizeStateSelector(\n  stateSelector: AnySimpleStateSelector | AnyStateSelector\n): Required<AnyStateSelector> {\n  const selectorOptions = isSimpleSelector(stateSelector)\n    ? { selector: stateSelector }\n    : stateSelector;\n\n  return {\n    deep: false,\n    immediate: false,\n    filter: () => true,\n    metadata: {\n      replaceable: true\n    },\n    ...selectorOptions\n  };\n}\n\n/**\n * Checks if the type of the store emitter selector is simple or complex. This selector can be\n * a function if it is simple or an object with the selector and other options if it is complex.\n *\n * @param stateSelector - The store emitter selector.\n * @returns A boolean which flags if the stateSelector is simple (function) or complex (object).\n *\n * @internal\n */\nexport function isSimpleSelector(\n  stateSelector: AnySimpleStateSelector | AnyStateSelector\n): stateSelector is AnySimpleStateSelector {\n  return typeof stateSelector === 'function';\n}\n","import Vue from 'vue';\nimport { XModuleName } from '../x-modules/x-modules.types';\n\n/**\n * Gets the X-Component name.\n *\n * @param component - The x-component to get its name.\n * @returns The x-module name if the component is an x-component, or `null` if it is not an\n * x-component.\n * @internal\n */\nexport function getXComponentXModuleName(component: Vue | undefined): XModuleName | null {\n  return component?.$options.xModule ?? null;\n}\n\n/**\n * Returns if the component is an X-Component. An X-Component is a component that has an\n * {@link XModule} associated to it.\n *\n * @param component - The component to check if it is an X-Component.\n * @returns A boolean which flags if a component is a X-Component.\n * @public\n */\nexport function isXComponent(component: Vue): boolean {\n  return !!getXComponentXModuleName(component);\n}\n","import Vue, { ComponentOptions } from 'vue';\nimport { Store } from 'vuex';\nimport { XBus } from '@empathyco/x-bus';\nimport { getXComponentXModuleName, isXComponent } from '../components/x-component.utils';\nimport { RootXStoreState } from '../store/store.types';\nimport { XEvent, XEventPayload, XEventsTypes } from '../wiring/events.types';\nimport { WireMetadata } from '../wiring/wiring.types';\nimport { FeatureLocation } from '../types/origin';\nimport { XModuleName } from '../x-modules/x-modules.types';\nimport { getAliasAPI } from './x-plugin.alias';\nimport { XComponentAPI, XComponentBusAPI } from './x-plugin.types';\n\ndeclare module 'vue/types/vue' {\n  export interface Vue {\n    $x: XComponentAPI;\n  }\n}\n\ndeclare module 'vue/types/options' {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  export interface ComponentOptions<V, Data, Methods, Computed, PropsDef, Props> {\n    xModule?: XModuleName;\n  }\n}\n\ninterface PrivateExtendedVueComponent extends Vue {\n  $location?: FeatureLocation;\n  $store: Store<{ x: Partial<RootXStoreState['x']> }>;\n  xComponent: Vue | undefined;\n}\n\n/**\n * Vue global mixin that adds a `$x` object to every component with the {@link XComponentAPI}.\n *\n * @remarks It adds an injection property `origin` which value is included in the metadata of each\n * event emitted with `$x.emit`.\n *\n * @param bus - The {@link @empathyco/x-bus#XBus} to use inside the components for emitting events.\n * @returns Mixin options which registers the component as X-Component and the $x.\n * @internal\n */\nexport const createXComponentAPIMixin = (\n  bus: XBus<XEventsTypes, WireMetadata>\n): ComponentOptions<Vue> & ThisType<PrivateExtendedVueComponent> => ({\n  inject: {\n    $location: {\n      from: 'location',\n      default: undefined\n    }\n  },\n  beforeCreate(this: PrivateExtendedVueComponent) {\n    this.xComponent = getRootXComponent(this);\n    const aliasAPI = getAliasAPI(this);\n    const busAPI = getBusAPI(bus, this);\n    this.$x = Object.assign(aliasAPI, busAPI);\n  }\n});\n\n/**\n * Creates an object containing the API related to the {@link @empathyco/x-bus#XBus}.\n *\n * @param bus - The global {@link @empathyco/x-bus#XBus}.\n * @param component - The component instance.\n *\n * @returns An object containing the {@link XComponentBusAPI}.\n * @internal\n */\nexport function getBusAPI(\n  bus: XBus<XEventsTypes, WireMetadata>,\n  component: PrivateExtendedVueComponent\n): XComponentBusAPI {\n  return {\n    emit: <Event extends XEvent>(\n      event: Event,\n      payload?: XEventPayload<Event>,\n      metadata: Omit<WireMetadata, 'moduleName'> = {}\n    ) => {\n      bus.emit(event, payload as XEventPayload<Event>, createWireMetadata(component, metadata));\n      component.xComponent?.$emit(event, payload);\n    },\n    on: bus.on.bind(bus)\n  };\n}\n\n/**\n * Creates a wire metadata object based on the component and the provided metadata.\n *\n * @param component - The component this metadata belongs to.\n * @param metadata - Additional metadata emitted by the component.\n * @returns A {@link WireMetadata} object.\n * @internal\n */\nfunction createWireMetadata(\n  component: PrivateExtendedVueComponent,\n  metadata: Partial<WireMetadata>\n): WireMetadata {\n  return Object.defineProperties(\n    {\n      replaceable: true,\n      moduleName: getXComponentXModuleName(component.xComponent),\n      location: component.$location,\n      ...metadata\n    },\n    {\n      component: {\n        value: component,\n        /* FIX-ME: defining component as a non-enumerable property to ease tests changes due to\n         * cyclic dependencies in Vue component instances. */\n        enumerable: false\n      }\n    }\n  );\n}\n\n/**\n * Given a component, finds the root XComponent in the ancestors hierarchy.\n *\n * @param component - The component to find its root XComponent.\n * @returns The root XComponent or undefined if it has not.\n * @public\n */\nexport function getRootXComponent(component: Vue): Vue | undefined {\n  let xComponent: Vue | undefined;\n  let currentComponent: Vue | null = component;\n  while (currentComponent != null) {\n    if (isXComponent(currentComponent)) {\n      xComponent = currentComponent;\n    }\n    currentComponent = currentComponent.$parent;\n  }\n  return xComponent;\n}\n","import Vue from 'vue';\nimport { RequestStatus } from '../store/utils/status-store.utils';\nimport {\n  XComponentAliasAPI,\n  XComponentAliasQueryAPI,\n  XComponentAliasStatusAPI\n} from './x-plugin.types';\nimport { getGetterPath } from './x-plugin.utils';\n\n/**\n * Creates an object containing the alias part of {@link XComponentAPI}.\n *\n * @param component - The component with the store from which retrieve the data.\n * @returns An object containing the alias part of the {@link XComponentAPI}.\n *\n * @internal\n */\nexport function getAliasAPI(component: Vue): XComponentAliasAPI {\n  const queryModules = [\n    'facets',\n    'searchBox',\n    'nextQueries',\n    'querySuggestions',\n    'relatedTags',\n    'search'\n  ] as const;\n  const statusModules = [\n    'identifierResults',\n    'nextQueries',\n    'popularSearches',\n    'querySuggestions',\n    'recommendations',\n    'relatedTags',\n    'search'\n  ] as const;\n\n  const query = queryModules.reduce((acc, moduleName) => {\n    return Object.defineProperty(acc, moduleName, {\n      get(): string {\n        return component.$store.state.x[moduleName]?.query ?? '';\n      },\n      enumerable: true\n    });\n  }, {} as XComponentAliasQueryAPI);\n  const status = statusModules.reduce((acc, moduleName) => {\n    return Object.defineProperty(acc, moduleName, {\n      get(): RequestStatus | undefined {\n        return component.$store.state.x[moduleName]?.status;\n      },\n      enumerable: true\n    });\n  }, {} as XComponentAliasStatusAPI);\n\n  return {\n    query,\n    status,\n    get device() {\n      return component.$store.state.x.device?.name ?? null;\n    },\n    get facets() {\n      return component.$store.getters[getGetterPath('facets', 'facets')] ?? {};\n    },\n    get historyQueries() {\n      return component.$store.getters[getGetterPath('historyQueries', 'historyQueries')] ?? [];\n    },\n    get historyQueriesWithResults() {\n      return (\n        component.$store.getters[getGetterPath('historyQueries', 'historyQueriesWithResults')] ?? []\n      );\n    },\n    get fullHistoryQueries() {\n      return component.$store.state.x.historyQueries?.historyQueries ?? [];\n    },\n    get isHistoryQueriesEnabled() {\n      return component.$store.state.x.historyQueries?.isEnabled ?? false;\n    },\n    get fromNoResultsWithFilters() {\n      return component.$store.state.x.search?.fromNoResultsWithFilters ?? false;\n    },\n    get identifierResults() {\n      return component.$store.state.x.identifierResults?.identifierResults ?? [];\n    },\n    get searchBoxStatus() {\n      return component.$store.state.x.searchBox?.inputStatus ?? undefined;\n    },\n    get isEmpathizeOpen() {\n      return component.$store.state.x.empathize?.isOpen ?? false;\n    },\n    get nextQueries() {\n      return component.$store.getters[getGetterPath('nextQueries', 'nextQueries')] ?? [];\n    },\n    get noResults() {\n      return component.$store.state.x.search?.isNoResults ?? false;\n    },\n    get partialResults() {\n      return component.$store.state.x.search?.partialResults ?? [];\n    },\n    get popularSearches() {\n      return component.$store.state.x.popularSearches?.popularSearches ?? [];\n    },\n    get querySuggestions() {\n      return component.$store.getters[getGetterPath('querySuggestions', 'querySuggestions')] ?? [];\n    },\n    get fullQuerySuggestions() {\n      return component.$store.state.x.querySuggestions?.suggestions ?? [];\n    },\n    get recommendations() {\n      return component.$store.state.x.recommendations?.recommendations ?? [];\n    },\n    get redirections() {\n      return component.$store.state.x.search?.redirections ?? [];\n    },\n    get relatedTags() {\n      return component.$store.getters[getGetterPath('relatedTags', 'relatedTags')] ?? [];\n    },\n    get results() {\n      return component.$store.state.x.search?.results ?? [];\n    },\n    get scroll() {\n      return component.$store.state.x.scroll?.data ?? {};\n    },\n    get selectedFilters() {\n      return component.$store.getters[getGetterPath('facets', 'selectedFilters')] ?? [];\n    },\n    get selectedRelatedTags() {\n      return component.$store.state.x.relatedTags?.selectedRelatedTags ?? [];\n    },\n    get semanticQueries() {\n      return component.$store.state.x.semanticQueries?.semanticQueries ?? [];\n    },\n    get spellcheckedQuery() {\n      return component.$store.state.x.search?.spellcheckedQuery ?? null;\n    },\n    get totalResults() {\n      return component.$store.state.x.search?.totalResults ?? 0;\n    },\n    get selectedSort() {\n      return component.$store.state.x.search?.sort ?? '';\n    }\n  };\n}\n","import { deepMerge } from '@empathyco/x-deep-merge';\nimport { forEach, Dictionary } from '@empathyco/x-utils';\nimport { PluginObject, VueConstructor } from 'vue';\nimport Vuex, { Module, Store } from 'vuex';\nimport { XComponentsAdapter } from '@empathyco/x-types';\nimport { EventPayload, SubjectPayload, XBus } from '@empathyco/x-bus';\nimport { Observable } from 'rxjs';\nimport { AnyXStoreModule, RootXStoreState } from '../store/store.types';\nimport { cleanGettersProxyCache } from '../store/utils/getters-proxy.utils';\nimport { RootXStoreModule } from '../store/x.module';\nimport { XEvent, XEventsTypes } from '../wiring/events.types';\nimport { AnyWire, WireMetadata } from '../wiring/wiring.types';\nimport { AnyXModule, XModuleName } from '../x-modules/x-modules.types';\nimport { sendWiringToDevtools } from './devtools/wiring.devtools';\nimport { bus } from './x-bus';\nimport { registerStoreEmitters } from './x-emitters';\nimport { createXComponentAPIMixin } from './x-plugin.mixin';\nimport { AnyXStoreModuleOption, XModuleOptions, XPluginOptions } from './x-plugin.types';\nimport { assertXPluginOptionsAreValid } from './x-plugin.utils';\n\n/**\n * Vue plugin that initializes the properties needed by the x-components, and exposes the events bus\n * and the adapter after it has been installed.\n *\n * @public\n */\nexport class XPlugin implements PluginObject<XPluginOptions> {\n  /**\n   * {@link @empathyco/x-typesm#XComponentsAdapter | XComponentsAdapter} Is the middleware\n   * between the components and our API where data can be mapped to client needs.\n   * This property is only available after installing the plugin.\n   *\n   * @returns The installed adapter.\n   * @throws If this property is accessed before calling `Vue.use(xPlugin)`.\n   * @public\n   */\n  public static get adapter(): XComponentsAdapter {\n    return this.getInstance().adapter;\n  }\n\n  /**\n   * Exposed {@link @empathyco/x-bus#XBus}, so any kind of application can subscribe to\n   * {@link XEventsTypes} without having to pass through a component.\n   * This property is only available after installing the plugin.\n   *\n   * @returns The installed bus.\n   * @throws If this property is accessed before calling `Vue.use(xPlugin)`.\n   * @public\n   */\n  public static get bus(): XBus<XEventsTypes, WireMetadata> {\n    return this.getInstance().bus;\n  }\n\n  /**\n   * {@link https://vuex.vuejs.org | Vuex Store} Is the place where all shared data\n   * is saved.\n   *\n   * @returns The installed store.\n   * @throws If this property is accessed before calling `Vue.use(xPlugin)`.\n   * @public\n   */\n  public static get store(): Store<RootXStoreState> {\n    return this.getInstance().store;\n  }\n\n  /**\n   * Safely retrieves the installed instance of the XPlugin.\n   *\n   * @returns The installed instance of the XPlugin.\n   * @throws If this method is called before calling `Vue.use(xPlugin)`.\n   * @internal\n   */\n  protected static getInstance(): XPlugin {\n    if (!this.instance) {\n      throw Error(\"XPlugin must be installed before accessing it's API.\");\n    }\n    return this.instance;\n  }\n\n  /**\n   * Record of modules that have been tried to be installed before the installation of the plugin.\n   *\n   * @internal\n   */\n  protected static pendingXModules: Partial<Record<XModuleName, AnyXModule>> = {};\n\n  /**\n   * Instance of the installed plugin. Used to expose the bus and the adapter.\n   *\n   * @internal\n   */\n  protected static instance?: XPlugin;\n\n  public wiring: Partial<Record<XModuleName, Partial<Record<XEvent, string[]>>>> = {};\n  /**\n   * Bus for retrieving the observables when registering the wiring.\n   *\n   * @internal\n   */\n  protected bus: XBus<XEventsTypes, WireMetadata>;\n\n  /**\n   * Adapter for the API, responsible for transforming requests and responses.\n   *\n   * @internal\n   */\n  protected adapter!: XComponentsAdapter;\n\n  /**\n   * Set of the already installed {@link XModule | XModules} to avoid re-registering them.\n   *\n   * @internal\n   */\n  protected installedXModules = new Set<string>();\n\n  /**\n   * True if the plugin has been installed in a Vue instance, in this case\n   * {@link XModule |Xmodules} will be installed immediately. False otherwise, in this case\n   * {@link XModule | XModules} will be installed lazily when the {@link XPlugin#install} method\n   * is called.\n   *\n   * @internal\n   */\n  protected isInstalled = false;\n\n  /**\n   * The installation options of the plugin, where all the customization of\n   * {@link XModule | XModules} is done.\n   *\n   * @internal\n   */\n  protected options!: XPluginOptions;\n\n  /**\n   * The Vuex store, to pass to the wires for its registration, and to register the store\n   * modules on it.\n   *\n   * @internal\n   */\n  protected store!: Store<any>;\n  /**\n   * The global Vue, passed by the installation method. Used to apply the global mixin\n   * {@link createXComponentAPIMixin}, and install the {@link https://vuex.vuejs.org/ | Vuex}\n   * plugin.\n   *\n   * @internal\n   */\n  protected vue!: VueConstructor;\n\n  /**\n   * Creates a new instance of the XPlugin with the given bus passed as parameter.\n   *\n   * @param bus - The {@link @empathyco/x-bus#XBus} implementation to use for the plugin.\n   *\n   * @public\n   */\n  public constructor(bus: XBus<XEventsTypes, WireMetadata>) {\n    this.bus = bus;\n  }\n\n  /**\n   * If the plugin has already been installed, it immediately registers a {@link XModule}. If it\n   * has not been installed yet, it stores the module in a list until the plugin is installed.\n   *\n   * @param xModule - The module to register.\n   *\n   * @public\n   */\n  static registerXModule(xModule: AnyXModule): void {\n    if (this.instance) {\n      this.instance.registerXModule(xModule);\n    } else {\n      this.lazyRegisterXModule(xModule);\n    }\n  }\n\n  /**\n   * Utility method for resetting the installed instance of the plugin.\n   *\n   * @remarks Use only for testing.\n   *\n   * @internal\n   */\n  static resetInstance(): void {\n    cleanGettersProxyCache();\n    this.instance = undefined;\n  }\n\n  /**\n   * Stores the {@link XModule} in a dictionary, so it can be registered later in the installation\n   * process.\n   *\n   * @param xModule - The module to register.\n   *\n   * @internal\n   */\n  protected static lazyRegisterXModule(xModule: AnyXModule): void {\n    this.pendingXModules[xModule.name] = xModule;\n  }\n\n  /**\n   * Installs the plugin into the Vue instance.\n   *\n   * @param vue - The GlobalVue object.\n   * @param options - The options to install this plugin with.\n   * @throws If the XPlugin has already been installed, or the options are not valid.\n   *\n   * @internal\n   */\n  install(vue: VueConstructor, options?: XPluginOptions): void {\n    if (this.isInstalled) {\n      throw new Error('XPlugin has already been installed');\n    }\n    assertXPluginOptionsAreValid(options);\n    XPlugin.instance = this;\n    this.vue = vue;\n    this.options = options;\n    this.adapter = options.adapter;\n    this.registerStore();\n    this.applyMixins();\n    this.registerInitialModules();\n    this.registerPendingXModules();\n    this.isInstalled = true;\n  }\n\n  /**\n   * Performs the registration of a {@link XModule}.\n   *\n   * @param xModule - The module to register.\n   *\n   * @internal\n   */\n  protected registerXModule(xModule: AnyXModule): void {\n    if (!this.installedXModules.has(xModule.name)) {\n      const customizedXModule = this.customizeXModule(xModule);\n      this.registerStoreModule(customizedXModule);\n      this.registerStoreEmitters(customizedXModule);\n      this.registerWiring(customizedXModule);\n      // The wiring must be registered after the store emitters\n      // to allow lazy loaded modules work properly.\n      this.installedXModules.add(xModule.name);\n      this.bus.emit('ModuleRegistered', xModule.name);\n    }\n  }\n\n  /**\n   * Performs a customization of a {@link XModule} using the XPlugin public and private options.\n   *\n   * @param xModule - The module to customize.\n   * @returns The customized xModule.\n   *\n   * @internal\n   */\n  protected customizeXModule({\n    name,\n    wiring,\n    storeModule,\n    storeEmitters,\n    ...restXModule\n  }: AnyXModule): AnyXModule {\n    const { wiring: wiringOptions, config }: XModuleOptions<XModuleName> =\n      this.options.xModules?.[name] ?? {};\n\n    const { storeModule: storeModuleOptions, storeEmitters: emittersOptions } =\n      this.options.__PRIVATE__xModules?.[name] ?? {};\n\n    return {\n      name,\n      wiring: wiringOptions ? deepMerge({}, wiring, wiringOptions) : wiring,\n      storeModule: this.customizeStoreModule(storeModule, storeModuleOptions ?? {}, config),\n      storeEmitters: emittersOptions\n        ? deepMerge({}, storeEmitters, emittersOptions)\n        : storeEmitters,\n      ...restXModule\n    };\n  }\n\n  /**\n   * Performs the registration of the wiring, retrieving the observable for each event, and\n   * executing each wire.\n   *\n   * @param xModule - The {@link XModule} to register its wiring.\n   *\n   * @internal\n   */\n  protected registerWiring({ wiring, name }: AnyXModule): void {\n    sendWiringToDevtools(name, wiring);\n    forEach(wiring, (event, wires: Dictionary<AnyWire>) => {\n      // Obtain the observable\n      const observable = this.bus.on(event, true) as unknown as Observable<\n        SubjectPayload<EventPayload<XEventsTypes, typeof event>, WireMetadata>\n      >;\n      // Register event wires\n      forEach(wires, (_, wire) => {\n        wire(observable, this.store as Store<RootXStoreState>, this.bus.on.bind(this.bus));\n      });\n    });\n  }\n\n  /**\n   * Registers a {@link https://vuex.vuejs.org/ | Vuex} store module under the 'x' module.\n   *\n   * @param xModule - The {@link XModule} to register its Store Module.\n   *\n   * @internal\n   */\n  protected registerStoreModule({ name, storeModule }: AnyXModule): void {\n    (storeModule as Module<any, any>).namespaced = true;\n    this.store.registerModule(['x', name], storeModule);\n  }\n\n  /**\n   * Overrides a {@link https://vuex.vuejs.org/ | Vuex} store module definition.\n   *\n   * Priority of configuration merging.\n   * 1st {@link XPluginOptions.xModules | xModules XPlugin option}.\n   * 2nd {@link XPluginOptions.__PRIVATE__xModules | Private xModules XPlugin option}.\n   * 3rd {@link XStoreModule.state | Default state of the xModule}.\n   *\n   * @param defaultModule - The default store module to override.\n   * @param moduleOptions - The state, actions, mutations and getters to override the defaultModule.\n   * @param configOptions - The state config to override the moduleOptions.\n   * @returns The {@link XStoreModule} customized.\n   *\n   * @internal\n   */\n  protected customizeStoreModule(\n    { state: defaultState, ...actionsGettersMutations }: AnyXStoreModule,\n    { state: xModuleState, ...newActionsGettersMutations }: AnyXStoreModuleOption,\n    configOptions: unknown\n  ): AnyXStoreModule {\n    const configOptionsObject = configOptions ? { config: configOptions } : {};\n    const customizedModule = deepMerge({}, actionsGettersMutations, newActionsGettersMutations);\n    customizedModule.state = deepMerge(defaultState(), xModuleState, configOptionsObject);\n    return customizedModule;\n  }\n\n  /**\n   * Registers the store emitters, making them emit the event when the part of the state selected\n   * changes.\n   *\n   * @param xModule - The {@link XModule} to register its Store Emitters.\n   *\n   * @internal\n   */\n  protected registerStoreEmitters(xModule: AnyXModule): void {\n    registerStoreEmitters(xModule, this.bus, this.store);\n  }\n\n  /**\n   * Registers the {@link https://vuex.vuejs.org/ | Vuex} store. If the store has not been passed\n   * through the {@link XPluginOptions} object, it creates one, and injects it in the Vue\n   * prototype. Then it registers an x module in the store, to safe scope all the\n   * {@link XModule | XModules} dynamically installed.\n   *\n   * @internal\n   */\n  protected registerStore(): void {\n    this.vue.use(Vuex); // We can safely install Vuex because if it is already installed Vue\n    // will simply ignore it\n    this.store =\n      this.options.store ??\n      new Store({\n        strict: process.env.NODE_ENV !== 'production'\n      });\n    if (!this.options.store) {\n      this.vue.prototype.$store = this.store;\n    }\n    this.store.registerModule('x', RootXStoreModule);\n  }\n\n  /**\n   * Applies the {@link createXComponentAPIMixin} mixin in the global Vue.\n   *\n   * @internal\n   */\n  protected applyMixins(): void {\n    this.vue.mixin(createXComponentAPIMixin(this.bus));\n  }\n\n  /**\n   * Registers the initial {@link XModule | XModules} during the {@link XPlugin} installation.\n   *\n   * @internal\n   */\n  protected registerInitialModules(): void {\n    this.options.initialXModules?.forEach(xModule => {\n      this.registerXModule(xModule);\n    });\n  }\n\n  /**\n   * Registers the pending {@link XModule | XModules}, that requested to be registered before the\n   * installation of the plugin.\n   *\n   * @internal\n   */\n  protected registerPendingXModules(): void {\n    forEach(XPlugin.pendingXModules, (_, xModule) => {\n      this.registerXModule(xModule);\n    });\n    XPlugin.pendingXModules = {};\n  }\n}\n\n/**\n * Vue plugin that modifies each component instance, extending them with the\n * {@link XComponentAPI | X Component API }.\n *\n * @example\n * Minimal installation example. An API adapter is needed to connect the X Components with the\n * suggestions, search, or tagging APIs. In this example we are using the default Empathy's platform\n * adapter.\n *\n * ```typescript\n *  import { platformAdapter } from '@empathyco/x-adapter-platform';\n *  Vue.use(xPlugin, { adapter: platformAdapter });\n * ```\n *\n * @example\n * If you are using {@link https://vuex.vuejs.org/ | Vuex} in your project you must install its\n *   plugin, and instantiate a store before installing the XPlugin:\n * ```typescript\n * Vue.use(Vuex);\n * const store = new Store({ ... });\n * Vue.use(xPlugin, { adapter, store });\n * ```\n * @public\n */\nexport const xPlugin = new XPlugin(bus);\n","import Vue, { ComponentOptions } from 'vue';\nimport { XPlugin } from '../plugins/x-plugin';\nimport { AnyXModule } from '../x-modules/x-modules.types';\n\n/**\n * Initializes a component as an X-Component:\n * * Registers the module passed as parameter.\n * * Flags the component as X-Component, so then it can be detected with the {@link isXComponent}\n * function.\n *\n * @param module - The module associated to the X-Component using this mixin.\n * @returns Mixin for the module.\n * @public\n */\nexport function xComponentMixin(module: AnyXModule): ComponentOptions<Vue> {\n  XPlugin.registerXModule(module);\n  return {\n    xModule: module.name\n  };\n}\n","import { Dictionary } from '@empathyco/x-utils';\nimport { WatchOptions } from 'vue';\nimport { Returns } from '../../utils/types';\nimport { XEvent, XEventPayload } from '../../wiring/events.types';\nimport { AnyXStoreModule } from '../store.types';\nimport { WireMetadata } from '../../wiring/wiring.types';\n\n/**\n * Selects a part of the store state or getters (AKA \"getter\" inside\n * {@link https://vuex.vuejs.org/ | Vuex} watchers).\n *\n * @param ReturnType - The type of the state or getters property selected.\n * @param State - The type of the state of the {@link XModule} where this selector is used.\n * @param Getters - The type of the getters of the {@link XModule} where this selector is used.\n * @public\n */\nexport type SimpleStateSelector<\n  ReturnType,\n  State extends Dictionary,\n  Getters extends Dictionary\n> = (state: State, getters: Getters) => ReturnType;\n\n/**\n * Composition type of {@link SimpleStateSelector} which allows to indicate if the state selector\n * should be executed in first instance (first assignment of values). Selector is the\n * {@link SimpleStateSelector} and immediate flags if the selector should be executed when it is\n * initialized for first time.\n *\n * @param ReturnType - The type of the state or getters property selected.\n * @param State - The type of the state of the {@link XModule} where this selector is used.\n * @param Getters - The type of the getters of the {@link XModule} where this selector is used.\n * @public\n */\nexport interface StateSelector<ReturnType, State extends Dictionary, Getters extends Dictionary>\n  extends WatchOptions {\n  selector: SimpleStateSelector<ReturnType, State, Getters>;\n  /**\n   * Checks if the value of the selector has changed.\n   *\n   * @remarks\n   * This function exist because Vue will not stop reactivity propagation if the observed variable\n   * is an `object`, an `Array`, or the `deep` mode has been enabled.\n   *\n   * @param newValue - The new value.\n   * @param oldValue - The old value.\n   * @returns True if the value has really changed.\n   */\n  filter?(newValue: ReturnType, oldValue: ReturnType): boolean;\n  metadata?: Partial<WireMetadata>;\n}\n\n/**\n * Dictionary where the key is a {@link XEvent}, and the value is {@link SimpleStateSelector} or\n * {@link StateSelector}. This {@link SimpleStateSelector} or {@link StateSelector} can only\n * access the state and getters from the {@link XStoreModule} passed as param type. This\n * dictionary is used to emits a {@link XEvent} when the part of the store selected by\n * {@link SimpleStateSelector} changes.\n *\n * @param StoreModule - The store module that these store emitters will be able to access.\n * @public\n */\nexport type StoreEmitters<StoreModule extends AnyXStoreModule> = {\n  [Event in XEvent]?:\n    | SimpleStateSelector<\n        XEventPayload<Event>,\n        ReturnType<StoreModule['state']>,\n        Returns<StoreModule['getters']>\n      >\n    | StateSelector<\n        XEventPayload<Event>,\n        ReturnType<StoreModule['state']>,\n        Returns<StoreModule['getters']>\n      >;\n};\n/**\n * Alias for any simple state selector.\n *\n * @public\n */\nexport type AnySimpleStateSelector = SimpleStateSelector<any, any, any>;\n/**\n * Alias for any state selector.\n *\n * @public\n */\nexport type AnyStateSelector = StateSelector<any, any, any>;\n/**\n * Alias for any store emitters.\n *\n * @public\n */\nexport type AnyStoreEmitters = StoreEmitters<AnyXStoreModule>;\n\n/**\n * Helper function for creating type-safe {@link StoreEmitters}.\n *\n * @param storeModule - The store module that the emitters will be associated to.\n * @param emitters - The {@link StoreEmitters} to create.\n * @returns A type-safe function for storeEmitters.\n * @public\n */\nexport function createStoreEmitters<\n  Module extends AnyXStoreModule,\n  Emitters extends StoreEmitters<Module>\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n>(storeModule: Module, emitters: Emitters): Emitters {\n  return emitters;\n}\n","import { Store } from 'vuex';\nimport { RootXStoreState } from '../store/store.types';\nimport { MonadicFunction, NiladicFunction, SubObject } from '../utils/index';\nimport {\n  AnyWire,\n  PayloadFactoryData,\n  Wire,\n  WireParams,\n  WirePayload,\n  WireService,\n  WireServiceWithoutPayload\n} from './wiring.types';\n\n/**\n * Creates a wire that executes the function passed. This function will receive a\n * {@link WireParams} object.\n *\n * @param fn - The function to execute whenever a new value is emitted to the observable.\n * @returns The Wire function.\n * @public\n */\nexport function createWireFromFunction<Payload>(\n  fn: (parameters: WireParams<Payload>) => void\n): Wire<Payload> {\n  return (observable, store) =>\n    observable.subscribe(({ metadata, eventPayload }) => {\n      fn({ eventPayload, store, metadata });\n    });\n}\n\n/**\n * Creates a wire that commits a mutation to the store. This wire receives a function. This function\n * is used to get the actual payload value passed to mutation.\n * This wire can be used in every event, as it does not have a payload type associated.\n *\n * @param mutation - The full mutation path to commit. I.e. `x/searchBox/setQuery`.\n * @param payloadFactory - A function that receives a {@link PayloadFactoryData | object}\n * with the Store state, getters, payload and metadata as parameter.\n * @returns A {@link AnyWire} wire that commits the mutation with the payload returned by the\n * payloadFactory.\n * @public\n */\nexport function wireCommit<Payload>(\n  mutation: string,\n  payloadFactory: (params: PayloadFactoryData<Payload>) => any\n): AnyWire;\n/**\n * Creates a wire that commits a mutation to the store. This wire can receive any value as payload.\n * This wire can be used in every event, as it does not have a payload type associated.\n *\n * @param mutation - The full mutation path to commit. I.e. `x/searchBox/setQuery`.\n * @param staticPayload - A static payload to pass to the mutation.\n * @returns {@link AnyWire} A wire that commits the mutation with the staticPayload payload.\n * @public\n */\nexport function wireCommit(mutation: string, staticPayload: any): AnyWire;\n/**\n * Creates a wire that commits a mutation to the store. This wire will commit to the store the\n * payload that it receives in the observable.\n *\n * @param mutation - The full mutation path to commit. I.e. `x/searchBox/setQuery`.\n * @typeParam Payload - The type of the payload that this wire will receive\n * @returns {@link Wire} A wire that commits the mutation with the payload that it receives\n * in the observable.\n * @public\n */\nexport function wireCommit<Payload>(mutation: string): Wire<Payload>;\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function wireCommit<Payload>(mutation: string, payload?: Payload): Wire<Payload> {\n  return (observable, store) =>\n    observable.subscribe(createSubscriptionCallback(store, 'commit', mutation, payload));\n}\n\n/**\n * Creates a wire that commits a mutation to the store, but without any payload. This wire can\n * be used in every event, as it does not have a payload type associated.\n *\n * @param mutation - The full mutation path to commit. I.e. `x/searchBox/setQuery`.\n * @returns {@link AnyWire} A wire that commits the mutation without any payload.\n * @public\n */\nexport function wireCommitWithoutPayload(mutation: string): AnyWire {\n  return (observable, store) => observable.subscribe(() => store.commit(mutation));\n}\n\n/**\n * Creates a wire that dispatch an action to the store. This wire receives a function. This function\n * is used to get the actual payload value passed to action.\n * This wire can be used in every event, as it does not have a payload type associated.\n *\n * @param action - The full action path to dispatch. I.e. `x/querySuggestions/fetchSuggestions`.\n * @param payloadFactory - A function that receives a {@link PayloadFactoryData | object}\n * with the Store state, getters, payload and metadata as parameter.\n * @returns A {@link AnyWire} wire that dispatches the action with the payload returned by the\n * payloadFactory.\n * @public\n */\nexport function wireDispatch<Payload>(\n  action: string,\n  payloadFactory: (params: PayloadFactoryData<Payload>) => any\n): AnyWire;\n/**\n * Creates a wire that dispatches an action to the store. This wire can be used in every event,\n * as it does not have a payload type associated.\n *\n * @param action - The full action path to dispatch. I.e. `x/querySuggestions/fetchSuggestions`.\n * @param staticPayload - A static payload to pass to the action which will be dispatched.\n * @returns {@link AnyWire} A wire that dispatches the action with the staticPayload payload.\n * @public\n */\nexport function wireDispatch(action: string, staticPayload: any): AnyWire;\n/**\n * Creates a wire that dispatches an action to the store. This wire will pass the payload\n * received in the observable to the action.\n *\n * @param action - The full action path to dispatch. I.e. `x/querySuggestions/fetchSuggestions`.\n * @typeParam Payload - The type of the payload that this wire will receive\n * @returns {@link Wire} A wire that dispatches the action with the payload that it receives\n * in the observable.\n * @public\n */\nexport function wireDispatch<Payload>(action: string): Wire<Payload>;\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function wireDispatch<Payload>(action: string, payload?: Payload): Wire<Payload> {\n  return (observable, store) =>\n    observable.subscribe(createSubscriptionCallback(store, 'dispatch', action, payload));\n}\n\n/**\n * Creates a wire that dispatches an action to the store, but without any payload. This wire can\n * be used in every event, as it does not have a payload type associated.\n *\n * @param action - The full action path to dispatch. I.e. `x/querySuggestions/fetchSuggestions`.\n * @returns {@link AnyWire} A wire that dispatches the action without any payload.\n * @public\n */\nexport function wireDispatchWithoutPayload(action: string): AnyWire {\n  return (observable, store) => observable.subscribe(() => store.dispatch(action));\n}\n\n/**\n * Creates a wires factory that can create wires that will invoke the service methods.\n *\n * @param service - The service to invoke its methods.\n * @returns A factory to create wires that invoke the service methods.\n * @public\n */\nexport function wireService<SomeService>(\n  service: SomeService & SubObject<SomeService, MonadicFunction>\n): WireService<SubObject<SomeService, MonadicFunction>> {\n  return (method, payload?) => {\n    return observable =>\n      observable.subscribe(\n        payload !== undefined\n          ? () => service[method](payload)\n          : observablePayload => service[method](observablePayload.eventPayload)\n      );\n  };\n}\n\n/**\n * Creates a wires factory that can create wires that will invoke the service methods but\n * without payload.\n *\n * @param service - The service to invoke its methods.\n * @returns A factory to create wires that invoke the service methods without payload.\n * @public\n */\nexport function wireServiceWithoutPayload<SomeService>(\n  service: SomeService & SubObject<SomeService, NiladicFunction>\n): WireServiceWithoutPayload<SubObject<SomeService, NiladicFunction>> {\n  return method => {\n    return observable => observable.subscribe(() => service[method]());\n  };\n}\n\n/**\n * Creates the callback function for the {@link wireCommit} and {@link wireDispatch}\n * subscriptions. It can be based on the payload as function which retrieves the observable\n * payload from the store, a static payload or the event value from the observable.\n *\n * @param store - The {@link RootXStoreState} store.\n * @param commitOrDispatch - The executor over store. It can be `commit` or `dispatch`.\n * @param mutationOrAction - The mutation or action to commit or dispatch respectively.\n * @param payload - The payload for the store executor. It can be a function which retrieves the\n * payload from the store, a static payload or the event value from the observable.\n * @typeParam Payload - The type of the payload to get the observable event value type.\n * @returns A function to commit or dispatch a payload value over store.\n * @internal\n */\nfunction createSubscriptionCallback<Payload>(\n  store: Store<RootXStoreState>,\n  commitOrDispatch: 'commit' | 'dispatch',\n  mutationOrAction: string,\n  payload?: Payload\n): (observableValue: WirePayload<Payload>) => void {\n  const storeExecutor = store[commitOrDispatch];\n  return typeof payload === 'function'\n    ? wirePayload => {\n        return storeExecutor(\n          mutationOrAction,\n          payload({\n            state: store.state,\n            getters: store.getters,\n            ...wirePayload\n          })\n        );\n      }\n    : payload !== undefined\n    ? () => {\n        storeExecutor(mutationOrAction, payload);\n      }\n    : observableValue => {\n        storeExecutor(mutationOrAction, observableValue.eventPayload);\n      };\n}\n","import { Store } from 'vuex';\nimport { RootXStoreState, StoreModuleStateAndGetters } from '../store/store.types';\nimport { getGettersProxy } from '../store/utils/getters-proxy.utils';\nimport { ExtractState, XModuleName } from '../x-modules/x-modules.types';\nimport { Wiring } from './wiring.types';\n\n/**\n * Util function to generate type-safe wiring.\n * If TypeScript ever accepts the PR about generic type inference this function can be removed.\n *\n * @param wiring - The wiring to create.\n * @returns Type-safe wiring.\n *\n * @public\n */\nexport function createWiring<T extends Partial<Wiring>>(wiring: T): T {\n  return wiring;\n}\n\n/**\n * Returns an object with the getters and state of a module of store defined by the moduleName\n * parameter.\n *\n * @param state - The Vuex store State.\n * @param getters - The Vuex store Getters.\n * @param moduleName - The {@link XModuleName} of the module.\n * @returns The {@link StoreModuleStateAndGetters} with the Getters and the State of the\n * {@link XStoreModule | Store Module} defined by moduleName.\n *\n * @public\n */\nexport function getStateAndGettersFromModule<ModuleName extends XModuleName>(\n  state: RootXStoreState,\n  getters: Pick<Store<any>, 'getters'>,\n  moduleName: ModuleName\n): StoreModuleStateAndGetters<ModuleName> {\n  return {\n    state: state.x[moduleName] as unknown as ExtractState<ModuleName>,\n    getters: getGettersProxy(getters, moduleName)\n  };\n}\n","import { XModuleName } from '../x-modules/x-modules.types';\nimport {\n  NamespacedWireCommit,\n  NamespacedWireCommitWithoutPayload,\n  NamespacedWireDispatch,\n  NamespacedWireDispatchWithoutPayload\n} from './namespaced-wiring.types';\nimport {\n  wireCommit,\n  wireCommitWithoutPayload,\n  wireDispatch,\n  wireDispatchWithoutPayload\n} from './wires.factory';\nimport { PayloadFactoryData } from './wiring.types';\nimport { getStateAndGettersFromModule } from './wiring.utils';\n\n/**\n * Creates a namespaced {@link (wireCommit:1)} for the module name passed.\n *\n * @param moduleName - The module name for scoping the {@link (wireCommit:1)}.\n * @returns A function which creates a namespaced wire for the {@link (wireCommit:1)}.\n *\n * @public\n */\nexport function namespacedWireCommit<ModuleName extends XModuleName>(\n  moduleName: ModuleName\n): NamespacedWireCommit<ModuleName> {\n  return (mutation: string, payload?: unknown) =>\n    wireCommit(`x/${moduleName}/${mutation}`, getPayload(moduleName, payload));\n}\n\n/**\n * Creates a namespaced {@link wireCommitWithoutPayload} for the module name passed.\n *\n * @param moduleName - The module name for scoping the {@link wireCommitWithoutPayload}.\n * @returns A function which creates a namespaced wire for the {@link wireCommitWithoutPayload}.\n *\n * @public\n */\nexport function namespacedWireCommitWithoutPayload<ModuleName extends XModuleName>(\n  moduleName: ModuleName\n): NamespacedWireCommitWithoutPayload<ModuleName> {\n  return mutation => wireCommitWithoutPayload(`x/${moduleName}/${mutation as string}`);\n}\n\n/**\n * Creates a namespaced {@link (wireDispatch:1)} for the module name passed.\n *\n * @param moduleName - The module name for scoping the {@link (wireDispatch:1)}.\n * @returns A function which creates a namespaced wire for the {@link (wireDispatch:1)}.\n *\n * @public\n */\nexport function namespacedWireDispatch<ModuleName extends XModuleName>(\n  moduleName: ModuleName\n): NamespacedWireDispatch<ModuleName> {\n  return (action: string, payload?: unknown) =>\n    wireDispatch(`x/${moduleName}/${action}`, getPayload(moduleName, payload));\n}\n\n/**\n * Creates a namespaced {@link wireDispatchWithoutPayload} for the module name passed.\n *\n * @param moduleName - The module name for scoping the {@link wireDispatchWithoutPayload}.\n * @returns A function which creates a namespaced wire for the {@link wireDispatchWithoutPayload}.\n *\n * @public\n */\nexport function namespacedWireDispatchWithoutPayload<ModuleName extends XModuleName>(\n  moduleName: ModuleName\n): NamespacedWireDispatchWithoutPayload<ModuleName> {\n  return action => wireDispatchWithoutPayload(`x/${moduleName}/${action as string}`);\n}\n\n/**\n * Decision maker of if the payload is a function which receives the\n * {@link StoreModuleStateAndGetters | module state and getters}, the payload and the metadata,\n * returns the payload for or a static value.\n *\n * @param moduleName - The {@link XModuleName | module name} for scoping the state and getters.\n * @param payload - The payload for the wire which can be a retrieving function or a static value.\n * @returns The function which will retrieve data from the store or the static value.\n *\n * @internal\n */\nfunction getPayload(moduleName: XModuleName, payload: unknown): unknown {\n  return typeof payload === 'function'\n    ? ({ state, getters, eventPayload, metadata }: PayloadFactoryData<XModuleName>) =>\n        payload({\n          ...getStateAndGettersFromModule(state, getters, moduleName),\n          eventPayload,\n          metadata\n        })\n    : payload;\n}\n","import { shallowRef, watchEffect, readonly, ref, watch, customRef, getCurrentScope, onScopeDispose, effectScope, provide, inject, isVue3, version, isRef, unref, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, isVue2, set as set$1, getCurrentInstance, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';\n\nvar __defProp$b = Object.defineProperty;\nvar __defProps$8 = Object.defineProperties;\nvar __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$d = Object.getOwnPropertySymbols;\nvar __hasOwnProp$d = Object.prototype.hasOwnProperty;\nvar __propIsEnum$d = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$b = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$d.call(b, prop))\n      __defNormalProp$b(a, prop, b[prop]);\n  if (__getOwnPropSymbols$d)\n    for (var prop of __getOwnPropSymbols$d(b)) {\n      if (__propIsEnum$d.call(b, prop))\n        __defNormalProp$b(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, __spreadProps$8(__spreadValues$b({}, options), {\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  }));\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\" });\n  const get = typeof fn === \"function\" ? fn : fn.get;\n  const set = typeof fn === \"function\" ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createEventHook() {\n  const fns = /* @__PURE__ */ new Set();\n  const off = (fn) => {\n    fns.delete(fn);\n  };\n  const on = (fn) => {\n    fns.add(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (param) => {\n    return Promise.all(Array.from(fns).map((fn) => fn(param)));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return (...args) => {\n    if (!initialized) {\n      state = scope.run(() => stateFactory(...args));\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nfunction createInjectionState(composable) {\n  const key = Symbol(\"InjectionState\");\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provide(key, state);\n    return state;\n  };\n  const useInjectedState = () => inject(key);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] extendRef only works in Vue 2.7 or above.\");\n    return;\n  }\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nvar __defProp$a = Object.defineProperty;\nvar __getOwnPropSymbols$c = Object.getOwnPropertySymbols;\nvar __hasOwnProp$c = Object.prototype.hasOwnProperty;\nvar __propIsEnum$c = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$a = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$c.call(b, prop))\n      __defNormalProp$a(a, prop, b[prop]);\n  if (__getOwnPropSymbols$c)\n    for (var prop of __getOwnPropSymbols$c(b)) {\n      if (__propIsEnum$c.call(b, prop))\n        __defNormalProp$a(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = __spreadValues$a({}, obj);\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction toValue(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nconst resolveUnref = toValue;\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : toValue;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(\n    keys.map((key) => {\n      const value = obj[key];\n      return [\n        key,\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n      ];\n    })\n  );\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(\n    () => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0])))\n  );\n}\n\nconst isClient = typeof window !== \"undefined\";\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n  var _a;\n  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /* @__PURE__ */ /iP(ad|hone|od)/.test(window.navigator.userAgent);\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  const filter = (invoke) => {\n    const duration = toValue(ms);\n    const maxDuration = toValue(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = null;\n          resolve(invoke());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = null;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(ms, trailing = true, leading = true, rejectOnCancel = false) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = toValue(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\n}\n\nconst directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?[0-9]+\\.?[0-9]*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n    return (!omitUndefined || value !== void 0) && !keys.includes(key);\n  }));\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\n\nfunction toRef(...args) {\n  if (args.length !== 1)\n    return toRef$1(...args);\n  const r = args[0];\n  return typeof r === \"function\" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);\n}\nconst resolveRef = toRef;\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = defaultValue;\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = defaultValue;\n      trigger();\n    }, toValue(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(\n    debounceFilter(ms, options),\n    fn\n  );\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\n    fn\n  );\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(\n    ref,\n    {\n      get,\n      set,\n      untrackedGet,\n      silentSet,\n      peek,\n      lay\n    },\n    { enumerable: true }\n  );\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction syncRef(left, right, options = {}) {\n  var _a, _b;\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options;\n  let watchLeft;\n  let watchRight;\n  const transformLTR = (_a = transform.ltr) != null ? _a : (v) => v;\n  const transformRTL = (_b = transform.rtl) != null ? _b : (v) => v;\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchLeft = watch(\n      left,\n      (newValue) => right.value = transformLTR(newValue),\n      { flush, deep, immediate }\n    );\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchRight = watch(\n      right,\n      (newValue) => left.value = transformRTL(newValue),\n      { flush, deep, immediate }\n    );\n  }\n  return () => {\n    watchLeft == null ? void 0 : watchLeft();\n    watchRight == null ? void 0 : watchRight();\n  };\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(\n    source,\n    (newValue) => targets.forEach((target) => target.value = newValue),\n    { flush, deep, immediate }\n  );\n}\n\nvar __defProp$9 = Object.defineProperty;\nvar __defProps$7 = Object.defineProperties;\nvar __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$9 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$b.call(b, prop))\n      __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$b)\n    for (var prop of __getOwnPropSymbols$b(b)) {\n      if (__propIsEnum$b.call(b, prop))\n        __defNormalProp$9(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));\nfunction toRefs(objectRef) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        if (Array.isArray(objectRef.value)) {\n          const copy = [...objectRef.value];\n          copy[key] = v;\n          objectRef.value = copy;\n        } else {\n          const newObject = __spreadProps$7(__spreadValues$9({}, objectRef.value), { [key]: v });\n          Object.setPrototypeOf(newObject, objectRef.value);\n          objectRef.value = newObject;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true) {\n  if (getCurrentInstance())\n    onBeforeMount(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn) {\n  if (getCurrentInstance())\n    onBeforeUnmount(fn);\n}\n\nfunction tryOnMounted(fn, sync = true) {\n  if (getCurrentInstance())\n    onMounted(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn) {\n  if (getCurrentInstance())\n    onUnmounted(fn);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        r,\n        (v) => {\n          if (condition(v) !== isNot) {\n            stop == null ? void 0 : stop();\n            resolve(v);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => stop == null ? void 0 : stop())\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        [r, value],\n        ([v1, v2]) => {\n          if (isNot !== (v1 === v2)) {\n            stop == null ? void 0 : stop();\n            resolve(v1);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => {\n          stop == null ? void 0 : stop();\n          return toValue(r);\n        })\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(toValue(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(toValue(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction defaultComparator(value, othVal) {\n  return value === othVal;\n}\nfunction useArrayDifference(...args) {\n  var _a;\n  const list = args[0];\n  const values = args[1];\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\n  if (typeof compareFn === \"string\") {\n    const key = compareFn;\n    compareFn = (value, othVal) => value[key] === othVal[key];\n  }\n  return computed(() => toValue(list).filter((x) => toValue(values).findIndex((y) => compareFn(x, y)) === -1));\n}\n\nfunction useArrayEvery(list, fn) {\n  return computed(() => toValue(list).every((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return computed(\n    () => toValue(\n      toValue(list).find((element, index, array) => fn(toValue(element), index, array))\n    )\n  );\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => toValue(list).findIndex((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction findLast(arr, cb) {\n  let index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr))\n      return arr[index];\n  }\n  return void 0;\n}\nfunction useArrayFindLast(list, fn) {\n  return computed(\n    () => toValue(\n      !Array.prototype.findLast ? findLast(toValue(list), (element, index, array) => fn(toValue(element), index, array)) : toValue(list).findLast((element, index, array) => fn(toValue(element), index, array))\n    )\n  );\n}\n\nfunction isArrayIncludesOptions(obj) {\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\nfunction useArrayIncludes(...args) {\n  var _a;\n  const list = args[0];\n  const value = args[1];\n  let comparator = args[2];\n  let formIndex = 0;\n  if (isArrayIncludesOptions(comparator)) {\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\n    comparator = comparator.comparator;\n  }\n  if (typeof comparator === \"string\") {\n    const key = comparator;\n    comparator = (element, value2) => element[key] === toValue(value2);\n  }\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue(value2);\n  return computed(\n    () => toValue(list).slice(formIndex).some(\n      (element, index, array) => comparator(toValue(element), toValue(value), index, toValue(array))\n    )\n  );\n}\n\nfunction useArrayJoin(list, separator) {\n  return computed(() => toValue(list).map((i) => toValue(i)).join(toValue(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(toValue(sum), toValue(value), index);\n  return computed(() => {\n    const resolved = toValue(list);\n    return args.length ? resolved.reduce(reduceCallback, toValue(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return computed(() => toValue(list).some((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n  return array.reduce((acc, v) => {\n    if (!acc.some((x) => fn(v, x, array)))\n      acc.push(v);\n    return acc;\n  }, []);\n}\nfunction useArrayUnique(list, compareFn) {\n  return computed(() => {\n    const resolvedList = toValue(list).map((element) => toValue(element));\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n  });\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  const count = ref(initialValue);\n  const {\n    max = Infinity,\n    min = -Infinity\n  } = options;\n  const inc = (delta = 1) => count.value = Math.min(max, count.value + delta);\n  const dec = (delta = 1) => count.value = Math.max(min, count.value - delta);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = initialValue) => {\n    initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/;\nconst REGEX_FORMAT = /\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n}\nfunction formatDate(date, formatStr, options = {}) {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(options.locales, { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(options.locales, { month: \"long\" }),\n    D: () => String(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(options.locales, { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(options.locales, { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(options.locales, { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\n    var _a2;\n    return $1 || ((_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) || match;\n  });\n}\nfunction normalizeDate(date) {\n  if (date === null)\n    return /* @__PURE__ */ new Date(NaN);\n  if (date === void 0)\n    return /* @__PURE__ */ new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n}\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(toValue(date)), toValue(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    const intervalValue = toValue(interval);\n    if (intervalValue <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || typeof interval === \"function\") {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$8 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$a.call(b, prop))\n      __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a)\n    for (var prop of __getOwnPropSymbols$a(b)) {\n      if (__propIsEnum$a.call(b, prop))\n        __defNormalProp$8(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = ref(0);\n  const update = () => counter.value += 1;\n  const reset = () => {\n    counter.value = 0;\n  };\n  const controls = useIntervalFn(\n    callback ? () => {\n      update();\n      callback(counter.value);\n    } : update,\n    interval,\n    { immediate }\n  );\n  if (exposeControls) {\n    return __spreadValues$8({\n      counter,\n      reset\n    }, controls);\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(\n    source,\n    () => ms.value = timestamp(),\n    options\n  );\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, toValue(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: readonly(isPending),\n    start,\n    stop\n  };\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$7 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$9.call(b, prop))\n      __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9)\n    for (var prop of __getOwnPropSymbols$9(b)) {\n      if (__propIsEnum$9.call(b, prop))\n        __defNormalProp$7(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(\n    callback != null ? callback : noop,\n    interval,\n    options\n  );\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return __spreadValues$7({\n      ready\n    }, controls);\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = toValue(value);\n    if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return computed(() => `${toValue(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = toValue(truthyValue);\n      _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [\n    ...source instanceof Function ? source() : Array.isArray(source) ? source : toValue(source)\n  ];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = new Array(oldList.length);\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __objRest$5 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$8)\n    for (var prop of __getOwnPropSymbols$8(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchWithFilter(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$5(_a, [\n    \"eventFilter\"\n  ]);\n  return watch(\n    source,\n    createFilterWrapper(\n      eventFilter,\n      cb\n    ),\n    watchOptions\n  );\n}\n\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __objRest$4 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$7)\n    for (var prop of __getOwnPropSymbols$7(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchAtMost(source, cb, options) {\n  const _a = options, {\n    count\n  } = _a, watchOptions = __objRest$4(_a, [\n    \"count\"\n  ]);\n  const current = ref(0);\n  const stop = watchWithFilter(\n    source,\n    (...args) => {\n      current.value += 1;\n      if (current.value >= toValue(count))\n        nextTick(() => stop());\n      cb(...args);\n    },\n    watchOptions\n  );\n  return { count: current, stop };\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __defProps$6 = Object.defineProperties;\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$6 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$6.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(b)) {\n      if (__propIsEnum$6.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));\nvar __objRest$3 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchDebounced(source, cb, options = {}) {\n  const _a = options, {\n    debounce = 0,\n    maxWait = void 0\n  } = _a, watchOptions = __objRest$3(_a, [\n    \"debounce\",\n    \"maxWait\"\n  ]);\n  return watchWithFilter(\n    source,\n    cb,\n    __spreadProps$6(__spreadValues$6({}, watchOptions), {\n      eventFilter: debounceFilter(debounce, { maxWait })\n    })\n  );\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$5.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(b)) {\n      if (__propIsEnum$5.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\nfunction watchDeep(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    __spreadProps$5(__spreadValues$5({}, options), {\n      deep: true\n    })\n  );\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$4.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(b)) {\n      if (__propIsEnum$4.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\nvar __objRest$2 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchIgnorable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$2(_a, [\n    \"eventFilter\"\n  ]);\n  const filteredCb = createFilterWrapper(\n    eventFilter,\n    cb\n  );\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(\n      source,\n      (...args) => {\n        if (!ignore.value)\n          filteredCb(...args);\n      },\n      watchOptions\n    );\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(\n      watch(\n        source,\n        () => {\n          syncCounter.value++;\n        },\n        __spreadProps$4(__spreadValues$4({}, watchOptions), { flush: \"sync\" })\n      )\n    );\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(\n      watch(\n        source,\n        (...args) => {\n          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n          ignoreCounter.value = 0;\n          syncCounter.value = 0;\n          if (ignore)\n            return;\n          filteredCb(...args);\n        },\n        watchOptions\n      )\n    );\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nfunction watchImmediate(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    __spreadProps$3(__spreadValues$3({}, options), {\n      immediate: true\n    })\n  );\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nvar __objRest$1 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchPausable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter: filter\n  } = _a, watchOptions = __objRest$1(_a, [\n    \"eventFilter\"\n  ]);\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(\n    source,\n    cb,\n    __spreadProps$2(__spreadValues$2({}, watchOptions), {\n      eventFilter\n    })\n  );\n  return { stop, pause, resume, isActive };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchThrottled(source, cb, options = {}) {\n  const _a = options, {\n    throttle = 0,\n    trailing = true,\n    leading = true\n  } = _a, watchOptions = __objRest(_a, [\n    \"throttle\",\n    \"trailing\",\n    \"leading\"\n  ]);\n  return watchWithFilter(\n    source,\n    cb,\n    __spreadProps$1(__spreadValues$1({}, watchOptions), {\n      eventFilter: throttleFilter(throttle, trailing, leading)\n    })\n  );\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return __spreadProps(__spreadValues({}, res), {\n    trigger\n  });\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => toValue(item));\n  return toValue(sources);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  return watch(\n    source,\n    (v, ov, onInvalidate) => {\n      if (v)\n        cb(v, ov, onInvalidate);\n    },\n    options\n  );\n}\n\nexport { assert, refAutoReset as autoResetRef, bypassFilter, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, hasOwn, identity, watchIgnorable as ignorableWatch, increaseWithUnit, invoke, isClient, isDef, isDefined, isIOS, isObject, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRef, toRefs, toValue, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","import Vue from 'vue'\nimport { getCurrentInstance } from 'vue'\n\nvar isVue2 = true\nvar isVue3 = false\nvar Vue2 = Vue\nvar warn = Vue.util.warn\n\nfunction install() {}\n\n// createApp polyfill\nexport function createApp(rootComponent, rootProps) {\n  var vm\n  var provide = {}\n  var app = {\n    config: Vue.config,\n    use: Vue.use.bind(Vue),\n    mixin: Vue.mixin.bind(Vue),\n    component: Vue.component.bind(Vue),\n    provide: function (key, value) {\n      provide[key] = value\n      return this\n    },\n    directive: function (name, dir) {\n      if (dir) {\n        Vue.directive(name, dir)\n        return app\n      } else {\n        return Vue.directive(name)\n      }\n    },\n    mount: function (el, hydrating) {\n      if (!vm) {\n        vm = new Vue(Object.assign({ propsData: rootProps }, rootComponent, { provide: Object.assign(provide, rootComponent.provide) }))\n        vm.$mount(el, hydrating)\n        return vm\n      } else {\n        return vm\n      }\n    },\n    unmount: function () {\n      if (vm) {\n        vm.$destroy()\n        vm = undefined\n      }\n    },\n  }\n  return app\n}\n\nexport {\n  Vue,\n  Vue2,\n  isVue2,\n  isVue3,\n  install,\n  warn\n}\n\n// Vue 3 components mock\nfunction createMockComponent(name) {\n  return {\n    setup() {\n      throw new Error('[vue-demi] ' + name + ' is not supported in Vue 2. It\\'s provided to avoid compiler errors.')\n    }\n  }\n}\nexport var Fragment = /*#__PURE__*/ createMockComponent('Fragment')\nexport var Transition = /*#__PURE__*/ createMockComponent('Transition')\nexport var TransitionGroup = /*#__PURE__*/ createMockComponent('TransitionGroup')\nexport var Teleport = /*#__PURE__*/ createMockComponent('Teleport')\nexport var Suspense = /*#__PURE__*/ createMockComponent('Suspense')\nexport var KeepAlive = /*#__PURE__*/ createMockComponent('KeepAlive')\n\nexport * from 'vue'\n\n// Not implemented https://github.com/vuejs/core/pull/8111, falls back to getCurrentInstance()\nexport function hasInjectionContext() {\n  return !!getCurrentInstance()\n}\n","import { noop, makeDestructurable, toValue, isClient, tryOnScopeDispose, isIOS, tryOnMounted, computedWithControl, isObject, objectOmit, promiseTimeout, until, toRef, increaseWithUnit, objectEntries, useTimeoutFn, pausableWatch, createEventHook, timestamp, pausableFilter, watchIgnorable, debounceFilter, createFilterWrapper, bypassFilter, createSingletonPromise, toRefs, notNullish, containsProp, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, useIntervalFn, clamp, syncRef, objectPick, tryOnUnmounted, watchWithFilter, identity, isDef } from '@vueuse/shared';\nexport * from '@vueuse/shared';\nimport { isRef, ref, shallowRef, watchEffect, computed, inject, isVue3, version, defineComponent, h, TransitionGroup, shallowReactive, Fragment, watch, getCurrentInstance, customRef, onUpdated, onMounted, readonly, nextTick, reactive, markRaw, getCurrentScope, isVue2, set, del, isReadonly, onBeforeUpdate } from 'vue-demi';\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  let options;\n  if (isRef(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    evaluating = void 0,\n    shallow = true,\n    onError = noop\n  } = options;\n  const started = ref(!lazy);\n  const current = shallow ? shallowRef(initialState) : ref(initialState);\n  let counter = 0;\n  watchEffect(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  });\n  if (lazy) {\n    return computed(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = inject(key);\n  if (defaultSource)\n    source = inject(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = inject(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return computed((ctx) => options(source, ctx));\n  } else {\n    return computed({\n      get: (ctx) => options.get(source, ctx),\n      set: options.set\n    });\n  }\n}\n\nvar __defProp$p = Object.defineProperty;\nvar __defProps$c = Object.defineProperties;\nvar __getOwnPropDescs$c = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$s = Object.getOwnPropertySymbols;\nvar __hasOwnProp$s = Object.prototype.hasOwnProperty;\nvar __propIsEnum$s = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$p = (obj, key, value) => key in obj ? __defProp$p(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$p = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$s.call(b, prop))\n      __defNormalProp$p(a, prop, b[prop]);\n  if (__getOwnPropSymbols$s)\n    for (var prop of __getOwnPropSymbols$s(b)) {\n      if (__propIsEnum$s.call(b, prop))\n        __defNormalProp$p(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$c = (a, b) => __defProps$c(a, __getOwnPropDescs$c(b));\nfunction createReusableTemplate() {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createReusableTemplate only works in Vue 2.7 or above.\");\n    return;\n  }\n  const render = shallowRef();\n  const define = /* #__PURE__ */ defineComponent({\n    setup(_, { slots }) {\n      return () => {\n        render.value = slots.default;\n      };\n    }\n  });\n  const reuse = /* #__PURE__ */ defineComponent({\n    inheritAttrs: false,\n    setup(_, { attrs, slots }) {\n      return () => {\n        var _a;\n        if (!render.value && process.env.NODE_ENV !== \"production\")\n          throw new Error(\"[VueUse] Failed to find the definition of reusable template\");\n        return (_a = render.value) == null ? void 0 : _a.call(render, __spreadProps$c(__spreadValues$p({}, attrs), { $slots: slots }));\n      };\n    }\n  });\n  return makeDestructurable(\n    { define, reuse },\n    [define, reuse]\n  );\n}\n\nfunction createTemplatePromise(options = {}) {\n  if (!isVue3) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createTemplatePromise only works in Vue 3 or above.\");\n    return;\n  }\n  let index = 0;\n  const instances = ref([]);\n  function create(...args) {\n    const props = shallowReactive({\n      key: index++,\n      args,\n      promise: void 0,\n      resolve: () => {\n      },\n      reject: () => {\n      },\n      isResolving: false,\n      options\n    });\n    instances.value.push(props);\n    props.promise = new Promise((_resolve, _reject) => {\n      props.resolve = (v) => {\n        props.isResolving = true;\n        return _resolve(v);\n      };\n      props.reject = _reject;\n    }).finally(() => {\n      props.promise = void 0;\n      const index2 = instances.value.indexOf(props);\n      if (index2 !== -1)\n        instances.value.splice(index2, 1);\n    });\n    return props.promise;\n  }\n  function start(...args) {\n    if (options.singleton && instances.value.length > 0)\n      return instances.value[0].promise;\n    return create(...args);\n  }\n  const component = /* #__PURE__ */ defineComponent((_, { slots }) => {\n    const renderList = () => instances.value.map((props) => {\n      var _a;\n      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));\n    });\n    if (options.transition)\n      return () => h(TransitionGroup, options.transition, renderList);\n    return renderList;\n  });\n  component.start = start;\n  return component;\n}\n\nfunction createUnrefFn(fn) {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => toValue(i)));\n  };\n}\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = toValue(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\nfunction useEventListener(...args) {\n  let target;\n  let events;\n  let listeners;\n  let options;\n  if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n    [events, listeners, options] = args;\n    target = defaultWindow;\n  } else {\n    [target, events, listeners, options] = args;\n  }\n  if (!target)\n    return noop;\n  if (!Array.isArray(events))\n    events = [events];\n  if (!Array.isArray(listeners))\n    listeners = [listeners];\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener, options2) => {\n    el.addEventListener(event, listener, options2);\n    return () => el.removeEventListener(event, listener, options2);\n  };\n  const stopWatch = watch(\n    () => [unrefElement(target), toValue(options)],\n    ([el, options2]) => {\n      cleanup();\n      if (!el)\n        return;\n      cleanups.push(\n        ...events.flatMap((event) => {\n          return listeners.map((listener) => register(el, event, listener, options2));\n        })\n      );\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return stop;\n}\n\nlet _iOSWorkaround = false;\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;\n  if (!window)\n    return;\n  if (isIOS && !_iOSWorkaround) {\n    _iOSWorkaround = true;\n    Array.from(window.document.body.children).forEach((el) => el.addEventListener(\"click\", noop));\n  }\n  let shouldListen = true;\n  const shouldIgnore = (event) => {\n    return ignore.some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  const listener = (event) => {\n    const el = unrefElement(target);\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  const cleanup = [\n    useEventListener(window, \"click\", listener, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      if (el)\n        shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      var _a;\n      const el = unrefElement(target);\n      if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement)))\n        handler(event);\n    })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nvar __defProp$o = Object.defineProperty;\nvar __defProps$b = Object.defineProperties;\nvar __getOwnPropDescs$b = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$r = Object.getOwnPropertySymbols;\nvar __hasOwnProp$r = Object.prototype.hasOwnProperty;\nvar __propIsEnum$r = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$o = (obj, key, value) => key in obj ? __defProp$o(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$o = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$r.call(b, prop))\n      __defNormalProp$o(a, prop, b[prop]);\n  if (__getOwnPropSymbols$r)\n    for (var prop of __getOwnPropSymbols$r(b)) {\n      if (__propIsEnum$r.call(b, prop))\n        __defNormalProp$o(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$b = (a, b) => __defProps$b(a, __getOwnPropDescs$b(b));\nfunction createKeyPredicate(keyFilter) {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n}\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const {\n    target = defaultWindow,\n    eventName = \"keydown\",\n    passive = false,\n    dedupe = false\n  } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (e.repeat && toValue(dedupe))\n      return;\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$b(__spreadValues$o({}, options), { eventName: \"keydown\" }));\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$b(__spreadValues$o({}, options), { eventName: \"keypress\" }));\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$b(__spreadValues$o({}, options), { eventName: \"keyup\" }));\n}\n\nconst DEFAULT_DELAY = 500;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = computed(() => unrefElement(target));\n  let timeout;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    timeout = setTimeout(\n      () => handler(ev),\n      (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY\n    );\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions);\n  useEventListener(elementRef, \"pointerup\", clear, listenerOptions);\n  useEventListener(elementRef, \"pointerleave\", clear, listenerOptions);\n}\n\nfunction isFocusedElementEditable() {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n}\nfunction isTypedCharValid({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  if (keyCode >= 97 && keyCode <= 122)\n    return true;\n  return false;\n}\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\nfunction templateRef(key, initialValue = null) {\n  const instance = getCurrentInstance();\n  let _trigger = () => {\n  };\n  const element = customRef((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  tryOnMounted(_trigger);\n  onUpdated(_trigger);\n  return element;\n}\n\nfunction useActiveElement(options = {}) {\n  var _a;\n  const { window = defaultWindow } = options;\n  const document = (_a = options.document) != null ? _a : window == null ? void 0 : window.document;\n  const activeElement = computedWithControl(\n    () => null,\n    () => document == null ? void 0 : document.activeElement\n  );\n  if (window) {\n    useEventListener(window, \"blur\", (event) => {\n      if (event.relatedTarget !== null)\n        return;\n      activeElement.trigger();\n    }, true);\n    useEventListener(window, \"focus\", activeElement.trigger, true);\n  }\n  return activeElement;\n}\n\nfunction useMounted() {\n  const isMounted = ref(false);\n  if (getCurrentInstance()) {\n    onMounted(() => {\n      isMounted.value = true;\n    });\n  }\n  return isMounted;\n}\n\nfunction useSupported(callback) {\n  const isMounted = useMounted();\n  return computed(() => {\n    isMounted.value;\n    return Boolean(callback());\n  });\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    window = defaultWindow\n  } = options;\n  const isActive = ref(false);\n  let previousFrameTimestamp = 0;\n  let rafId = null;\n  function loop(timestamp) {\n    if (!isActive.value || !window)\n      return;\n    const delta = timestamp - previousFrameTimestamp;\n    fn({ delta, timestamp });\n    previousFrameTimestamp = timestamp;\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      rafId = window.requestAnimationFrame(loop);\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive: readonly(isActive),\n    pause,\n    resume\n  };\n}\n\nfunction useAnimate(target, keyframes, options) {\n  let config;\n  let animateOptions;\n  if (isObject(options)) {\n    config = options;\n    animateOptions = objectOmit(options, [\"window\", \"immediate\", \"commitStyles\", \"persist\", \"onReady\", \"onError\"]);\n  } else {\n    config = { duration: options };\n    animateOptions = options;\n  }\n  const {\n    window = defaultWindow,\n    immediate = true,\n    commitStyles,\n    persist,\n    playbackRate: _playbackRate = 1,\n    onReady,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = config;\n  const isSupported = useSupported(() => window && HTMLElement && \"animate\" in HTMLElement.prototype);\n  const animate = shallowRef(void 0);\n  const store = shallowReactive({\n    startTime: null,\n    currentTime: null,\n    timeline: null,\n    playbackRate: _playbackRate,\n    pending: false,\n    playState: immediate ? \"idle\" : \"paused\",\n    replaceState: \"active\"\n  });\n  const pending = computed(() => store.pending);\n  const playState = computed(() => store.playState);\n  const replaceState = computed(() => store.replaceState);\n  const startTime = computed({\n    get() {\n      return store.startTime;\n    },\n    set(value) {\n      store.startTime = value;\n      if (animate.value)\n        animate.value.startTime = value;\n    }\n  });\n  const currentTime = computed({\n    get() {\n      return store.currentTime;\n    },\n    set(value) {\n      store.currentTime = value;\n      if (animate.value) {\n        animate.value.currentTime = value;\n        syncResume();\n      }\n    }\n  });\n  const timeline = computed({\n    get() {\n      return store.timeline;\n    },\n    set(value) {\n      store.timeline = value;\n      if (animate.value)\n        animate.value.timeline = value;\n    }\n  });\n  const playbackRate = computed({\n    get() {\n      return store.playbackRate;\n    },\n    set(value) {\n      store.playbackRate = value;\n      if (animate.value)\n        animate.value.playbackRate = value;\n    }\n  });\n  const play = () => {\n    if (animate.value) {\n      try {\n        animate.value.play();\n        syncResume();\n      } catch (e) {\n        syncPause();\n        onError(e);\n      }\n    } else {\n      update();\n    }\n  };\n  const pause = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.pause();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const reverse = () => {\n    var _a;\n    !animate.value && update();\n    try {\n      (_a = animate.value) == null ? void 0 : _a.reverse();\n      syncResume();\n    } catch (e) {\n      syncPause();\n      onError(e);\n    }\n  };\n  const finish = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.finish();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const cancel = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.cancel();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  watch(() => unrefElement(target), (el) => {\n    el && update();\n  });\n  watch(() => keyframes, (value) => {\n    !animate.value && update();\n    if (!unrefElement(target) && animate.value) {\n      animate.value.effect = new KeyframeEffect(\n        unrefElement(target),\n        toValue(value),\n        animateOptions\n      );\n    }\n  }, { deep: true });\n  tryOnMounted(() => {\n    nextTick(() => update(true));\n  });\n  tryOnScopeDispose(cancel);\n  function update(init) {\n    const el = unrefElement(target);\n    if (!isSupported.value || !el)\n      return;\n    animate.value = el.animate(toValue(keyframes), animateOptions);\n    if (commitStyles)\n      animate.value.commitStyles();\n    if (persist)\n      animate.value.persist();\n    if (_playbackRate !== 1)\n      animate.value.playbackRate = _playbackRate;\n    if (init && !immediate)\n      animate.value.pause();\n    else\n      syncResume();\n    onReady == null ? void 0 : onReady(animate.value);\n  }\n  useEventListener(animate, \"cancel\", syncPause);\n  useEventListener(animate, \"finish\", syncPause);\n  useEventListener(animate, \"remove\", syncPause);\n  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {\n    if (!animate.value)\n      return;\n    store.pending = animate.value.pending;\n    store.playState = animate.value.playState;\n    store.replaceState = animate.value.replaceState;\n    store.startTime = animate.value.startTime;\n    store.currentTime = animate.value.currentTime;\n    store.timeline = animate.value.timeline;\n    store.playbackRate = animate.value.playbackRate;\n  }, { immediate: false });\n  function syncResume() {\n    if (isSupported.value)\n      resumeRef();\n  }\n  function syncPause() {\n    if (isSupported.value && window)\n      window.requestAnimationFrame(pauseRef);\n  }\n  return {\n    isSupported,\n    animate,\n    // actions\n    play,\n    pause,\n    reverse,\n    finish,\n    cancel,\n    // state\n    pending,\n    playState,\n    replaceState,\n    startTime,\n    currentTime,\n    timeline,\n    playbackRate\n  };\n}\n\nfunction useAsyncQueue(tasks, options = {}) {\n  const {\n    interrupt = true,\n    onError = noop,\n    onFinished = noop\n  } = options;\n  const promiseState = {\n    pending: \"pending\",\n    rejected: \"rejected\",\n    fulfilled: \"fulfilled\"\n  };\n  const initialResult = Array.from(new Array(tasks.length), () => ({ state: promiseState.pending, data: null }));\n  const result = reactive(initialResult);\n  const activeIndex = ref(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      return curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        activeIndex.value === tasks.length - 1 && onFinished();\n        return currentRes;\n      });\n    }).catch((e) => {\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\n\nvar __defProp$n = Object.defineProperty;\nvar __defProps$a = Object.defineProperties;\nvar __getOwnPropDescs$a = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$q = Object.getOwnPropertySymbols;\nvar __hasOwnProp$q = Object.prototype.hasOwnProperty;\nvar __propIsEnum$q = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$n = (obj, key, value) => key in obj ? __defProp$n(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$n = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$q.call(b, prop))\n      __defNormalProp$n(a, prop, b[prop]);\n  if (__getOwnPropSymbols$q)\n    for (var prop of __getOwnPropSymbols$q(b)) {\n      if (__propIsEnum$q.call(b, prop))\n        __defNormalProp$n(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$a = (a, b) => __defProps$a(a, __getOwnPropDescs$a(b));\nfunction useAsyncState(promise, initialState, options) {\n  const {\n    immediate = true,\n    delay = 0,\n    onError = noop,\n    onSuccess = noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = ref(false);\n  const isLoading = ref(false);\n  const error = shallowRef(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = initialState;\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n      onSuccess(data);\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw e;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate)\n    execute(delay);\n  const shell = {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute\n  };\n  function waitUntilIsLoaded() {\n    return new Promise((resolve, reject) => {\n      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  return __spreadProps$a(__spreadValues$n({}, shell), {\n    then(onFulfilled, onRejected) {\n      return waitUntilIsLoaded().then(onFulfilled, onRejected);\n    }\n  });\n}\n\nconst defaults = {\n  array: (v) => JSON.stringify(v),\n  object: (v) => JSON.stringify(v),\n  set: (v) => JSON.stringify(Array.from(v)),\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\n  null: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n  if (!target)\n    return defaults.null;\n  if (target instanceof Map)\n    return defaults.map;\n  else if (target instanceof Set)\n    return defaults.set;\n  else if (Array.isArray(target))\n    return defaults.array;\n  else\n    return defaults.object;\n}\n\nfunction useBase64(target, options) {\n  const base64 = ref(\"\");\n  const promise = ref();\n  function execute() {\n    if (!isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = toValue(target);\n        if (_target == null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else if (typeof _target === \"object\") {\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\n          const serialized = _serializeFn(_target);\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => base64.value = res);\n    return promise.value;\n  }\n  if (isRef(target) || typeof target === \"function\")\n    watch(target, execute, { immediate: true });\n  else\n    execute();\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\nfunction useBattery({ navigator = defaultNavigator } = {}) {\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator);\n  const charging = ref(false);\n  const chargingTime = ref(0);\n  const dischargingTime = ref(0);\n  const level = ref(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported.value) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      for (const event of events)\n        useEventListener(battery, event, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\nfunction useBluetooth(options) {\n  let {\n    acceptAllDevices = false\n  } = options || {};\n  const {\n    filters = void 0,\n    optionalServices = void 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\n  const device = shallowRef(void 0);\n  const error = shallowRef(null);\n  watch(device, () => {\n    connectToBluetoothGATTServer();\n  });\n  async function requestDevice() {\n    if (!isSupported.value)\n      return;\n    error.value = null;\n    if (filters && filters.length > 0)\n      acceptAllDevices = false;\n    try {\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\n        acceptAllDevices,\n        filters,\n        optionalServices\n      }));\n    } catch (err) {\n      error.value = err;\n    }\n  }\n  const server = ref();\n  const isConnected = computed(() => {\n    var _a;\n    return ((_a = server.value) == null ? void 0 : _a.connected) || false;\n  });\n  async function connectToBluetoothGATTServer() {\n    error.value = null;\n    if (device.value && device.value.gatt) {\n      device.value.addEventListener(\"gattserverdisconnected\", () => {\n      });\n      try {\n        server.value = await device.value.gatt.connect();\n      } catch (err) {\n        error.value = err;\n      }\n    }\n  }\n  tryOnMounted(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\n  });\n  tryOnScopeDispose(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\n  });\n  return {\n    isSupported,\n    isConnected,\n    // Device:\n    device,\n    requestDevice,\n    // Server:\n    server,\n    // Errors:\n    error\n  };\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  let mediaQuery;\n  const matches = ref(false);\n  const cleanup = () => {\n    if (!mediaQuery)\n      return;\n    if (\"removeEventListener\" in mediaQuery)\n      mediaQuery.removeEventListener(\"change\", update);\n    else\n      mediaQuery.removeListener(update);\n  };\n  const update = () => {\n    if (!isSupported.value)\n      return;\n    cleanup();\n    mediaQuery = window.matchMedia(toRef(query).value);\n    matches.value = !!(mediaQuery == null ? void 0 : mediaQuery.matches);\n    if (!mediaQuery)\n      return;\n    if (\"addEventListener\" in mediaQuery)\n      mediaQuery.addEventListener(\"change\", update);\n    else\n      mediaQuery.addListener(update);\n  };\n  watchEffect(update);\n  tryOnScopeDispose(() => cleanup());\n  return matches;\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetify = {\n  xs: 600,\n  sm: 960,\n  md: 1264,\n  lg: 1904\n};\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 600,\n  sm: 1024,\n  md: 1440,\n  lg: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\nconst breakpointsMasterCss = {\n  \"3xs\": 360,\n  \"2xs\": 480,\n  \"xs\": 600,\n  \"sm\": 768,\n  \"md\": 1024,\n  \"lg\": 1280,\n  \"xl\": 1440,\n  \"2xl\": 1600,\n  \"3xl\": 1920,\n  \"4xl\": 2560\n};\n\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = breakpoints[k];\n    if (delta != null)\n      v = increaseWithUnit(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow } = options;\n  function match(query) {\n    if (!window)\n      return false;\n    return window.matchMedia(query).matches;\n  }\n  const greaterOrEqual = (k) => {\n    return useMediaQuery(`(min-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => greaterOrEqual(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  return Object.assign(shortcutMethods, {\n    greater(k) {\n      return useMediaQuery(`(min-width: ${getValue(k, 0.1)})`, options);\n    },\n    greaterOrEqual,\n    smaller(k) {\n      return useMediaQuery(`(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    smallerOrEqual(k) {\n      return useMediaQuery(`(max-width: ${getValue(k)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(`(min-width: ${getValue(k, 0.1)})`);\n    },\n    isGreaterOrEqual(k) {\n      return match(`(min-width: ${getValue(k)})`);\n    },\n    isSmaller(k) {\n      return match(`(max-width: ${getValue(k, -0.1)})`);\n    },\n    isSmallerOrEqual(k) {\n      return match(`(max-width: ${getValue(k)})`);\n    },\n    isInBetween(a, b) {\n      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\n    },\n    current() {\n      const points = Object.keys(breakpoints).map((i) => [i, greaterOrEqual(i)]);\n      return computed(() => points.filter(([, v]) => v.value).map(([k]) => k));\n    }\n  });\n}\n\nfunction useBroadcastChannel(options) {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\n  const isClosed = ref(false);\n  const channel = ref();\n  const data = ref();\n  const error = shallowRef(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported.value) {\n    tryOnMounted(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      channel.value.addEventListener(\"message\", (e) => {\n        data.value = e.data;\n      }, { passive: true });\n      channel.value.addEventListener(\"messageerror\", (e) => {\n        error.value = e;\n      }, { passive: true });\n      channel.value.addEventListener(\"close\", () => {\n        isClosed.value = true;\n      });\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n}\n\nvar __defProp$m = Object.defineProperty;\nvar __getOwnPropSymbols$p = Object.getOwnPropertySymbols;\nvar __hasOwnProp$p = Object.prototype.hasOwnProperty;\nvar __propIsEnum$p = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$m = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$m = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$p.call(b, prop))\n      __defNormalProp$m(a, prop, b[prop]);\n  if (__getOwnPropSymbols$p)\n    for (var prop of __getOwnPropSymbols$p(b)) {\n      if (__propIsEnum$p.call(b, prop))\n        __defNormalProp$m(a, prop, b[prop]);\n    }\n  return a;\n};\nconst WRITABLE_PROPERTIES = [\n  \"hash\",\n  \"host\",\n  \"hostname\",\n  \"href\",\n  \"pathname\",\n  \"port\",\n  \"protocol\",\n  \"search\"\n];\nfunction useBrowserLocation({ window = defaultWindow } = {}) {\n  const refs = Object.fromEntries(\n    WRITABLE_PROPERTIES.map((key) => [key, ref()])\n  );\n  for (const [key, ref2] of objectEntries(refs)) {\n    watch(ref2, (value) => {\n      if (!(window == null ? void 0 : window.location) || window.location[key] === value)\n        return;\n      window.location[key] = value;\n    });\n  }\n  const buildState = (trigger) => {\n    var _a;\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { origin } = (window == null ? void 0 : window.location) || {};\n    for (const key of WRITABLE_PROPERTIES)\n      refs[key].value = (_a = window == null ? void 0 : window.location) == null ? void 0 : _a[key];\n    return reactive(__spreadValues$m({\n      trigger,\n      state: state2,\n      length,\n      origin\n    }, refs));\n  };\n  const state = ref(buildState(\"load\"));\n  if (window) {\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), { passive: true });\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), { passive: true });\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, watchOptions) {\n  const cachedValue = ref(refValue.value);\n  watch(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500,\n    legacy = false\n  } = options;\n  const events = [\"copy\", \"cut\"];\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\n  const text = ref(\"\");\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateText() {\n    if (isClipboardApiSupported.value) {\n      navigator.clipboard.readText().then((value) => {\n        text.value = value;\n      });\n    } else {\n      text.value = legacyRead();\n    }\n  }\n  if (isSupported.value && read) {\n    for (const event of events)\n      useEventListener(event, updateText);\n  }\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      if (isClipboardApiSupported.value)\n        await navigator.clipboard.writeText(value);\n      else\n        legacyCopy(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  function legacyCopy(value) {\n    const ta = document.createElement(\"textarea\");\n    ta.value = value != null ? value : \"\";\n    ta.style.position = \"absolute\";\n    ta.style.opacity = \"0\";\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand(\"copy\");\n    ta.remove();\n  }\n  function legacyRead() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nvar __defProp$l = Object.defineProperty;\nvar __defProps$9 = Object.defineProperties;\nvar __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$o = Object.getOwnPropertySymbols;\nvar __hasOwnProp$o = Object.prototype.hasOwnProperty;\nvar __propIsEnum$o = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$l = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$o.call(b, prop))\n      __defNormalProp$l(a, prop, b[prop]);\n  if (__getOwnPropSymbols$o)\n    for (var prop of __getOwnPropSymbols$o(b)) {\n      if (__propIsEnum$o.call(b, prop))\n        __defNormalProp$l(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));\nfunction cloneFnJSON(source) {\n  return JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n  const cloned = ref({});\n  const {\n    manual,\n    clone = cloneFnJSON,\n    // watch options\n    deep = true,\n    immediate = true\n  } = options;\n  function sync() {\n    cloned.value = clone(toValue(source));\n  }\n  if (!manual && isRef(source)) {\n    watch(source, sync, __spreadProps$9(__spreadValues$l({}, options), {\n      deep,\n      immediate\n    }));\n  } else {\n    sync();\n  }\n  return { cloned, sync };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\nconst handlers = /* @__PURE__ */ getHandlers();\nfunction getHandlers() {\n  if (!(globalKey in _global))\n    _global[globalKey] = _global[globalKey] || {};\n  return _global[globalKey];\n}\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nvar __defProp$k = Object.defineProperty;\nvar __getOwnPropSymbols$n = Object.getOwnPropertySymbols;\nvar __hasOwnProp$n = Object.prototype.hasOwnProperty;\nvar __propIsEnum$n = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$k = (obj, key, value) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$k = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$n.call(b, prop))\n      __defNormalProp$k(a, prop, b[prop]);\n  if (__getOwnPropSymbols$n)\n    for (var prop of __getOwnPropSymbols$n(b)) {\n      if (__propIsEnum$n.call(b, prop))\n        __defNormalProp$k(a, prop, b[prop]);\n    }\n  return a;\n};\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nconst customStorageEventName = \"vueuse-storage\";\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const data = (shallow ? shallowRef : ref)(defaults);\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = toValue(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(\n    data,\n    () => write(data.value),\n    { flush, deep, eventFilter }\n  );\n  if (window && listenToStorageChanges) {\n    useEventListener(window, \"storage\", update);\n    useEventListener(window, customStorageEventName, updateFromCustomEvent);\n  }\n  update();\n  return data;\n  function write(v) {\n    try {\n      if (v == null) {\n        storage.removeItem(key);\n      } else {\n        const serialized = serializer.write(v);\n        const oldValue = storage.getItem(key);\n        if (oldValue !== serialized) {\n          storage.setItem(key, serialized);\n          if (window) {\n            window.dispatchEvent(new CustomEvent(customStorageEventName, {\n              detail: {\n                key,\n                oldValue,\n                newValue: serialized,\n                storageArea: storage\n              }\n            }));\n          }\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(key);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit !== null)\n        storage.setItem(key, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (typeof mergeDefaults === \"function\")\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return __spreadValues$k(__spreadValues$k({}, rawInit), value);\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function updateFromCustomEvent(event) {\n    update(event.detail);\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== key)\n      return;\n    pauseWatch();\n    try {\n      data.value = read(event);\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        nextTick(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n}\n\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nvar __defProp$j = Object.defineProperty;\nvar __getOwnPropSymbols$m = Object.getOwnPropertySymbols;\nvar __hasOwnProp$m = Object.prototype.hasOwnProperty;\nvar __propIsEnum$m = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$j = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$m.call(b, prop))\n      __defNormalProp$j(a, prop, b[prop]);\n  if (__getOwnPropSymbols$m)\n    for (var prop of __getOwnPropSymbols$m(b)) {\n      if (__propIsEnum$m.call(b, prop))\n        __defNormalProp$j(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto,\n    disableTransition = true\n  } = options;\n  const modes = __spreadValues$j({\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\"\n  }, options.modes || {});\n  const preferredDark = usePreferredDark({ window });\n  const system = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = computed(\n    () => store.value === \"auto\" ? system.value : store.value\n  );\n  const updateHTMLAttrs = getSSRHandler(\n    \"updateHTMLAttrs\",\n    (selector2, attribute2, value) => {\n      const el = typeof selector2 === \"string\" ? window == null ? void 0 : window.document.querySelector(selector2) : unrefElement(selector2);\n      if (!el)\n        return;\n      let style;\n      if (disableTransition) {\n        style = window.document.createElement(\"style\");\n        style.appendChild(document.createTextNode(\"*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\"));\n        window.document.head.appendChild(style);\n      }\n      if (attribute2 === \"class\") {\n        const current = value.split(/\\s/g);\n        Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n          if (current.includes(v))\n            el.classList.add(v);\n          else\n            el.classList.remove(v);\n        });\n      } else {\n        el.setAttribute(attribute2, value);\n      }\n      if (disableTransition) {\n        window.getComputedStyle(style).opacity;\n        document.head.removeChild(style);\n      }\n    }\n  );\n  function defaultOnChanged(mode) {\n    var _a;\n    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  tryOnMounted(() => onChanged(state.value));\n  const auto = computed({\n    get() {\n      return emitAuto ? store.value : state.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  try {\n    return Object.assign(auto, { store, system, state });\n  } catch (e) {\n    return auto;\n  }\n}\n\nfunction useConfirmDialog(revealed = ref(false)) {\n  const confirmHook = createEventHook();\n  const cancelHook = createEventHook();\n  const revealHook = createEventHook();\n  let _resolve = noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: computed(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nvar __getOwnPropSymbols$l = Object.getOwnPropertySymbols;\nvar __hasOwnProp$l = Object.prototype.hasOwnProperty;\nvar __propIsEnum$l = Object.prototype.propertyIsEnumerable;\nvar __objRest$3 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$l.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$l)\n    for (var prop of __getOwnPropSymbols$l(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$l.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction useMutationObserver(target, callback, options = {}) {\n  const _a = options, { window = defaultWindow } = _a, mutationOptions = __objRest$3(_a, [\"window\"]);\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const stopWatch = watch(\n    () => unrefElement(target),\n    (el) => {\n      cleanup();\n      if (isSupported.value && window && el) {\n        observer = new MutationObserver(callback);\n        observer.observe(el, mutationOptions);\n      }\n    },\n    { immediate: true }\n  );\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useCssVar(prop, target, options = {}) {\n  const { window = defaultWindow, initialValue = \"\", observe = false } = options;\n  const variable = ref(initialValue);\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  function updateCssVar() {\n    var _a;\n    const key = toValue(prop);\n    const el = toValue(elRef);\n    if (el && window) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();\n      variable.value = value || initialValue;\n    }\n  }\n  if (observe) {\n    useMutationObserver(elRef, updateCssVar, {\n      attributes: true,\n      window\n    });\n  }\n  watch(\n    [elRef, () => toValue(prop)],\n    updateCssVar,\n    { immediate: true }\n  );\n  watch(\n    variable,\n    (val) => {\n      var _a;\n      if ((_a = elRef.value) == null ? void 0 : _a.style)\n        elRef.value.style.setProperty(toValue(prop), val);\n    }\n  );\n  return variable;\n}\n\nfunction useCurrentElement() {\n  const vm = getCurrentInstance();\n  const currentElement = computedWithControl(\n    () => null,\n    () => vm.proxy.$el\n  );\n  onUpdated(currentElement.trigger);\n  onMounted(currentElement.trigger);\n  return currentElement;\n}\n\nfunction useCycleList(list, options) {\n  const state = shallowRef(getInitialValue());\n  const listRef = toRef(list);\n  const index = computed({\n    get() {\n      var _a;\n      const targetList = listRef.value;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const targetList = listRef.value;\n    const length = targetList.length;\n    const index2 = (i % length + length) % length;\n    const value = targetList[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  function getInitialValue() {\n    var _a, _b;\n    return (_b = toValue((_a = options == null ? void 0 : options.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;\n  }\n  watch(listRef, () => set(index.value));\n  return {\n    state,\n    index,\n    next,\n    prev\n  };\n}\n\nvar __defProp$i = Object.defineProperty;\nvar __defProps$8 = Object.defineProperties;\nvar __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$k = Object.getOwnPropertySymbols;\nvar __hasOwnProp$k = Object.prototype.hasOwnProperty;\nvar __propIsEnum$k = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$i = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$k.call(b, prop))\n      __defNormalProp$i(a, prop, b[prop]);\n  if (__getOwnPropSymbols$k)\n    for (var prop of __getOwnPropSymbols$k(b)) {\n      if (__propIsEnum$k.call(b, prop))\n        __defNormalProp$i(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\"\n  } = options;\n  const mode = useColorMode(__spreadProps$8(__spreadValues$i({}, options), {\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\", defaultHandler, mode2);\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  }));\n  const isDark = computed({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      const modeVal = v ? \"dark\" : \"light\";\n      if (mode.system.value === modeVal)\n        mode.value = \"auto\";\n      else\n        mode.value = modeVal;\n    }\n  });\n  return isDark;\n}\n\nfunction fnBypass(v) {\n  return v;\n}\nfunction fnSetSource(source, value) {\n  return source.value = value;\n}\nfunction defaultDump(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return markRaw({\n      snapshot: dump(source.value),\n      timestamp: timestamp()\n    });\n  }\n  const last = ref(_createHistoryRecord());\n  const undoStack = ref([]);\n  const redoStack = ref([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Infinity);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = computed(() => [last.value, ...undoStack.value]);\n  const canUndo = computed(() => undoStack.value.length > 0);\n  const canRedo = computed(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nvar __defProp$h = Object.defineProperty;\nvar __defProps$7 = Object.defineProperties;\nvar __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$j = Object.getOwnPropertySymbols;\nvar __hasOwnProp$j = Object.prototype.hasOwnProperty;\nvar __propIsEnum$j = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$h = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$j.call(b, prop))\n      __defNormalProp$h(a, prop, b[prop]);\n  if (__getOwnPropSymbols$j)\n    for (var prop of __getOwnPropSymbols$j(b)) {\n      if (__propIsEnum$j.call(b, prop))\n        __defNormalProp$h(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = pausableFilter(eventFilter);\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = watchIgnorable(\n    source,\n    commit,\n    { deep, flush, eventFilter: composedFilter }\n  );\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, __spreadProps$7(__spreadValues$h({}, options), { clone: options.clone || deep, setSource }));\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return __spreadProps$7(__spreadValues$h({}, manualHistory), {\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  });\n}\n\nvar __defProp$g = Object.defineProperty;\nvar __defProps$6 = Object.defineProperties;\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$i = Object.getOwnPropertySymbols;\nvar __hasOwnProp$i = Object.prototype.hasOwnProperty;\nvar __propIsEnum$i = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$g = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$i.call(b, prop))\n      __defNormalProp$g(a, prop, b[prop]);\n  if (__getOwnPropSymbols$i)\n    for (var prop of __getOwnPropSymbols$i(b)) {\n      if (__propIsEnum$i.call(b, prop))\n        __defNormalProp$g(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n  const history = useRefHistory(source, __spreadProps$6(__spreadValues$g({}, options), { eventFilter: filter }));\n  return __spreadValues$g({}, history);\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    eventFilter = bypassFilter\n  } = options;\n  const acceleration = ref({ x: null, y: null, z: null });\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\n  const interval = ref(0);\n  const accelerationIncludingGravity = ref({\n    x: null,\n    y: null,\n    z: null\n  });\n  if (window) {\n    const onDeviceMotion = createFilterWrapper(\n      eventFilter,\n      (event) => {\n        acceleration.value = event.acceleration;\n        accelerationIncludingGravity.value = event.accelerationIncludingGravity;\n        rotationRate.value = event.rotationRate;\n        interval.value = event.interval;\n      }\n    );\n    useEventListener(window, \"devicemotion\", onDeviceMotion);\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval\n  };\n}\n\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = ref(false);\n  const alpha = ref(null);\n  const beta = ref(null);\n  const gamma = ref(null);\n  if (window && isSupported.value) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\nfunction useDevicePixelRatio({\n  window = defaultWindow\n} = {}) {\n  const pixelRatio = ref(1);\n  if (window) {\n    let observe = function() {\n      pixelRatio.value = window.devicePixelRatio;\n      cleanup();\n      media = window.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);\n      media.addEventListener(\"change\", observe, { once: true });\n    }, cleanup = function() {\n      media == null ? void 0 : media.removeEventListener(\"change\", observe);\n    };\n    let media;\n    observe();\n    tryOnScopeDispose(cleanup);\n  }\n  return { pixelRatio };\n}\n\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\n  let permissionStatus;\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = ref();\n  const onChange = () => {\n    if (permissionStatus)\n      state.value = permissionStatus.state;\n  };\n  const query = createSingletonPromise(async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionStatus) {\n      try {\n        permissionStatus = await navigator.permissions.query(desc);\n        useEventListener(permissionStatus, \"change\", onChange);\n        onChange();\n      } catch (e) {\n        state.value = \"prompt\";\n      }\n    }\n    return permissionStatus;\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = ref([]);\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n  const permissionGranted = ref(false);\n  let stream;\n  async function update() {\n    if (!isSupported.value)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n    if (stream) {\n      stream.getTracks().forEach((t) => t.stop());\n      stream = null;\n    }\n  }\n  async function ensurePermissions() {\n    if (!isSupported.value)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(\"camera\", { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      stream = await navigator.mediaDevices.getUserMedia(constraints);\n      update();\n      permissionGranted.value = true;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (isSupported.value) {\n    if (requestPermissions)\n      ensurePermissions();\n    useEventListener(navigator.mediaDevices, \"devicechange\", update);\n    update();\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\n  });\n  const constraint = { audio, video };\n  const stream = shallowRef();\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\nfunction useDocumentVisibility({ document = defaultDocument } = {}) {\n  if (!document)\n    return ref(\"visible\");\n  const visibility = ref(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  });\n  return visibility;\n}\n\nvar __defProp$f = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$h = Object.getOwnPropertySymbols;\nvar __hasOwnProp$h = Object.prototype.hasOwnProperty;\nvar __propIsEnum$h = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$f = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$h.call(b, prop))\n      __defNormalProp$f(a, prop, b[prop]);\n  if (__getOwnPropSymbols$h)\n    for (var prop of __getOwnPropSymbols$h(b)) {\n      if (__propIsEnum$h.call(b, prop))\n        __defNormalProp$f(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\nfunction useDraggable(target, options = {}) {\n  var _a, _b;\n  const {\n    pointerTypes,\n    preventDefault,\n    stopPropagation,\n    exact,\n    onMove,\n    onEnd,\n    onStart,\n    initialValue,\n    axis = \"both\",\n    draggingElement = defaultWindow,\n    handle: draggingHandle = target\n  } = options;\n  const position = ref(\n    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }\n  );\n  const pressedDelta = ref();\n  const filterEvent = (e) => {\n    if (pointerTypes)\n      return pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if (toValue(preventDefault))\n      e.preventDefault();\n    if (toValue(stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    if (!filterEvent(e))\n      return;\n    if (toValue(exact) && e.target !== toValue(target))\n      return;\n    const rect = toValue(target).getBoundingClientRect();\n    const pos = {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    };\n    if ((onStart == null ? void 0 : onStart(pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    if (!filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    let { x, y } = position.value;\n    if (axis === \"x\" || axis === \"both\")\n      x = e.clientX - pressedDelta.value.x;\n    if (axis === \"y\" || axis === \"both\")\n      y = e.clientY - pressedDelta.value.y;\n    position.value = {\n      x,\n      y\n    };\n    onMove == null ? void 0 : onMove(position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    if (!filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    onEnd == null ? void 0 : onEnd(position.value, e);\n    handleEvent(e);\n  };\n  if (isClient) {\n    const config = { capture: (_b = options.capture) != null ? _b : true };\n    useEventListener(draggingHandle, \"pointerdown\", start, config);\n    useEventListener(draggingElement, \"pointermove\", move, config);\n    useEventListener(draggingElement, \"pointerup\", end, config);\n  }\n  return __spreadProps$5(__spreadValues$f({}, toRefs(position)), {\n    position,\n    isDragging: computed(() => !!pressedDelta.value),\n    style: computed(\n      () => `left:${position.value.x}px;top:${position.value.y}px;`\n    )\n  });\n}\n\nfunction useDropZone(target, onDrop) {\n  const isOverDropZone = ref(false);\n  let counter = 0;\n  if (isClient) {\n    useEventListener(target, \"dragenter\", (event) => {\n      event.preventDefault();\n      counter += 1;\n      isOverDropZone.value = true;\n    });\n    useEventListener(target, \"dragover\", (event) => {\n      event.preventDefault();\n    });\n    useEventListener(target, \"dragleave\", (event) => {\n      event.preventDefault();\n      counter -= 1;\n      if (counter === 0)\n        isOverDropZone.value = false;\n    });\n    useEventListener(target, \"drop\", (event) => {\n      var _a, _b;\n      event.preventDefault();\n      counter = 0;\n      isOverDropZone.value = false;\n      const files = Array.from((_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);\n      onDrop == null ? void 0 : onDrop(files.length === 0 ? null : files);\n    });\n  }\n  return {\n    isOverDropZone\n  };\n}\n\nvar __getOwnPropSymbols$g = Object.getOwnPropertySymbols;\nvar __hasOwnProp$g = Object.prototype.hasOwnProperty;\nvar __propIsEnum$g = Object.prototype.propertyIsEnumerable;\nvar __objRest$2 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$g)\n    for (var prop of __getOwnPropSymbols$g(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction useResizeObserver(target, callback, options = {}) {\n  const _a = options, { window = defaultWindow } = _a, observerOptions = __objRest$2(_a, [\"window\"]);\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(\n    () => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]\n  );\n  const stopWatch = watch(\n    targets,\n    (els) => {\n      cleanup();\n      if (isSupported.value && window) {\n        observer = new ResizeObserver(callback);\n        for (const _el of els)\n          _el && observer.observe(_el, observerOptions);\n      }\n    },\n    { immediate: true, flush: \"post\", deep: true }\n  );\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true\n  } = options;\n  const height = ref(0);\n  const bottom = ref(0);\n  const left = ref(0);\n  const right = ref(0);\n  const top = ref(0);\n  const width = ref(0);\n  const x = ref(0);\n  const y = ref(0);\n  function update() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  useResizeObserver(target, update);\n  watch(() => unrefElement(target), (ele) => !ele && update());\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { capture: true, passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  tryOnMounted(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nvar __defProp$e = Object.defineProperty;\nvar __getOwnPropSymbols$f = Object.getOwnPropertySymbols;\nvar __hasOwnProp$f = Object.prototype.hasOwnProperty;\nvar __propIsEnum$f = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$e = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$f.call(b, prop))\n      __defNormalProp$e(a, prop, b[prop]);\n  if (__getOwnPropSymbols$f)\n    for (var prop of __getOwnPropSymbols$f(b)) {\n      if (__propIsEnum$f.call(b, prop))\n        __defNormalProp$e(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useElementByPoint(options) {\n  const element = ref(null);\n  const { x, y, document = defaultDocument } = options;\n  const controls = useRafFn(() => {\n    element.value = (document == null ? void 0 : document.elementFromPoint(toValue(x), toValue(y))) || null;\n  });\n  return __spreadValues$e({\n    element\n  }, controls);\n}\n\nfunction useElementHover(el, options = {}) {\n  const {\n    delayEnter = 0,\n    delayLeave = 0,\n    window = defaultWindow\n  } = options;\n  const isHovered = ref(false);\n  let timer;\n  const toggle = (entering) => {\n    const delay = entering ? delayEnter : delayLeave;\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n    if (delay)\n      timer = setTimeout(() => isHovered.value = entering, delay);\n    else\n      isHovered.value = entering;\n  };\n  if (!window)\n    return isHovered;\n  useEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\n  useEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { window = defaultWindow, box = \"content-box\" } = options;\n  const isSVG = computed(() => {\n    var _a, _b;\n    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes(\"svg\");\n  });\n  const width = ref(initialSize.width);\n  const height = ref(initialSize.height);\n  useResizeObserver(\n    target,\n    ([entry]) => {\n      const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n      if (window && isSVG.value) {\n        const $elem = unrefElement(target);\n        if ($elem) {\n          const styles = window.getComputedStyle($elem);\n          width.value = parseFloat(styles.width);\n          height.value = parseFloat(styles.height);\n        }\n      } else {\n        if (boxSize) {\n          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];\n          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n        } else {\n          width.value = entry.contentRect.width;\n          height.value = entry.contentRect.height;\n        }\n      }\n    },\n    options\n  );\n  watch(\n    () => unrefElement(target),\n    (ele) => {\n      width.value = ele ? initialSize.width : 0;\n      height.value = ele ? initialSize.height : 0;\n    }\n  );\n  return {\n    width,\n    height\n  };\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0.1,\n    window = defaultWindow,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  const targets = computed(() => {\n    const _target = toValue(target);\n    return (Array.isArray(_target) ? _target : [_target]).map(unrefElement).filter(notNullish);\n  });\n  let cleanup = noop;\n  const isActive = ref(immediate);\n  const stopWatch = isSupported.value ? watch(\n    () => [targets.value, unrefElement(root), isActive.value],\n    ([targets2, root2]) => {\n      cleanup();\n      if (!isActive.value)\n        return;\n      if (!targets2.length)\n        return;\n      const observer = new IntersectionObserver(\n        callback,\n        {\n          root: unrefElement(root2),\n          rootMargin,\n          threshold\n        }\n      );\n      targets2.forEach((el) => el && observer.observe(el));\n      cleanup = () => {\n        observer.disconnect();\n        cleanup = noop;\n      };\n    },\n    { immediate, flush: \"post\" }\n  ) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n    isActive.value = false;\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    isActive,\n    pause() {\n      cleanup();\n      isActive.value = false;\n    },\n    resume() {\n      isActive.value = true;\n    },\n    stop\n  };\n}\n\nfunction useElementVisibility(element, { window = defaultWindow, scrollTarget } = {}) {\n  const elementIsVisible = ref(false);\n  useIntersectionObserver(\n    element,\n    ([{ isIntersecting }]) => {\n      elementIsVisible.value = isIntersecting;\n    },\n    {\n      root: scrollTarget,\n      window\n    }\n  );\n  return elementIsVisible;\n}\n\nconst events = /* @__PURE__ */ new Map();\n\nfunction useEventBus(key) {\n  const scope = getCurrentScope();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || /* @__PURE__ */ new Set();\n    listeners.add(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    listeners.delete(listener);\n    if (!listeners.size)\n      reset();\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction useEventSource(url, events = [], options = {}) {\n  const event = ref(null);\n  const data = ref(null);\n  const status = ref(\"CONNECTING\");\n  const eventSource = ref(null);\n  const error = shallowRef(null);\n  const {\n    withCredentials = false\n  } = options;\n  const close = () => {\n    if (eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n    }\n  };\n  const es = new EventSource(url, { withCredentials });\n  eventSource.value = es;\n  es.onopen = () => {\n    status.value = \"OPEN\";\n    error.value = null;\n  };\n  es.onerror = (e) => {\n    status.value = \"CLOSED\";\n    error.value = e;\n  };\n  es.onmessage = (e) => {\n    event.value = null;\n    data.value = e.data;\n  };\n  for (const event_name of events) {\n    useEventListener(es, event_name, (e) => {\n      event.value = event_name;\n      data.value = e.data || null;\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    close\n  };\n}\n\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = ref(initialValue);\n  async function open(openOptions) {\n    if (!isSupported.value)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = toRef(newIcon);\n  const applyIcon = (icon) => {\n    document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`).forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  watch(\n    favicon,\n    (i, o) => {\n      if (typeof i === \"string\" && i !== o)\n        applyIcon(i);\n    },\n    { immediate: true }\n  );\n  return favicon;\n}\n\nvar __defProp$d = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$e = Object.getOwnPropertySymbols;\nvar __hasOwnProp$e = Object.prototype.hasOwnProperty;\nvar __propIsEnum$e = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$d = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$e.call(b, prop))\n      __defNormalProp$d(a, prop, b[prop]);\n  if (__getOwnPropSymbols$e)\n    for (var prop of __getOwnPropSymbols$e(b)) {\n      if (__propIsEnum$e.call(b, prop))\n        __defNormalProp$d(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\"\n};\nfunction isFetchOptions(obj) {\n  return obj && containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\");\n}\nfunction isAbsoluteURL(url) {\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\nfunction headersToObject(headers) {\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\n    return Object.fromEntries([...headers.entries()]);\n  return headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n  if (combination === \"overwrite\") {\n    return async (ctx) => {\n      const callback = callbacks[callbacks.length - 1];\n      if (callback)\n        return __spreadValues$d(__spreadValues$d({}, ctx), await callback(ctx));\n      return ctx;\n    };\n  } else {\n    return async (ctx) => {\n      for (const callback of callbacks) {\n        if (callback)\n          ctx = __spreadValues$d(__spreadValues$d({}, ctx), await callback(ctx));\n      }\n      return ctx;\n    };\n  }\n}\nfunction createFetch(config = {}) {\n  const _combination = config.combination || \"chain\";\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = computed(() => {\n      const baseUrl = toValue(config.baseUrl);\n      const targetUrl = toValue(url);\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n    });\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = __spreadProps$4(__spreadValues$d(__spreadValues$d({}, options), args[0]), {\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n        });\n      } else {\n        fetchOptions = __spreadProps$4(__spreadValues$d(__spreadValues$d({}, fetchOptions), args[0]), {\n          headers: __spreadValues$d(__spreadValues$d({}, headersToObject(fetchOptions.headers) || {}), headersToObject(args[0].headers) || {})\n        });\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1])) {\n      options = __spreadProps$4(__spreadValues$d(__spreadValues$d({}, options), args[1]), {\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n      });\n    }\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = { immediate: true, refetch: false, timeout: 0 };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = __spreadValues$d(__spreadValues$d({}, options), args[0]);\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = __spreadValues$d(__spreadValues$d({}, options), args[1]);\n  }\n  const {\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = createEventHook();\n  const errorEvent = createEventHook();\n  const finallyEvent = createEventHook();\n  const isFinished = ref(false);\n  const isFetching = ref(false);\n  const aborted = ref(false);\n  const statusCode = ref(null);\n  const response = shallowRef(null);\n  const error = shallowRef(null);\n  const data = shallowRef(initialData || null);\n  const canAbort = computed(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = () => {\n    if (supportsAbort) {\n      controller == null ? void 0 : controller.abort();\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = __spreadProps$4(__spreadValues$d({}, fetchOptions), {\n        signal: controller.signal\n      });\n    }\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\n  const execute = async (throwOnFailed = false) => {\n    var _a2;\n    abort();\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    if (config.payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      const payload = toValue(config.payload);\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n    }\n    let isCanceled = false;\n    const context = {\n      url: toValue(url),\n      options: __spreadValues$d(__spreadValues$d({}, defaultFetchOptions), fetchOptions),\n      cancel: () => {\n        isCanceled = true;\n      }\n    };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return new Promise((resolve, reject) => {\n      var _a3;\n      fetch(\n        context.url,\n        __spreadProps$4(__spreadValues$d(__spreadValues$d({}, defaultFetchOptions), context.options), {\n          headers: __spreadValues$d(__spreadValues$d({}, headersToObject(defaultFetchOptions.headers)), headersToObject((_a3 = context.options) == null ? void 0 : _a3.headers))\n        })\n      ).then(async (fetchResponse) => {\n        response.value = fetchResponse;\n        statusCode.value = fetchResponse.status;\n        responseData = await fetchResponse[config.type]();\n        if (!fetchResponse.ok) {\n          data.value = initialData || null;\n          throw new Error(fetchResponse.statusText);\n        }\n        if (options.afterFetch)\n          ({ data: responseData } = await options.afterFetch({ data: responseData, response: fetchResponse }));\n        data.value = responseData;\n        responseEvent.trigger(fetchResponse);\n        return resolve(fetchResponse);\n      }).catch(async (fetchError) => {\n        let errorData = fetchError.message || fetchError.name;\n        if (options.onFetchError)\n          ({ error: errorData } = await options.onFetchError({ data: responseData, error: fetchError, response: response.value }));\n        error.value = errorData;\n        errorEvent.trigger(fetchError);\n        if (throwOnFailed)\n          return reject(fetchError);\n        return resolve(null);\n      }).finally(() => {\n        loading(false);\n        if (timer)\n          timer.stop();\n        finallyEvent.trigger(null);\n      });\n    });\n  };\n  const refetch = toRef(options.refetch);\n  watch(\n    [\n      refetch,\n      toRef(url)\n    ],\n    ([refetch2]) => refetch2 && execute(),\n    { deep: true }\n  );\n  const shell = {\n    isFinished,\n    statusCode,\n    response,\n    error,\n    data,\n    isFetching,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    // method\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    // type\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if (isRef(config.payload)) {\n          watch(\n            [\n              refetch,\n              toRef(config.payload)\n            ],\n            ([refetch2]) => refetch2 && execute(),\n            { deep: true }\n          );\n        }\n        const rawPayload = toValue(config.payload);\n        if (!payloadType && rawPayload && Object.getPrototypeOf(rawPayload) === Object.prototype && !(rawPayload instanceof FormData))\n          config.payloadType = \"json\";\n        return __spreadProps$4(__spreadValues$d({}, shell), {\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        });\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return __spreadProps$4(__spreadValues$d({}, shell), {\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        });\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    Promise.resolve().then(() => execute());\n  return __spreadProps$4(__spreadValues$d({}, shell), {\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  });\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\"))\n    return `${start}/${end}`;\n  return `${start}${end}`;\n}\n\nvar __defProp$c = Object.defineProperty;\nvar __getOwnPropSymbols$d = Object.getOwnPropertySymbols;\nvar __hasOwnProp$d = Object.prototype.hasOwnProperty;\nvar __propIsEnum$d = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$c = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$d.call(b, prop))\n      __defNormalProp$c(a, prop, b[prop]);\n  if (__getOwnPropSymbols$d)\n    for (var prop of __getOwnPropSymbols$d(b)) {\n      if (__propIsEnum$d.call(b, prop))\n        __defNormalProp$c(a, prop, b[prop]);\n    }\n  return a;\n};\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: \"*\"\n};\nfunction useFileDialog(options = {}) {\n  const {\n    document = defaultDocument\n  } = options;\n  const files = ref(null);\n  const { on: onChange, trigger } = createEventHook();\n  let input;\n  if (document) {\n    input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.onchange = (event) => {\n      const result = event.target;\n      files.value = result.files;\n      trigger(files.value);\n    };\n  }\n  const open = (localOptions) => {\n    if (!input)\n      return;\n    const _options = __spreadValues$c(__spreadValues$c(__spreadValues$c({}, DEFAULT_OPTIONS), options), localOptions);\n    input.multiple = _options.multiple;\n    input.accept = _options.accept;\n    if (hasOwn(_options, \"capture\"))\n      input.capture = _options.capture;\n    input.click();\n  };\n  const reset = () => {\n    files.value = null;\n    if (input)\n      input.value = \"\";\n  };\n  return {\n    files: readonly(files),\n    open,\n    reset,\n    onChange\n  };\n}\n\nvar __defProp$b = Object.defineProperty;\nvar __getOwnPropSymbols$c = Object.getOwnPropertySymbols;\nvar __hasOwnProp$c = Object.prototype.hasOwnProperty;\nvar __propIsEnum$c = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$b = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$c.call(b, prop))\n      __defNormalProp$b(a, prop, b[prop]);\n  if (__getOwnPropSymbols$c)\n    for (var prop of __getOwnPropSymbols$c(b)) {\n      if (__propIsEnum$c.call(b, prop))\n        __defNormalProp$b(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = options;\n  const window = _window;\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = ref();\n  const data = ref();\n  const file = ref();\n  const fileName = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported.value)\n      return;\n    const [handle] = await window.showOpenFilePicker(__spreadValues$b(__spreadValues$b({}, toValue(options)), _options));\n    fileHandle.value = handle;\n    await updateFile();\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker(__spreadValues$b(__spreadValues$b({}, options), _options));\n    data.value = void 0;\n    await updateFile();\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported.value)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker(__spreadValues$b(__spreadValues$b({}, options), _options));\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    const type = toValue(dataType);\n    if (type === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    else if (type === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    else if (type === \"Blob\")\n      data.value = file.value;\n  }\n  watch(() => toValue(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false } = options;\n  const innerFocused = ref(false);\n  const targetElement = computed(() => unrefElement(target));\n  useEventListener(targetElement, \"focus\", () => innerFocused.value = true);\n  useEventListener(targetElement, \"blur\", () => innerFocused.value = false);\n  const focused = computed({\n    get: () => innerFocused.value,\n    set(value) {\n      var _a, _b;\n      if (!value && innerFocused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      else if (value && !innerFocused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus();\n    }\n  });\n  watch(\n    targetElement,\n    () => {\n      focused.value = initialValue;\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  return { focused };\n}\n\nfunction useFocusWithin(target, options = {}) {\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);\n  return { focused };\n}\n\nfunction useFps(options) {\n  var _a;\n  const fps = ref(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst eventHandlers = [\n  \"fullscreenchange\",\n  \"webkitfullscreenchange\",\n  \"webkitendfullscreen\",\n  \"mozfullscreenchange\",\n  \"MSFullscreenChange\"\n];\nfunction useFullscreen(target, options = {}) {\n  const {\n    document = defaultDocument,\n    autoExit = false\n  } = options;\n  const targetRef = computed(() => {\n    var _a;\n    return (_a = unrefElement(target)) != null ? _a : document == null ? void 0 : document.querySelector(\"html\");\n  });\n  const isFullscreen = ref(false);\n  const requestMethod = computed(() => {\n    return [\n      \"requestFullscreen\",\n      \"webkitRequestFullscreen\",\n      \"webkitEnterFullscreen\",\n      \"webkitEnterFullScreen\",\n      \"webkitRequestFullScreen\",\n      \"mozRequestFullScreen\",\n      \"msRequestFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const exitMethod = computed(() => {\n    return [\n      \"exitFullscreen\",\n      \"webkitExitFullscreen\",\n      \"webkitExitFullScreen\",\n      \"webkitCancelFullScreen\",\n      \"mozCancelFullScreen\",\n      \"msExitFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenEnabled = computed(() => {\n    return [\n      \"fullScreen\",\n      \"webkitIsFullScreen\",\n      \"webkitDisplayingFullscreen\",\n      \"mozFullScreen\",\n      \"msFullscreenElement\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenElementMethod = [\n    \"fullscreenElement\",\n    \"webkitFullscreenElement\",\n    \"mozFullScreenElement\",\n    \"msFullscreenElement\"\n  ].find((m) => document && m in document);\n  const isSupported = useSupported(\n    () => targetRef.value && document && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0\n  );\n  const isCurrentElementFullScreen = () => {\n    if (fullscreenElementMethod)\n      return (document == null ? void 0 : document[fullscreenElementMethod]) === targetRef.value;\n    return false;\n  };\n  const isElementFullScreen = () => {\n    if (fullscreenEnabled.value) {\n      if (document && document[fullscreenEnabled.value] != null) {\n        return document[fullscreenEnabled.value];\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {\n          return Boolean(target2[fullscreenEnabled.value]);\n        }\n      }\n    }\n    return false;\n  };\n  async function exit() {\n    if (!isSupported.value)\n      return;\n    if (exitMethod.value) {\n      if ((document == null ? void 0 : document[exitMethod.value]) != null) {\n        await document[exitMethod.value]();\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)\n          await target2[exitMethod.value]();\n      }\n    }\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported.value)\n      return;\n    if (isElementFullScreen())\n      await exit();\n    const target2 = targetRef.value;\n    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {\n      await target2[requestMethod.value]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    await (isFullscreen.value ? exit() : enter());\n  }\n  const handlerCallback = () => {\n    const isElementFullScreenValue = isElementFullScreen();\n    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())\n      isFullscreen.value = isElementFullScreenValue;\n  };\n  useEventListener(document, eventHandlers, handlerCallback, false);\n  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, false);\n  if (autoExit)\n    tryOnScopeDispose(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return computed(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\n  const gamepads = ref([]);\n  const onConnectedHook = createEventHook();\n  const onDisconnectedHook = createEventHook();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return {\n      id: gamepad.id,\n      hapticActuators,\n      index: gamepad.index,\n      mapping: gamepad.mapping,\n      connected: gamepad.connected,\n      timestamp: gamepad.timestamp,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\n    };\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (let i = 0; i < _gamepads.length; ++i) {\n      const gamepad = _gamepads[i];\n      if (gamepad) {\n        const index = gamepads.value.findIndex(({ index: index2 }) => index2 === gamepad.index);\n        if (index > -1)\n          gamepads.value[index] = stateFromGamepad(gamepad);\n      }\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad));\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad));\n  tryOnMounted(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    if (_gamepads) {\n      for (let i = 0; i < _gamepads.length; ++i) {\n        const gamepad = _gamepads[i];\n        if (gamepad)\n          onGamepadConnected(gamepad);\n      }\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\n  const locatedAt = ref(null);\n  const error = shallowRef(null);\n  const coords = ref({\n    accuracy: 0,\n    latitude: Infinity,\n    longitude: Infinity,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  function resume() {\n    if (isSupported.value) {\n      watcher = navigator.geolocation.watchPosition(\n        updatePosition,\n        (err) => error.value = err,\n        {\n          enableHighAccuracy,\n          maximumAge,\n          timeout\n        }\n      );\n    }\n  }\n  if (immediate)\n    resume();\n  function pause() {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  }\n  tryOnScopeDispose(() => {\n    pause();\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error,\n    resume,\n    pause\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = throttleFilter(50)\n  } = options;\n  const idle = ref(initialState);\n  const lastActive = ref(timestamp());\n  let timer;\n  const reset = () => {\n    idle.value = false;\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  };\n  const onEvent = createFilterWrapper(\n    eventFilter,\n    () => {\n      lastActive.value = timestamp();\n      reset();\n    }\n  );\n  if (window) {\n    const document = window.document;\n    for (const event of events)\n      useEventListener(window, event, onEvent, { passive: true });\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      });\n    }\n    reset();\n  }\n  return {\n    idle,\n    lastActive,\n    reset\n  };\n}\n\nvar __defProp$a = Object.defineProperty;\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$a = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$b.call(b, prop))\n      __defNormalProp$a(a, prop, b[prop]);\n  if (__getOwnPropSymbols$b)\n    for (var prop of __getOwnPropSymbols$b(b)) {\n      if (__propIsEnum$b.call(b, prop))\n        __defNormalProp$a(a, prop, b[prop]);\n    }\n  return a;\n};\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes, class: clazz, loading, crossorigin } = options;\n    img.src = src;\n    if (srcset)\n      img.srcset = srcset;\n    if (sizes)\n      img.sizes = sizes;\n    if (clazz)\n      img.className = clazz;\n    if (loading)\n      img.loading = loading;\n    if (crossorigin)\n      img.crossOrigin = crossorigin;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nfunction useImage(options, asyncStateOptions = {}) {\n  const state = useAsyncState(\n    () => loadImage(toValue(options)),\n    void 0,\n    __spreadValues$a({\n      resetOnExecute: true\n    }, asyncStateOptions)\n  );\n  watch(\n    () => toValue(options),\n    () => state.execute(asyncStateOptions.delay),\n    { deep: true }\n  );\n  return state;\n}\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\"\n  } = options;\n  const internalX = ref(0);\n  const internalY = ref(0);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c;\n    const _element = toValue(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = toValue(_y)) != null ? _a : y.value,\n      left: (_b = toValue(_x)) != null ? _b : x.value,\n      behavior: toValue(behavior)\n    });\n  }\n  const isScrolling = ref(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = (e) => {\n    if (!isScrolling.value)\n      return;\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  };\n  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);\n  const setArrivedState = (target) => {\n    const el = target === document ? target.documentElement : target;\n    const { display, flexDirection } = getComputedStyle(el);\n    const scrollLeft = el.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalX.value;\n    const left = Math.abs(scrollLeft) <= 0 + (offset.left || 0);\n    const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"row-reverse\") {\n      arrivedState.left = right;\n      arrivedState.right = left;\n    } else {\n      arrivedState.left = left;\n      arrivedState.right = right;\n    }\n    internalX.value = scrollLeft;\n    let scrollTop = el.scrollTop;\n    if (target === document && !scrollTop)\n      scrollTop = document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    const top = Math.abs(scrollTop) <= 0 + (offset.top || 0);\n    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"column-reverse\") {\n      arrivedState.top = bottom;\n      arrivedState.bottom = top;\n    } else {\n      arrivedState.top = top;\n      arrivedState.bottom = bottom;\n    }\n    internalY.value = scrollTop;\n  };\n  const onScrollHandler = (e) => {\n    const eventTarget = e.target === document ? e.target.documentElement : e.target;\n    setArrivedState(eventTarget);\n    isScrolling.value = true;\n    onScrollEndDebounced(e);\n    onScroll(e);\n  };\n  useEventListener(\n    element,\n    \"scroll\",\n    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,\n    eventListenerOptions\n  );\n  useEventListener(\n    element,\n    \"scrollend\",\n    onScrollEnd,\n    eventListenerOptions\n  );\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions,\n    measure() {\n      const _element = toValue(element);\n      if (_element)\n        setArrivedState(_element);\n    }\n  };\n}\n\nvar __defProp$9 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$9 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$a.call(b, prop))\n      __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a)\n    for (var prop of __getOwnPropSymbols$a(b)) {\n      if (__propIsEnum$a.call(b, prop))\n        __defNormalProp$9(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a;\n  const {\n    direction = \"bottom\",\n    interval = 100\n  } = options;\n  const state = reactive(useScroll(\n    element,\n    __spreadProps$3(__spreadValues$9({}, options), {\n      offset: __spreadValues$9({\n        [direction]: (_a = options.distance) != null ? _a : 0\n      }, options.offset)\n    })\n  ));\n  const promise = ref();\n  const isLoading = computed(() => !!promise.value);\n  function checkAndLoad() {\n    state.measure();\n    const el = toValue(element);\n    if (!el)\n      return;\n    const isNarrower = direction === \"bottom\" || direction === \"top\" ? el.scrollHeight <= el.clientHeight : el.scrollWidth <= el.clientWidth;\n    if (state.arrivedState[direction] || isNarrower) {\n      if (!promise.value) {\n        promise.value = Promise.all([\n          onLoadMore(state),\n          new Promise((resolve) => setTimeout(resolve, interval))\n        ]).finally(() => {\n          promise.value = null;\n          nextTick(() => checkAndLoad());\n        });\n      }\n    }\n  }\n  watch(\n    () => [state.arrivedState[direction], toValue(element)],\n    checkAndLoad,\n    { immediate: true }\n  );\n  return {\n    isLoading\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = ref(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = noop\n  } = options;\n  const current = reactive(/* @__PURE__ */ new Set());\n  const obj = {\n    toJSON() {\n      return {};\n    },\n    current\n  };\n  const refs = useReactive ? reactive(obj) : obj;\n  const metaDeps = /* @__PURE__ */ new Set();\n  const usedKeys = /* @__PURE__ */ new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function reset() {\n    current.clear();\n    for (const key of usedKeys)\n      setRefs(key, false);\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (key) {\n      if (value)\n        current.add(key);\n      else\n        current.delete(key);\n    }\n    for (const key2 of values) {\n      usedKeys.add(key2);\n      setRefs(key2, value);\n    }\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  useEventListener(target, \"keydown\", (e) => {\n    updateRefs(e, true);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(target, \"keyup\", (e) => {\n    updateRefs(e, false);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(\"blur\", reset, { passive: true });\n  useEventListener(\"focus\", reset, { passive: true });\n  const proxy = new Proxy(\n    refs,\n    {\n      get(target2, prop, rec) {\n        if (typeof prop !== \"string\")\n          return Reflect.get(target2, prop, rec);\n        prop = prop.toLowerCase();\n        if (prop in aliasMap)\n          prop = aliasMap[prop];\n        if (!(prop in refs)) {\n          if (/[+_-]/.test(prop)) {\n            const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n            refs[prop] = computed(() => keys.every((key) => toValue(proxy[key])));\n          } else {\n            refs[prop] = ref(false);\n          }\n        }\n        const r = Reflect.get(target2, prop, rec);\n        return useReactive ? toValue(r) : r;\n      }\n    }\n  );\n  return proxy;\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$8 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$9.call(b, prop))\n      __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9)\n    for (var prop of __getOwnPropSymbols$9(b)) {\n      if (__propIsEnum$9.call(b, prop))\n        __defNormalProp$8(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction usingElRef(source, cb) {\n  if (toValue(source))\n    cb(toValue(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  options = __spreadValues$8(__spreadValues$8({}, defaultOptions), options);\n  const {\n    document = defaultDocument\n  } = options;\n  const currentTime = ref(0);\n  const duration = ref(0);\n  const seeking = ref(false);\n  const volume = ref(1);\n  const waiting = ref(false);\n  const ended = ref(false);\n  const playing = ref(false);\n  const rate = ref(1);\n  const stalled = ref(false);\n  const buffered = ref([]);\n  const tracks = ref([]);\n  const selectedTrack = ref(-1);\n  const isPictureInPicture = ref(false);\n  const muted = ref(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = createEventHook();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = typeof track === \"number\" ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = typeof track === \"number\" ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  watchEffect(() => {\n    if (!document)\n      return;\n    const el = toValue(target);\n    if (!el)\n      return;\n    const src = toValue(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (typeof src === \"string\")\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if (isObject(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.removeEventListener(\"error\", sourceErrorEvent.trigger);\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.addEventListener(\"error\", sourceErrorEvent.trigger);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  tryOnScopeDispose(() => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.querySelectorAll(\"source\").forEach((e) => e.removeEventListener(\"error\", sourceErrorEvent.trigger));\n  });\n  watch([target, volume], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.volume = volume.value;\n  });\n  watch([target, muted], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.muted = muted.value;\n  });\n  watch([target, rate], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.playbackRate = rate.value;\n  });\n  watchEffect(() => {\n    if (!document)\n      return;\n    const textTracks = toValue(options.tracks);\n    const el = toValue(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    isPlaying ? el.play() : el.pause();\n  });\n  useEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime));\n  useEventListener(target, \"durationchange\", () => duration.value = toValue(target).duration);\n  useEventListener(target, \"progress\", () => buffered.value = timeRangeToArray(toValue(target).buffered));\n  useEventListener(target, \"seeking\", () => seeking.value = true);\n  useEventListener(target, \"seeked\", () => seeking.value = false);\n  useEventListener(target, \"waiting\", () => waiting.value = true);\n  useEventListener(target, \"playing\", () => {\n    waiting.value = false;\n    ended.value = false;\n  });\n  useEventListener(target, \"ratechange\", () => rate.value = toValue(target).playbackRate);\n  useEventListener(target, \"stalled\", () => stalled.value = true);\n  useEventListener(target, \"ended\", () => ended.value = true);\n  useEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false));\n  useEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true));\n  useEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true);\n  useEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false);\n  useEventListener(target, \"volumechange\", () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    volume.value = el.volume;\n    muted.value = el.muted;\n  });\n  const listeners = [];\n  const stop = watch([target], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks));\n  });\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    // Volume\n    volume,\n    muted,\n    // Tracks\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    // Picture in Picture\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    // Events\n    onSourceError: sourceErrorEvent.on\n  };\n}\n\nfunction getMapVue2Compat() {\n  const data = reactive({});\n  return {\n    get: (key) => data[key],\n    set: (key, value) => set(data, key, value),\n    has: (key) => hasOwn(data, key),\n    delete: (key) => del(data, key),\n    clear: () => {\n      Object.keys(data).forEach((key) => {\n        del(data, key);\n      });\n    }\n  };\n}\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return reactive(options.cache);\n    if (isVue2)\n      return getMapVue2Compat();\n    return reactive(/* @__PURE__ */ new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\nfunction useMemory(options = {}) {\n  const memory = ref();\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n  if (isSupported.value) {\n    const { interval = 1e3 } = options;\n    useIntervalFn(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nconst BuiltinExtractors = {\n  page: (event) => [event.pageX, event.pageY],\n  client: (event) => [event.clientX, event.clientY],\n  screen: (event) => [event.screenX, event.screenY],\n  movement: (event) => event instanceof Touch ? null : [event.movementX, event.movementY]\n};\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    target = window,\n    eventFilter\n  } = options;\n  const x = ref(initialValue.x);\n  const y = ref(initialValue.y);\n  const sourceType = ref(null);\n  const extractor = typeof type === \"function\" ? type : BuiltinExtractors[type];\n  const mouseHandler = (event) => {\n    const result = extractor(event);\n    if (result) {\n      [x.value, y.value] = result;\n      sourceType.value = \"mouse\";\n    }\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const result = extractor(event.touches[0]);\n      if (result) {\n        [x.value, y.value] = result;\n        sourceType.value = \"touch\";\n      }\n    }\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);\n  const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);\n  if (target) {\n    useEventListener(target, \"mousemove\", mouseHandlerWrapper, { passive: true });\n    useEventListener(target, \"dragover\", mouseHandlerWrapper, { passive: true });\n    if (touch && type !== \"movement\") {\n      useEventListener(target, \"touchstart\", touchHandlerWrapper, { passive: true });\n      useEventListener(target, \"touchmove\", touchHandlerWrapper, { passive: true });\n      if (resetOnTouchEnds)\n        useEventListener(target, \"touchend\", reset, { passive: true });\n    }\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = ref(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = ref(0);\n  const elementY = ref(0);\n  const elementPositionX = ref(0);\n  const elementPositionY = ref(0);\n  const elementHeight = ref(0);\n  const elementWidth = ref(0);\n  const isOutside = ref(true);\n  let stop = () => {\n  };\n  if (window) {\n    stop = watch(\n      [targetRef, x, y],\n      () => {\n        const el = unrefElement(targetRef);\n        if (!el)\n          return;\n        const {\n          left,\n          top,\n          width,\n          height\n        } = el.getBoundingClientRect();\n        elementPositionX.value = left + window.pageXOffset;\n        elementPositionY.value = top + window.pageYOffset;\n        elementHeight.value = height;\n        elementWidth.value = width;\n        const elX = x.value - elementPositionX.value;\n        const elY = y.value - elementPositionY.value;\n        isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n        if (handleOutside || !isOutside.value) {\n          elementX.value = elX;\n          elementY.value = elY;\n        }\n      },\n      { immediate: true }\n    );\n    useEventListener(document, \"mouseleave\", () => {\n      isOutside.value = true;\n    });\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = ref(initialValue);\n  const sourceType = ref(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => () => {\n    pressed.value = true;\n    sourceType.value = srcType;\n  };\n  const onReleased = () => {\n    pressed.value = false;\n    sourceType.value = null;\n  };\n  const target = computed(() => unrefElement(options.target) || window);\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), { passive: true });\n  useEventListener(window, \"mouseleave\", onReleased, { passive: true });\n  useEventListener(window, \"mouseup\", onReleased, { passive: true });\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), { passive: true });\n    useEventListener(window, \"drop\", onReleased, { passive: true });\n    useEventListener(window, \"dragend\", onReleased, { passive: true });\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), { passive: true });\n    useEventListener(window, \"touchend\", onReleased, { passive: true });\n    useEventListener(window, \"touchcancel\", onReleased, { passive: true });\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\nfunction useNavigatorLanguage(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\n  const language = ref(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  });\n  return {\n    isSupported,\n    language\n  };\n}\n\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\n  const isOnline = ref(true);\n  const saveData = ref(false);\n  const offlineAt = ref(void 0);\n  const onlineAt = ref(void 0);\n  const downlink = ref(void 0);\n  const downlinkMax = ref(void 0);\n  const rtt = ref(void 0);\n  const effectiveType = ref(void 0);\n  const type = ref(\"unknown\");\n  const connection = isSupported.value && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    });\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    });\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, false);\n  updateNetworkInformation();\n  return {\n    isSupported,\n    isOnline,\n    saveData,\n    offlineAt,\n    onlineAt,\n    downlink,\n    downlinkMax,\n    effectiveType,\n    rtt,\n    type\n  };\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$7 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$8.call(b, prop))\n      __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$8)\n    for (var prop of __getOwnPropSymbols$8(b)) {\n      if (__propIsEnum$8.call(b, prop))\n        __defNormalProp$7(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\"\n  } = options;\n  const now = ref(/* @__PURE__ */ new Date());\n  const update = () => now.value = /* @__PURE__ */ new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });\n  if (exposeControls) {\n    return __spreadValues$7({\n      now\n    }, controls);\n  } else {\n    return now;\n  }\n}\n\nfunction useObjectUrl(object) {\n  const url = ref();\n  const release = () => {\n    if (url.value)\n      URL.revokeObjectURL(url.value);\n    url.value = void 0;\n  };\n  watch(\n    () => toValue(object),\n    (newObject) => {\n      release();\n      if (newObject)\n        url.value = URL.createObjectURL(newObject);\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(release);\n  return readonly(url);\n}\n\nfunction useClamp(value, min, max) {\n  if (typeof value === \"function\" || isReadonly(value))\n    return computed(() => clamp(toValue(value), toValue(min), toValue(max)));\n  const _value = ref(value);\n  return computed({\n    get() {\n      return _value.value = clamp(_value.value, toValue(min), toValue(max));\n    },\n    set(value2) {\n      _value.value = clamp(value2, toValue(min), toValue(max));\n    }\n  });\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Infinity,\n    pageSize = 10,\n    page = 1,\n    onPageChange = noop,\n    onPageSizeChange = noop,\n    onPageCountChange = noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Infinity);\n  const pageCount = computed(() => Math.max(\n    1,\n    Math.ceil(toValue(total) / toValue(currentPageSize))\n  ));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = computed(() => currentPage.value === 1);\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\n  if (isRef(page))\n    syncRef(page, currentPage);\n  if (isRef(pageSize))\n    syncRef(pageSize, currentPageSize);\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  watch(currentPage, () => {\n    onPageChange(reactive(returnValue));\n  });\n  watch(currentPageSize, () => {\n    onPageSizeChange(reactive(returnValue));\n  });\n  watch(pageCount, () => {\n    onPageCountChange(reactive(returnValue));\n  });\n  return returnValue;\n}\n\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = ref(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    useEventListener(window, \"mouseout\", handler, { passive: true });\n    useEventListener(window.document, \"mouseleave\", handler, { passive: true });\n    useEventListener(window.document, \"mouseenter\", handler, { passive: true });\n  }\n  return isLeft;\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = reactive(useDeviceOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = computed(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0))\n      return \"deviceOrientation\";\n    return \"mouse\";\n  });\n  const roll = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      const value = -orientation.beta / 90;\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      const value = orientation.gamma / 90;\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nfunction useParentElement(element = useCurrentElement()) {\n  const parentElement = shallowRef();\n  const update = () => {\n    const el = unrefElement(element);\n    if (el)\n      parentElement.value = el.parentElement;\n  };\n  tryOnMounted(update);\n  watch(() => toValue(element), update);\n  return parentElement;\n}\n\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __objRest$1 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$7)\n    for (var prop of __getOwnPropSymbols$7(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction usePerformanceObserver(options, callback) {\n  const _a = options, {\n    window = defaultWindow,\n    immediate = true\n  } = _a, performanceOptions = __objRest$1(_a, [\n    \"window\",\n    \"immediate\"\n  ]);\n  const isSupported = useSupported(() => window && \"PerformanceObserver\" in window);\n  let observer;\n  const stop = () => {\n    observer == null ? void 0 : observer.disconnect();\n  };\n  const start = () => {\n    if (isSupported.value) {\n      stop();\n      observer = new PerformanceObserver(callback);\n      observer.observe(performanceOptions);\n    }\n  };\n  tryOnScopeDispose(stop);\n  if (immediate)\n    start();\n  return {\n    isSupported,\n    start,\n    stop\n  };\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$6 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$6.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(b)) {\n      if (__propIsEnum$6.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = ref(false);\n  const state = ref(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = objectPick(event, keys, false);\n  };\n  if (target) {\n    useEventListener(target, \"pointerdown\", handler, { passive: true });\n    useEventListener(target, \"pointermove\", handler, { passive: true });\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, { passive: true });\n  }\n  return __spreadProps$2(__spreadValues$6({}, toRefs(state)), {\n    isInside\n  });\n}\n\nfunction usePointerLock(target, options = {}) {\n  const { document = defaultDocument, pointerLockOptions } = options;\n  const isSupported = useSupported(() => document && \"pointerLockElement\" in document);\n  const element = ref();\n  const triggerElement = ref();\n  let targetElement;\n  if (isSupported.value) {\n    useEventListener(document, \"pointerlockchange\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        element.value = document.pointerLockElement;\n        if (!element.value)\n          targetElement = triggerElement.value = null;\n      }\n    });\n    useEventListener(document, \"pointerlockerror\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        const action = document.pointerLockElement ? \"release\" : \"acquire\";\n        throw new Error(`Failed to ${action} pointer lock.`);\n      }\n    });\n  }\n  async function lock(e, options2) {\n    var _a;\n    if (!isSupported.value)\n      throw new Error(\"Pointer Lock API is not supported by your browser.\");\n    triggerElement.value = e instanceof Event ? e.currentTarget : null;\n    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);\n    if (!targetElement)\n      throw new Error(\"Target element undefined.\");\n    targetElement.requestPointerLock(options2 != null ? options2 : pointerLockOptions);\n    return await until(element).toBe(targetElement);\n  }\n  async function unlock() {\n    if (!element.value)\n      return false;\n    document.exitPointerLock();\n    await until(element).toBeNull();\n    return true;\n  }\n  return {\n    isSupported,\n    element,\n    triggerElement,\n    lock,\n    unlock\n  };\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = toRef(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart\n  } = options;\n  const posStart = reactive({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = reactive({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = computed(() => posStart.x - posEnd.x);\n  const distanceY = computed(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const isPointerDown = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return distanceY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const eventIsAllowed = (e) => {\n    var _a, _b, _c;\n    const isReleasingButton = e.buttons === 0;\n    const isPrimaryButton = e.buttons === 1;\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\n  };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      var _a, _b;\n      if (!eventIsAllowed(e))\n        return;\n      isPointerDown.value = true;\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }),\n    useEventListener(target, \"pointerup\", (e) => {\n      var _a, _b;\n      if (!eventIsAllowed(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"initial\");\n    })\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: readonly(isSwiping),\n    direction: readonly(direction),\n    posStart: readonly(posStart),\n    posEnd: readonly(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return computed(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredContrast(options) {\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n  return computed(() => {\n    if (isMore.value)\n      return \"more\";\n    if (isLess.value)\n      return \"less\";\n    if (isCustom.value)\n      return \"custom\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref([\"en\"]);\n  const navigator = window.navigator;\n  const value = ref(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  });\n  return value;\n}\n\nfunction usePreferredReducedMotion(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePrevious(value, initialValue) {\n  const previous = shallowRef(initialValue);\n  watch(\n    toRef(value),\n    (_, oldValue) => {\n      previous.value = oldValue;\n    },\n    { flush: \"sync\" }\n  );\n  return readonly(previous);\n}\n\nfunction useScreenOrientation(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\n  const orientation = ref(screenOrientation.type);\n  const angle = ref(screenOrientation.angle || 0);\n  if (isSupported.value) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    });\n  }\n  const lockOrientation = (type) => {\n    if (!isSupported.value)\n      return Promise.reject(new Error(\"Not supported\"));\n    return screenOrientation.lock(type);\n  };\n  const unlockOrientation = () => {\n    if (isSupported.value)\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n}\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = ref(\"\");\n  const right = ref(\"\");\n  const bottom = ref(\"\");\n  const left = ref(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    update();\n    useEventListener(\"resize\", useDebounceFn(update));\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {}\n  } = options;\n  const scriptTag = ref(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = toValue(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    el.addEventListener(\"error\", (event) => reject(event));\n    el.addEventListener(\"abort\", (event) => reject(event));\n    el.addEventListener(\"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    });\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnUnmounted(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction checkOverflowScroll(ele) {\n  const style = window.getComputedStyle(ele);\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientHeight < ele.scrollHeight || style.overflowY === \"auto\" && ele.clientWidth < ele.scrollWidth) {\n    return true;\n  } else {\n    const parent = ele.parentNode;\n    if (!parent || parent.tagName === \"BODY\")\n      return false;\n    return checkOverflowScroll(parent);\n  }\n}\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  const _target = e.target;\n  if (checkOverflowScroll(_target))\n    return false;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = ref(initialState);\n  let stopTouchMoveListener = null;\n  let initialOverflow;\n  watch(toRef(element), (el) => {\n    if (el) {\n      const ele = el;\n      initialOverflow = ele.style.overflow;\n      if (isLocked.value)\n        ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const ele = toValue(element);\n    if (!ele || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(\n        ele,\n        \"touchmove\",\n        (e) => {\n          preventDefault(e);\n        },\n        { passive: false }\n      );\n    }\n    ele.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    const ele = toValue(element);\n    if (!ele || !isLocked.value)\n      return;\n    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());\n    ele.style.overflow = initialOverflow;\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else\n        unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$5.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(b)) {\n      if (__propIsEnum$5.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\n  const share = async (overrideOptions = {}) => {\n    if (isSupported.value) {\n      const data = __spreadValues$5(__spreadValues$5({}, toValue(shareOptions)), toValue(overrideOptions));\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n  var _a, _b, _c, _d;\n  const [source] = args;\n  let compareFn = defaultCompare;\n  let options = {};\n  if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      options = args[1];\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\n    } else {\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\n    }\n  } else if (args.length > 2) {\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\n    options = (_d = args[2]) != null ? _d : {};\n  }\n  const {\n    dirty = false,\n    sortFn = defaultSortFn\n  } = options;\n  if (!dirty)\n    return computed(() => sortFn([...toValue(source)], compareFn));\n  watchEffect(() => {\n    const result = sortFn(toValue(source), compareFn);\n    if (isRef(source))\n      source.value = result;\n    else\n      source.splice(0, source.length, ...result);\n  });\n  return source;\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    window = defaultWindow\n  } = options;\n  const lang = toRef(options.lang || \"en-US\");\n  const isListening = ref(false);\n  const isFinal = ref(false);\n  const result = ref(\"\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isListening.value) => {\n    isListening.value = value;\n  };\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = useSupported(() => SpeechRecognition);\n  let recognition;\n  if (isSupported.value) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = toValue(lang);\n    recognition.onstart = () => {\n      isFinal.value = false;\n    };\n    watch(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const transcript = Array.from(event.results).map((result2) => {\n        isFinal.value = result2.isFinal;\n        return result2[0];\n      }).map((result2) => result2.transcript).join(\"\");\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = toValue(lang);\n    };\n    watch(isListening, () => {\n      if (isListening.value)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isListening.value = false;\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = useSupported(() => synth);\n  const isPlaying = ref(false);\n  const status = ref(\"init\");\n  const spokenText = toRef(text || \"\");\n  const lang = toRef(options.lang || \"en-US\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = toValue(lang);\n    utterance2.voice = toValue(options.voice) || null;\n    utterance2.pitch = pitch;\n    utterance2.rate = rate;\n    utterance2.volume = volume;\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n  };\n  const utterance = computed(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    utterance && synth.speak(utterance.value);\n  };\n  const stop = () => {\n    synth.cancel();\n    isPlaying.value = false;\n  };\n  if (isSupported.value) {\n    bindEventsForUtterance(utterance.value);\n    watch(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    if (options.voice) {\n      watch(options.voice, () => {\n        synth.cancel();\n      });\n    }\n    watch(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    utterance,\n    error,\n    stop,\n    toggle,\n    speak\n  };\n}\n\nfunction useStepper(steps, initialStep) {\n  const stepsRef = ref(steps);\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\n  const current = computed(() => at(index.value));\n  const isFirst = computed(() => index.value === 0);\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\n  const next = computed(() => stepNames.value[index.value + 1]);\n  const previous = computed(() => stepNames.value[index.value - 1]);\n  function at(index2) {\n    if (Array.isArray(stepsRef.value))\n      return stepsRef.value[index2];\n    return stepsRef.value[stepNames.value[index2]];\n  }\n  function get(step) {\n    if (!stepNames.value.includes(step))\n      return;\n    return at(stepNames.value.indexOf(step));\n  }\n  function goTo(step) {\n    if (stepNames.value.includes(step))\n      index.value = stepNames.value.indexOf(step);\n  }\n  function goToNext() {\n    if (isLast.value)\n      return;\n    index.value++;\n  }\n  function goToPrevious() {\n    if (isFirst.value)\n      return;\n    index.value--;\n  }\n  function goBackTo(step) {\n    if (isAfter(step))\n      goTo(step);\n  }\n  function isNext(step) {\n    return stepNames.value.indexOf(step) === index.value + 1;\n  }\n  function isPrevious(step) {\n    return stepNames.value.indexOf(step) === index.value - 1;\n  }\n  function isCurrent(step) {\n    return stepNames.value.indexOf(step) === index.value;\n  }\n  function isBefore(step) {\n    return index.value < stepNames.value.indexOf(step);\n  }\n  function isAfter(step) {\n    return index.value > stepNames.value.indexOf(step);\n  }\n  return {\n    steps: stepsRef,\n    stepNames,\n    index,\n    current,\n    next,\n    previous,\n    isFirst,\n    isLast,\n    at,\n    get,\n    goTo,\n    goToNext,\n    goToPrevious,\n    goBackTo,\n    isNext,\n    isPrevious,\n    isCurrent,\n    isBefore,\n    isAfter\n  };\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$4.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(b)) {\n      if (__propIsEnum$4.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const rawInit = toValue(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? shallowRef : ref)(initialValue);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else if (mergeDefaults) {\n        const value = await serializer.read(rawValue);\n        if (typeof mergeDefaults === \"function\")\n          data.value = mergeDefaults(value, rawInit);\n        else if (type === \"object\" && !Array.isArray(value))\n          data.value = __spreadValues$4(__spreadValues$4({}, rawInit), value);\n        else\n          data.value = value;\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  read();\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => Promise.resolve().then(() => read(e)));\n  if (storage) {\n    watchWithFilter(\n      data,\n      async () => {\n        try {\n          if (data.value == null)\n            await storage.removeItem(key);\n          else\n            await storage.setItem(key, await serializer.write(data.value));\n        } catch (e) {\n          onError(e);\n        }\n      },\n      {\n        flush,\n        deep,\n        eventFilter\n      }\n    );\n  }\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = ref(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = ref(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    if (!el.isConnected) {\n      el.type = \"text/css\";\n      el.id = id;\n      if (options.media)\n        el.media = options.media;\n      document.head.appendChild(el);\n    }\n    if (isLoaded.value)\n      return;\n    stop = watch(\n      cssRef,\n      (value) => {\n        el.textContent = value;\n      },\n      { immediate: true }\n    );\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnScopeDispose(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: readonly(isLoaded)\n  };\n}\n\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true,\n    window = defaultWindow\n  } = options;\n  const coordsStart = reactive({ x: 0, y: 0 });\n  const coordsEnd = reactive({ x: 0, y: 0 });\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return diffY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  let listenerOptions;\n  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);\n  if (!passive)\n    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };\n  else\n    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      if (listenerOptions.capture && !listenerOptions.passive)\n        e.preventDefault();\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchend\", onTouchEnd, listenerOptions),\n    useEventListener(target, \"touchcancel\", onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isPassiveEventSupported,\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop\n  };\n}\nfunction checkPassiveEventSupport(document) {\n  if (!document)\n    return false;\n  let supportsPassive = false;\n  const optionsBlock = {\n    get passive() {\n      supportsPassive = true;\n      return false;\n    }\n  };\n  document.addEventListener(\"x\", noop, optionsBlock);\n  document.removeEventListener(\"x\", noop);\n  return supportsPassive;\n}\n\nfunction useTemplateRefsList() {\n  const refs = ref([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  onBeforeUpdate(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\nfunction useTextDirection(options = {}) {\n  const {\n    document = defaultDocument,\n    selector = \"html\",\n    observe = false,\n    initialValue = \"ltr\"\n  } = options;\n  function getValue() {\n    var _a, _b;\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\n  }\n  const dir = ref(getValue());\n  tryOnMounted(() => dir.value = getValue());\n  if (observe && document) {\n    useMutationObserver(\n      document.querySelector(selector),\n      () => dir.value = getValue(),\n      { attributes: true }\n    );\n  }\n  return computed({\n    get() {\n      return dir.value;\n    },\n    set(v) {\n      var _a, _b;\n      dir.value = v;\n      if (!document)\n        return;\n      if (dir.value)\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\n      else\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\n    }\n  });\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  const ranges = new Array(rangeCount);\n  for (let i = 0; i < rangeCount; i++) {\n    const range = selection.getRangeAt(i);\n    ranges[i] = range;\n  }\n  return ranges;\n}\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = ref(null);\n  const text = computed(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange);\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nfunction useTextareaAutosize(options) {\n  const textarea = ref(options == null ? void 0 : options.element);\n  const input = ref(options == null ? void 0 : options.input);\n  const textareaScrollHeight = ref(1);\n  function triggerResize() {\n    var _a, _b;\n    if (!textarea.value)\n      return;\n    let height = \"\";\n    textarea.value.style.height = \"1px\";\n    textareaScrollHeight.value = (_a = textarea.value) == null ? void 0 : _a.scrollHeight;\n    if (options == null ? void 0 : options.styleTarget)\n      toValue(options.styleTarget).style.height = `${textareaScrollHeight.value}px`;\n    else\n      height = `${textareaScrollHeight.value}px`;\n    textarea.value.style.height = height;\n    (_b = options == null ? void 0 : options.onResize) == null ? void 0 : _b.call(options);\n  }\n  watch([input, textarea], triggerResize, { immediate: true });\n  useResizeObserver(textarea, () => triggerResize());\n  if (options == null ? void 0 : options.watch)\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\n  return {\n    textarea,\n    input,\n    triggerResize\n  };\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = throttleFilter(throttle, trailing);\n  const history = useRefHistory(source, __spreadProps$1(__spreadValues$3({}, options), { eventFilter: filter }));\n  return __spreadValues$3({}, history);\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nconst DEFAULT_UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Infinity, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n  invalid: \"\"\n};\nfunction DEFAULT_FORMATTER(date) {\n  return date.toISOString().slice(0, 10);\n}\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const _a = useNow({ interval: updateInterval, controls: true }), { now } = _a, controls = __objRest(_a, [\"now\"]);\n  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now.value)));\n  if (exposeControls) {\n    return __spreadValues$2({\n      timeAgo\n    }, controls);\n  } else {\n    return timeAgo;\n  }\n}\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\n  var _a;\n  const {\n    max,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER,\n    units = DEFAULT_UNITS,\n    showSecond = false,\n    rounding = \"round\"\n  } = options;\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n  const diff = +now - +from;\n  const absDiff = Math.abs(diff);\n  function getValue(diff2, unit) {\n    return roundFn(Math.abs(diff2) / unit.value);\n  }\n  function format(diff2, unit) {\n    const val = getValue(diff2, unit);\n    const past = diff2 > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  if (absDiff < 6e4 && !showSecond)\n    return messages.justNow;\n  if (typeof max === \"number\" && absDiff > max)\n    return fullDateFormatter(new Date(from));\n  if (typeof max === \"string\") {\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\n    if (unitMax && absDiff > unitMax)\n      return fullDateFormatter(new Date(from));\n  }\n  for (const [idx, unit] of units.entries()) {\n    const val = getValue(diff, unit);\n    if (val <= 0 && units[idx - 1])\n      return format(diff, units[idx - 1]);\n    if (absDiff < unit.max)\n      return format(diff, unit);\n  }\n  return messages.invalid;\n}\n\nfunction useTimeoutPoll(fn, interval, timeoutPollOptions) {\n  const { start } = useTimeoutFn(loop, interval);\n  const isActive = ref(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      loop();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\",\n    callback\n  } = options;\n  const ts = ref(timestamp() + offset);\n  const update = () => ts.value = timestamp() + offset;\n  const cb = callback ? () => {\n    update();\n    callback(ts.value);\n  } : update;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  if (exposeControls) {\n    return __spreadValues$1({\n      timestamp: ts\n    }, controls);\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b;\n  const {\n    document = defaultDocument\n  } = options;\n  const title = toRef((_a = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _a : null);\n  const isReadonly = newTitle && typeof newTitle === \"function\";\n  function format(t) {\n    if (!(\"titleTemplate\" in options))\n      return t;\n    const template = options.titleTemplate || \"%s\";\n    return typeof template === \"function\" ? template(t) : toValue(template).replace(/%s/g, t);\n  }\n  watch(\n    title,\n    (t, o) => {\n      if (t !== o && document)\n        document.title = format(typeof t === \"string\" ? t : \"\");\n    },\n    { immediate: true }\n  );\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\n    useMutationObserver(\n      (_b = document.head) == null ? void 0 : _b.querySelector(\"title\"),\n      () => {\n        if (document && document.title !== title.value)\n          title.value = format(document.title);\n      },\n      { childList: true }\n    );\n  }\n  return title;\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _TransitionPresets = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nconst TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction lerp(a, b, alpha) {\n  return a + alpha * (b - a);\n}\nfunction toVec(t) {\n  return (typeof t === \"number\" ? [t] : t) || [];\n}\nfunction executeTransition(source, from, to, options = {}) {\n  var _a, _b;\n  const fromVal = toValue(from);\n  const toVal = toValue(to);\n  const v1 = toVec(fromVal);\n  const v2 = toVec(toVal);\n  const duration = (_a = toValue(options.duration)) != null ? _a : 1e3;\n  const startedAt = Date.now();\n  const endAt = Date.now() + duration;\n  const trans = typeof options.transition === \"function\" ? options.transition : (_b = toValue(options.transition)) != null ? _b : identity;\n  const ease = typeof trans === \"function\" ? trans : createEasingFunction(trans);\n  return new Promise((resolve) => {\n    source.value = fromVal;\n    const tick = () => {\n      var _a2;\n      if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {\n        resolve();\n        return;\n      }\n      const now = Date.now();\n      const alpha = ease((now - startedAt) / duration);\n      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha));\n      if (Array.isArray(source.value))\n        source.value = arr.map((n, i) => {\n          var _a3, _b2;\n          return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);\n        });\n      else if (typeof source.value === \"number\")\n        source.value = arr[0];\n      if (now < endAt) {\n        requestAnimationFrame(tick);\n      } else {\n        source.value = toVal;\n        resolve();\n      }\n    };\n    tick();\n  });\n}\nfunction useTransition(source, options = {}) {\n  let currentId = 0;\n  const sourceVal = () => {\n    const v = toValue(source);\n    return typeof v === \"number\" ? v : v.map(toValue);\n  };\n  const outputRef = ref(sourceVal());\n  watch(sourceVal, async (to) => {\n    var _a, _b;\n    if (toValue(options.disabled))\n      return;\n    const id = ++currentId;\n    if (options.delay)\n      await promiseTimeout(toValue(options.delay));\n    if (id !== currentId)\n      return;\n    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);\n    (_a = options.onStarted) == null ? void 0 : _a.call(options);\n    await executeTransition(outputRef, outputRef.value, toVal, __spreadProps(__spreadValues({}, options), {\n      abort: () => {\n        var _a2;\n        return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));\n      }\n    }));\n    (_b = options.onFinished) == null ? void 0 : _b.call(options);\n  }, { deep: true });\n  watch(() => toValue(options.disabled), (disabled) => {\n    if (disabled) {\n      currentId++;\n      outputRef.value = sourceVal();\n    }\n  });\n  tryOnScopeDispose(() => {\n    currentId++;\n  });\n  return computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value);\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    write: enableWrite = true,\n    window = defaultWindow\n  } = options;\n  if (!window)\n    return reactive(initialValue);\n  const state = reactive({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = params.toString();\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = pausableWatch(\n    state,\n    () => {\n      const params = new URLSearchParams(\"\");\n      Object.keys(state).forEach((key) => {\n        const mapEntry = state[key];\n        if (Array.isArray(mapEntry))\n          mapEntry.forEach((value) => params.append(key, value));\n        else if (removeNullishValues && mapEntry == null)\n          params.delete(key);\n        else if (removeFalsyValues && !mapEntry)\n          params.delete(key);\n        else\n          params.set(key, mapEntry);\n      });\n      write(params);\n    },\n    { deep: true }\n  );\n  function write(params, shouldUpdate) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    window.history.replaceState(\n      window.history.state,\n      window.document.title,\n      window.location.pathname + constructQuery(params)\n    );\n    resume();\n  }\n  function onChanged() {\n    if (!enableWrite)\n      return;\n    write(read(), true);\n  }\n  useEventListener(window, \"popstate\", onChanged, false);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, false);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = ref((_b = options.autoSwitch) != null ? _b : true);\n  const constraints = ref(options.constraints);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\n  });\n  const stream = shallowRef();\n  function getDeviceOptions(type) {\n    switch (type) {\n      case \"video\": {\n        if (constraints.value)\n          return constraints.value.video || false;\n        break;\n      }\n      case \"audio\": {\n        if (constraints.value)\n          return constraints.value.audio || false;\n        break;\n      }\n    }\n  }\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(\"video\"),\n      audio: getDeviceOptions(\"audio\")\n    });\n    return stream.value;\n  }\n  function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  watch(\n    constraints,\n    () => {\n      if (autoSwitch.value && stream.value)\n        restart();\n    },\n    { immediate: true }\n  );\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    constraints,\n    enabled,\n    autoSwitch\n  };\n}\n\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c, _d, _e;\n  const {\n    clone = false,\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue,\n    shouldEmit\n  } = options;\n  const vm = getCurrentInstance();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\n  let event = eventName;\n  if (!key) {\n    if (isVue2) {\n      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;\n      key = (modelOptions == null ? void 0 : modelOptions.value) || \"value\";\n      if (!eventName)\n        event = (modelOptions == null ? void 0 : modelOptions.event) || \"input\";\n    } else {\n      key = \"modelValue\";\n    }\n  }\n  event = eventName || event || `update:${key.toString()}`;\n  const cloneFn = (val) => !clone ? val : typeof clone === \"function\" ? clone(val) : cloneFnJSON(val);\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\n  const triggerEmit = (value) => {\n    if (shouldEmit) {\n      if (shouldEmit(value))\n        _emit(event, value);\n    } else {\n      _emit(event, value);\n    }\n  };\n  if (passive) {\n    const initialValue = getValue();\n    const proxy = ref(initialValue);\n    watch(\n      () => props[key],\n      (v) => proxy.value = cloneFn(v)\n    );\n    watch(\n      proxy,\n      (v) => {\n        if (v !== props[key] || deep)\n          triggerEmit(v);\n      },\n      { deep }\n    );\n    return proxy;\n  } else {\n    return computed({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        triggerEmit(value);\n      }\n    });\n  }\n}\n\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props)\n    ret[key] = useVModel(props, key, emit, options);\n  return ret;\n}\n\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\n  const patternRef = toRef(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported.value)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported.value)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = useIntervalFn(\n      vibrate,\n      interval,\n      {\n        immediate: false,\n        immediateCallback: false\n      }\n    );\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\nfunction useVirtualListResources(list) {\n  const containerRef = ref(null);\n  const size = useElementSize(containerRef);\n  const currentList = ref([]);\n  const source = shallowRef(list);\n  const state = ref({ start: 0, end: 10 });\n  return { state, source, currentList, size, containerRef };\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n  return (containerSize) => {\n    if (typeof itemSize === \"number\")\n      return Math.ceil(containerSize / itemSize);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      capacity = i;\n      if (sum > containerSize)\n        break;\n    }\n    return capacity - start;\n  };\n}\nfunction createGetOffset(source, itemSize) {\n  return (scrollDirection) => {\n    if (typeof itemSize === \"number\")\n      return Math.floor(scrollDirection / itemSize) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      if (sum >= scrollDirection) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n  return () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n}\nfunction createGetDistance(itemSize, source) {\n  return (index) => {\n    if (typeof itemSize === \"number\") {\n      const size2 = index * itemSize;\n      return size2;\n    }\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n    return size;\n  };\n}\nfunction useWatchForSizes(size, list, calculateRange) {\n  watch([size.width, size.height, list], () => {\n    calculateRange();\n  });\n}\nfunction createComputedTotalSize(itemSize, source) {\n  return computed(() => {\n    if (typeof itemSize === \"number\")\n      return source.value.length * itemSize;\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n  });\n}\nconst scrollToDictionaryForElementScrollKey = {\n  horizontal: \"scrollLeft\",\n  vertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n  return (index) => {\n    if (containerRef.value) {\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n      calculateRange();\n    }\n  };\n}\nfunction useHorizontalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowX: \"auto\" };\n  const { itemWidth, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n  const getOffset = createGetOffset(source, itemWidth);\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceLeft = createGetDistance(itemWidth, source);\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\n  const totalWidth = createComputedTotalSize(itemWidth, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        height: \"100%\",\n        width: `${totalWidth.value - offsetLeft.value}px`,\n        marginLeft: `${offsetLeft.value}px`,\n        display: \"flex\"\n      }\n    };\n  });\n  return {\n    scrollTo,\n    calculateRange,\n    wrapperProps,\n    containerStyle,\n    currentList,\n    containerRef\n  };\n}\nfunction useVerticalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowY: \"auto\" };\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n  const getOffset = createGetOffset(source, itemHeight);\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceTop = createGetDistance(itemHeight, source);\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\n  const totalHeight = createComputedTotalSize(itemHeight, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  return {\n    calculateRange,\n    scrollTo,\n    containerStyle,\n    wrapperProps,\n    currentList,\n    containerRef\n  };\n}\n\nfunction useWakeLock(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  let wakeLock;\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\n  const isActive = ref(false);\n  async function onVisibilityChange() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    if (document && document.visibilityState === \"visible\")\n      wakeLock = await navigator.wakeLock.request(\"screen\");\n    isActive.value = !wakeLock.released;\n  }\n  if (document)\n    useEventListener(document, \"visibilitychange\", onVisibilityChange, { passive: true });\n  async function request(type) {\n    if (!isSupported.value)\n      return;\n    wakeLock = await navigator.wakeLock.request(type);\n    isActive.value = !wakeLock.released;\n  }\n  async function release() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    await wakeLock.release();\n    isActive.value = !wakeLock.released;\n    wakeLock = null;\n  }\n  return {\n    isSupported,\n    isActive,\n    request,\n    release\n  };\n}\n\nfunction useWebNotification(defaultOptions = {}) {\n  const {\n    window = defaultWindow\n  } = defaultOptions;\n  const isSupported = useSupported(() => !!window && \"Notification\" in window);\n  const notification = ref(null);\n  const requestPermission = async () => {\n    if (!isSupported.value)\n      return;\n    if (\"permission\" in Notification && Notification.permission !== \"denied\")\n      await Notification.requestPermission();\n  };\n  const { on: onClick, trigger: clickTrigger } = createEventHook();\n  const { on: onShow, trigger: showTrigger } = createEventHook();\n  const { on: onError, trigger: errorTrigger } = createEventHook();\n  const { on: onClose, trigger: closeTrigger } = createEventHook();\n  const show = async (overrides) => {\n    if (!isSupported.value)\n      return;\n    await requestPermission();\n    const options = Object.assign({}, defaultOptions, overrides);\n    notification.value = new Notification(options.title || \"\", options);\n    notification.value.onclick = clickTrigger;\n    notification.value.onshow = showTrigger;\n    notification.value.onerror = errorTrigger;\n    notification.value.onclose = closeTrigger;\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  tryOnMounted(async () => {\n    if (isSupported.value)\n      await requestPermission();\n  });\n  tryOnScopeDispose(close);\n  if (isSupported.value && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n}\n\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = ref(null);\n  const status = ref(\"CLOSED\");\n  const wsRef = ref();\n  const urlRef = toRef(url);\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  let pongTimeoutWait;\n  const close = (code = 1e3, reason) => {\n    if (!wsRef.value)\n      return;\n    explicitlyClosed = true;\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n  };\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const resetHeartbeat = () => {\n    clearTimeout(pongTimeoutWait);\n    pongTimeoutWait = void 0;\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const ws = new WebSocket(urlRef.value, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      wsRef.value = void 0;\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      if (options.heartbeat) {\n        resetHeartbeat();\n        const {\n          message = DEFAULT_PING_MESSAGE\n        } = resolveNestedOptions(options.heartbeat);\n        if (e.data === message)\n          return;\n      }\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = DEFAULT_PING_MESSAGE,\n      interval = 1e3,\n      pongTimeout = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = useIntervalFn(\n      () => {\n        send(message, false);\n        if (pongTimeoutWait != null)\n          return;\n        pongTimeoutWait = setTimeout(() => {\n          close();\n        }, pongTimeout);\n      },\n      interval,\n      { immediate: false }\n    );\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (autoClose) {\n    useEventListener(window, \"beforeunload\", () => close());\n    tryOnScopeDispose(close);\n  }\n  const open = () => {\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    watch(urlRef, open, { immediate: true });\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(arg0, workerOptions, options) {\n  const {\n    window = defaultWindow\n  } = options != null ? options : {};\n  const data = ref(null);\n  const worker = shallowRef();\n  const post = function post2(val) {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(val);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    if (typeof arg0 === \"string\")\n      worker.value = new Worker(arg0, workerOptions);\n    else if (typeof arg0 === \"function\")\n      worker.value = arg0();\n    else\n      worker.value = arg0;\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    tryOnScopeDispose(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nfunction jobRunner(userFunc) {\n  return (e) => {\n    const userFuncArgs = e.data[0];\n    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n      postMessage([\"SUCCESS\", result]);\n    }).catch((error) => {\n      postMessage([\"ERROR\", error]);\n    });\n  };\n}\n\nfunction depsParser(deps) {\n  if (deps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  return `importScripts(${depsString})`;\n}\n\nfunction createWorkerBlobUrl(fn, deps) {\n  const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n}\n\nfunction useWebWorkerFn(fn, options = {}) {\n  const {\n    dependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = ref();\n  const workerStatus = ref(\"PENDING\");\n  const promise = ref({});\n  const timeoutId = ref();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  tryOnScopeDispose(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(\n        () => workerTerminate(\"TIMEOUT_EXPIRED\"),\n        timeout\n      );\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    promise.value = {\n      resolve,\n      reject\n    };\n    worker.value && worker.value.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\n        \"[useWebWorkerFn] You can only run one instance of the worker at a time.\"\n      );\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n}\n\nfunction useWindowFocus({ window = defaultWindow } = {}) {\n  if (!window)\n    return ref(false);\n  const focused = ref(window.document.hasFocus());\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  });\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  });\n  return focused;\n}\n\nfunction useWindowScroll({ window = defaultWindow } = {}) {\n  if (!window) {\n    return {\n      x: ref(0),\n      y: ref(0)\n    };\n  }\n  const x = ref(window.scrollX);\n  const y = ref(window.scrollY);\n  useEventListener(\n    window,\n    \"scroll\",\n    () => {\n      x.value = window.scrollX;\n      y.value = window.scrollY;\n    },\n    {\n      capture: false,\n      passive: true\n    }\n  );\n  return { x, y };\n}\n\nfunction useWindowSize(options = {}) {\n  const {\n    window = defaultWindow,\n    initialWidth = Infinity,\n    initialHeight = Infinity,\n    listenOrientation = true,\n    includeScrollbar = true\n  } = options;\n  const width = ref(initialWidth);\n  const height = ref(initialHeight);\n  const update = () => {\n    if (window) {\n      if (includeScrollbar) {\n        width.value = window.innerWidth;\n        height.value = window.innerHeight;\n      } else {\n        width.value = window.document.documentElement.clientWidth;\n        height.value = window.document.documentElement.clientHeight;\n      }\n    }\n  };\n  update();\n  tryOnMounted(update);\n  useEventListener(\"resize\", update, { passive: true });\n  if (listenOrientation) {\n    const matches = useMediaQuery(\"(orientation: portrait)\");\n    watch(matches, () => update());\n  }\n  return { width, height };\n}\n\nexport { DefaultMagicKeysAliasMap, StorageSerializers, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsMasterCss, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, cloneFnJSON, computedAsync, computedInject, createFetch, createReusableTemplate, createTemplatePromise, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, executeTransition, formatTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, setSSRHandler, templateRef, unrefElement, useActiveElement, useAnimate, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useCloned, useColorMode, useConfirmDialog, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, useParentElement, usePerformanceObserver, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePrevious, useRafFn, useRefHistory, useResizeObserver, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\n","/**\n * Util used to return true if the string is empty, undefined or null.\n *\n * @param str - String value.\n * @returns Returns true if str is an empty string, undefined or null.\n * @public\n */\nexport function isStringEmpty(str?: string | null): boolean {\n  return !str || str.length === 0;\n}\n\n/**\n * Util to transform string a into kebab case.\n *\n * @example\n * Transforms `camelCase` into `camel-case`\n * Transforms `PascalCase` into `pascal-case`\n * Transforms `snake_case` into `snake-case`\n * Transforms `space space  multispaces` into `space-space-multiplespaces`\n * Transforms `kebab-case` into `kebab-case`\n *\n * @param str - String value.\n * @returns Returns the string in kebab case.\n * @public\n */\nexport function toKebabCase(str: string): string {\n  return str\n    .replace(/([a-z])([A-Z])/g, '$1-$2')\n    .replace(/\\s+|_/g, '-')\n    .toLowerCase();\n}\n\n/**\n * Util to capitalize a string .\n *\n * @example\n * Transforms `query` into `Query`\n *\n * @param str - String value.\n *\n * @returns Returns the string capitalized.\n *\n * @public\n */\nexport function capitalize<StrType extends string>(str: StrType): Capitalize<StrType> {\n  return (str.charAt(0).toUpperCase() + str.slice(1)) as Capitalize<StrType>;\n}\n","import { reduce } from '@empathyco/x-utils';\nimport { useWindowSize, useScreenOrientation, useEventListener, useMemoize } from '@vueuse/core';\nimport { computed, effectScope, ref, Ref } from 'vue';\nimport { capitalize } from '../utils';\n\n/**\n * The Return type of the composable returned by `createUseDevice`.\n *\n * @public\n */\nexport type UseDeviceReturn<Device extends string = string> = {\n  orientation: Ref<'landscape' | 'portrait' | undefined>;\n  isTouchable: Ref<boolean>;\n  deviceName: Ref<string>;\n} & UseDeviceFlags<Device>;\n\n/**\n * The device flags type of the Return type of the composable returned by `createUseDevice`.\n *\n * @public\n */\nexport type UseDeviceFlags<Device extends string> = Record<\n  `is${Capitalize<Device>}`,\n  Ref<boolean>\n> &\n  Record<`is${Capitalize<Device>}OrGreater`, Ref<boolean>> &\n  Record<`is${Capitalize<Device>}OrLess`, Ref<boolean>>;\n\n/**\n * Factory function that creates a composable for device detection using the devices parameter\n * to configure breakpoints.\n *\n * @param devices - An object containing the breakpoints, where the key is the name of the device\n * and the value is the screen width.\n * @returns A composable which provides multiple reactive flags and values for detecting the\n * current device. The flags names depends on the names passed in the `devices` parameter.\n * @remarks The `orientation` only works for orientation-sensor devices (mobile, tablet, etc). If\n * in a desktop, the height of the window is larger than the width, the orientation will be\n * `landscape`.\n *\n * @example\n * ´´´typescript\n * const useDevice = createUseDevice(\\{ mobile: 0, tablet: 744, desktop: 1024 \\});\n * const \\{\n *   isMobile,\n *   isMobileOrLess,\n *   isMobileOrGreater,\n *   isTablet,\n *   isTabletOrLess,\n *   isTabletOrGreater,\n *   isDesktop,\n *   isDesktopOrLess,\n *   isDesktopOrGreater,\n *   deviceName,\n *   orientation,\n *   istTouchable\n * \\} = useDevice();\n *\n * @public\n */\nexport function createUseDevice<Device extends string>(\n  devices: Record<Device, number>\n): () => UseDeviceReturn<Device> {\n  let devicesFlags: UseDeviceFlags<Device>;\n  let orientation: UseDeviceReturn['orientation'];\n  let isTouchable: UseDeviceReturn['isTouchable'];\n  let deviceName: UseDeviceReturn['deviceName'];\n  // The `effectScope` group all the changes in one to avoid multiple re-renderings.\n  const scope = effectScope();\n  scope.run(() => {\n    devicesFlags = getDeviceFlags(devices);\n    orientation = getOrientation();\n    isTouchable = getIsTouchable();\n    deviceName = getDeviceName(devices, devicesFlags);\n  });\n  return () => ({\n    ...devicesFlags,\n    orientation,\n    isTouchable,\n    deviceName\n  });\n}\n\n/**\n * A function that returns reactive flags to detect the current device based on provided\n * breakpoints.\n *\n * @param devices - An object containing the breakpoints, where the key is the name of the device\n * and the value is the screen width.\n * @returns A object containing the multiple reactive flags.\n *\n * @internal\n */\nfunction getDeviceFlags<Device extends string>(\n  devices: Record<Device, number>\n): UseDeviceFlags<Device> {\n  const { width: windowSize } = useWindowSize();\n  return reduce(\n    devices,\n    (accumulator, device, deviceWidth) => {\n      const isDevice = computed(() => isCurrentDevice(device, devices, windowSize.value));\n      accumulator[`is${capitalize(device)}`] = isDevice;\n      accumulator[`is${capitalize(device)}OrLess`] = computed(\n        () => deviceWidth >= windowSize.value || isDevice.value\n      );\n      accumulator[`is${capitalize(device)}OrGreater`] = computed(\n        () => deviceWidth <= windowSize.value\n      );\n      return accumulator;\n    },\n    {} as Record<string, Ref<boolean>>\n  );\n}\n\n/**\n * To get the devices sorted by size and not run this calculation on every check.\n */\nconst getSortedByWidthDevices = useMemoize((devices: Record<string, number>) =>\n  Object.entries(devices).sort(([, aWidth], [, bWidth]) => bWidth - aWidth)\n);\n\n/**\n * Checks if the current device satisfies the criteria of being a valid device.\n *\n * @param device - The name of the current device.\n * @param devices - An object containing device names and their\n * respective widths.\n * @param windowSize - The width of the window.\n * @returns A boolean value indicating whether the current device satisfies the\n * criteria of being a valid device.\n *\n * @internal\n */\nfunction isCurrentDevice(\n  device: string,\n  devices: Record<string, number>,\n  windowSize: number\n): boolean {\n  const deviceWidth = devices[device];\n  return (\n    deviceWidth <= windowSize &&\n    !getSortedByWidthDevices(devices).some(\n      ([, otherDeviceWidth]) => otherDeviceWidth <= windowSize && otherDeviceWidth > deviceWidth\n    )\n  );\n}\n\n/**\n * A function that returns the current device orientation as a reactive value.\n *\n * @returns A reactive value indicating the current device\n * orientation.\n *\n * @internal\n */\nfunction getOrientation(): UseDeviceReturn['orientation'] {\n  const { orientation } = useScreenOrientation();\n  return computed(() =>\n    orientation.value?.includes('landscape')\n      ? 'landscape'\n      : orientation.value?.includes('portrait')\n      ? 'portrait'\n      : undefined\n  );\n}\n\n/**\n * A function that returns a reactive boolean indicating whether the current device is\n * touch-enabled.\n *\n * @returns A reactive boolean indicating whether the current device is touch-enabled.\n *\n * @internal\n */\nfunction getIsTouchable(): Ref<boolean> {\n  const isTouchableRef = ref(detectTouchable());\n  if (window) {\n    useEventListener(window, 'resize', () => (isTouchableRef.value = detectTouchable()), {\n      passive: true\n    });\n  }\n  return isTouchableRef;\n}\n\n/**\n * A function that returns a reactive string indicating the name of the currently detected device\n * based on the provided devices and device flags.\n *\n * @param  devices - An object containing the breakpoints, where the key is the name of the device\n * and the value is the screen width.\n * @param devicesFlags - An object containing multiple reactive flags and values for detecting\n * the current device.\n * @returns A reactive string indicating the name of the currently detected device.\n *\n * @internal\n */\nfunction getDeviceName(\n  devices: Record<string, number>,\n  devicesFlags: UseDeviceFlags<string>\n): Ref<string> {\n  return computed(\n    () => Object.keys(devices).find(device => devicesFlags[`is${capitalize(device)}`]?.value) ?? ''\n  );\n}\n\n/**\n * A utility function that detects whether the current device is touch-enabled.\n *\n * @returns A boolean indicating whether the current device is touch-enabled.\n *\n * @internal\n */\nfunction detectTouchable(): boolean {\n  return 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n}\n","\n  import { reduce } from '@empathyco/x-utils';\n  import { Component } from 'vue-property-decorator';\n  import { Observable, Subscription } from 'rxjs';\n  import { EventPayload, SubjectPayload } from '@empathyco/x-bus';\n  import { XEventListeners } from '../x-installer/api/api.types';\n  import { WireMetadata } from '../wiring/wiring.types';\n  import { XEventsTypes } from '../wiring/events.types';\n  import { NoElement } from './no-element';\n\n  /**\n   * This component helps subscribing to any {@link XEvent} with custom callbacks using Vue\n   * listeners API.\n   *\n   * @public\n   */\n  @Component\n  export default class GlobalXBus extends NoElement {\n    /**\n     * Object with the {@link XEvent} listeners.\n     *\n     * @internal\n     */\n    public $listeners!: XEventListeners;\n\n    created(): void {\n      this.handleXEventSubscription();\n    }\n\n    /**\n     * Handles a subscription to all the events provided in the listeners with the function that\n     * will execute the callback. Also unsubscribes on beforeDestroy.\n     *\n     * @internal\n     */\n    protected handleXEventSubscription(): void {\n      const subscription = reduce(\n        this.$listeners,\n        (subscription, eventName, callback) => {\n          subscription.add(\n            (\n              this.$x.on(eventName, true) as unknown as Observable<\n                SubjectPayload<EventPayload<XEventsTypes, typeof eventName>, WireMetadata>\n              >\n            ).subscribe(({ eventPayload, metadata }) => {\n              callback(eventPayload as never, metadata);\n            })\n          );\n          return subscription;\n        },\n        new Subscription()\n      );\n\n      this.$on('hook:beforeDestroy', () => {\n        subscription.unsubscribe();\n      });\n    }\n  }\n","<script lang=\"ts\">\n  import { reduce } from '@empathyco/x-utils';\n  import { Component } from 'vue-property-decorator';\n  import { Observable, Subscription } from 'rxjs';\n  import { EventPayload, SubjectPayload } from '@empathyco/x-bus';\n  import { XEventListeners } from '../x-installer/api/api.types';\n  import { WireMetadata } from '../wiring/wiring.types';\n  import { XEventsTypes } from '../wiring/events.types';\n  import { NoElement } from './no-element';\n\n  /**\n   * This component helps subscribing to any {@link XEvent} with custom callbacks using Vue\n   * listeners API.\n   *\n   * @public\n   */\n  @Component\n  export default class GlobalXBus extends NoElement {\n    /**\n     * Object with the {@link XEvent} listeners.\n     *\n     * @internal\n     */\n    public $listeners!: XEventListeners;\n\n    created(): void {\n      this.handleXEventSubscription();\n    }\n\n    /**\n     * Handles a subscription to all the events provided in the listeners with the function that\n     * will execute the callback. Also unsubscribes on beforeDestroy.\n     *\n     * @internal\n     */\n    protected handleXEventSubscription(): void {\n      const subscription = reduce(\n        this.$listeners,\n        (subscription, eventName, callback) => {\n          subscription.add(\n            (\n              this.$x.on(eventName, true) as unknown as Observable<\n                SubjectPayload<EventPayload<XEventsTypes, typeof eventName>, WireMetadata>\n              >\n            ).subscribe(({ eventPayload, metadata }) => {\n              callback(eventPayload as never, metadata);\n            })\n          );\n          return subscription;\n        },\n        new Subscription()\n      );\n\n      this.$on('hook:beforeDestroy', () => {\n        subscription.unsubscribe();\n      });\n    }\n  }\n</script>\n\n<docs lang=\"mdx\">\n## Events\n\nThis component emits no own events, but you can subscribe to any X Event using Vue listeners\n\n## See it in action\n\nThis component does not render anything. Its only responsibility is to facilitate listening to any X\nEvent by using Vue component listeners.\n\n```vue\n<template>\n  <GlobalXBus @UserAcceptedAQuery=\"printQuery\" />\n</template>\n\n<script>\n  import { GlobalXBus } from '@empathyco/x-components';\n  export default {\n    name: 'GlobalXBusTest',\n    components: {\n      GlobalXBus\n    },\n    methods: {\n      printQuery(query, metadata) {\n        console.log('My new query is:', query);\n        console.log('And has been triggered by this DOM element:', metadata.target);\n      }\n    }\n  };\n</script>\n```\n</docs>\n","\n\n\n\n\n  import { map } from '@empathyco/x-utils';\n  import { Component, Inject } from 'vue-property-decorator';\n  import Vue from 'vue';\n  import { WireMetadata } from '../wiring';\n  import { SnippetConfig, XEventListeners } from '../x-installer/api/api.types';\n  import GlobalXBus from './global-x-bus.vue';\n\n  /**\n   * This component subscribes to any {@link XEvent} with a custom callbacks provided by the snippet\n   * configuration.\n   *\n   * @public\n   */\n  @Component({\n    components: { GlobalXBus }\n  })\n  export default class SnippetCallbacks extends Vue {\n    /**\n     * Injects {@link SnippetConfig} provided by an ancestor as snippetConfig.\n     *\n     * @internal\n     */\n    @Inject('snippetConfig')\n    public snippetConfig!: SnippetConfig;\n\n    /**\n     * It maps all the callbacks provided by the snippetConfig and adds an emit to each one.\n     *\n     * @returns The event listeners with the {@link XEventsTypes.SnippetCallbackExecuted} emit in\n     * the callback.\n     *\n     * @internal\n     *\n     */\n    protected get eventListeners(): XEventListeners {\n      const { callbacks } = this.snippetConfig;\n      return callbacks\n        ? map(callbacks, (eventName, callback) => {\n            return (payload: unknown, metadata: WireMetadata) => {\n              const callbackReturn = callback(payload as never, metadata);\n              this.$x.emit('SnippetCallbackExecuted', {\n                event: eventName,\n                callbackReturn,\n                payload: payload as never,\n                metadata\n              });\n            };\n          })\n        : ({} as XEventListeners);\n    }\n  }\n","<template>\n  <GlobalXBus v-on=\"eventListeners\" />\n</template>\n\n<script lang=\"ts\">\n  import { map } from '@empathyco/x-utils';\n  import { Component, Inject } from 'vue-property-decorator';\n  import Vue from 'vue';\n  import { WireMetadata } from '../wiring';\n  import { SnippetConfig, XEventListeners } from '../x-installer/api/api.types';\n  import GlobalXBus from './global-x-bus.vue';\n\n  /**\n   * This component subscribes to any {@link XEvent} with a custom callbacks provided by the snippet\n   * configuration.\n   *\n   * @public\n   */\n  @Component({\n    components: { GlobalXBus }\n  })\n  export default class SnippetCallbacks extends Vue {\n    /**\n     * Injects {@link SnippetConfig} provided by an ancestor as snippetConfig.\n     *\n     * @internal\n     */\n    @Inject('snippetConfig')\n    public snippetConfig!: SnippetConfig;\n\n    /**\n     * It maps all the callbacks provided by the snippetConfig and adds an emit to each one.\n     *\n     * @returns The event listeners with the {@link XEventsTypes.SnippetCallbackExecuted} emit in\n     * the callback.\n     *\n     * @internal\n     *\n     */\n    protected get eventListeners(): XEventListeners {\n      const { callbacks } = this.snippetConfig;\n      return callbacks\n        ? map(callbacks, (eventName, callback) => {\n            return (payload: unknown, metadata: WireMetadata) => {\n              const callbackReturn = callback(payload as never, metadata);\n              this.$x.emit('SnippetCallbackExecuted', {\n                event: eventName,\n                callbackReturn,\n                payload: payload as never,\n                metadata\n              });\n            };\n          })\n        : ({} as XEventListeners);\n    }\n  }\n</script>\n\n<docs lang=\"mdx\">\n## Events\n\nThe `SnippetCallbacks` will emit the `SnippetCallbackExecuted` each time a callback provided by the\nsnippetConfig is fired.\n\n## See it in action\n\nThis component does not render anything. Its only responsibility is to receive any callback that\nwill be triggered once its listened event is emitted.\n\n```vue\n<template>\n  <SnippetCallbacks />\n</template>\n\n<script>\n  import { SnippetCallbacks } from '@empathyco/x-components';\n  export default {\n    name: 'SnippetCallbacksTest',\n    components: {\n      SnippetCallbacks\n    }\n  };\n</script>\n```\n</docs>\n","import { QueryOrigin, QueryOriginInit, ResultOrigin } from '../types/origin';\n\n/**\n * Creates a {@link QueryOrigin} or a {@link ResultOrigin} string given a {@link QueryFeature} and\n * a {@link FeatureLocation}.\n * If it can't be created, it returns `null`.\n *\n * @param originInit - An object containing the needed properties to create a {@link QueryOrigin} or\n * a {@link ResultOrigin}.\n *\n * @returns The composed origin, or `null` if it is not able to create the origin.\n *\n * @internal\n */\nexport function createOrigin({\n  feature,\n  location\n}: QueryOriginInit): QueryOrigin | ResultOrigin | null {\n  if (feature) {\n    return `${feature}:${location ?? 'none'}`;\n  }\n  return null;\n}\n","import { XModuleName } from '../x-modules/x-modules.types';\nimport { NamespacedTimeWireOperator } from './namespaced-wiring.types';\nimport { debounce, throttle } from './wires.operators';\nimport { getStateAndGettersFromModule } from './wiring.utils';\n\n/**\n * Type safe debounce operator which creates a function which can only access the Module of\n * the {@link https://vuex.vuejs.org/ | Vuex} Store passed as parameter.\n *\n * @param moduleName - The {@link XModuleName} to create the operator wire.\n * @returns A function which creates a wire that uses the {@link debounce} wire operator to\n * execute the `wire` after the time has passed without invoking it. This debounce time\n * is given by the execution of the `timeRetrieving` function.\n *\n * @public\n */\nexport function namespacedDebounce<ModuleName extends XModuleName>(\n  moduleName: ModuleName\n): NamespacedTimeWireOperator<ModuleName> {\n  return createNamespacedTimeWireOperator(moduleName, debounce);\n}\n\n/**\n * Type safe throttle operator which creates a function which can only access the Module of\n * the {@link https://vuex.vuejs.org/ | Vuex} Store passed as parameter.\n *\n * @param moduleName - The {@link XModuleName} to create the operator wire.\n * @returns A function which creates a wire that uses the {@link throttle} wire operator to\n * execute the `wire` once every couple of milliseconds. This throttle time is given by\n * the execution of the `timeRetrieving` function.\n *\n * @public\n */\nexport function namespacedThrottle<ModuleName extends XModuleName>(\n  moduleName: ModuleName\n): NamespacedTimeWireOperator<ModuleName> {\n  return createNamespacedTimeWireOperator(moduleName, throttle);\n}\n\n/**\n * Creates a function which creates a namespaced wire that uses the {@link debounce} or\n * {@link throttle} time wire operator.\n *\n * @param moduleName - The {@link XModuleName} to create the operator wire.\n * @param timingOperator - The time wire operator {@link debounce} or {@link throttle}.\n * @returns A function which creates a namespaced time wire operator.\n *\n * @internal\n */\nfunction createNamespacedTimeWireOperator<ModuleName extends XModuleName>(\n  moduleName: ModuleName,\n  timingOperator: typeof throttle | typeof debounce\n): NamespacedTimeWireOperator<ModuleName> {\n  return (wire, timeSelector, options) =>\n    timingOperator(\n      wire,\n      ({ state, getters }) =>\n        timeSelector(getStateAndGettersFromModule(state, getters, moduleName)),\n      options\n    );\n}\n","import { XBus } from '@empathyco/x-bus';\nimport { WireMetadata, XEventsTypes } from '../../wiring/index';\nimport { SnippetConfig, XAPI } from './api.types';\n\n/**\n * Default implementation for {@link XAPI}.\n *\n * @public\n */\nexport class BaseXAPI implements XAPI {\n  /**\n   * Flag to check if the initialization was already done.\n   *\n   * @internal\n   */\n  protected isXInitialized = false;\n\n  /**\n   * Bus for emitting and listening events.\n   *\n   * @internal\n   */\n  protected bus!: XBus<XEventsTypes, WireMetadata>;\n\n  /**\n   * The callback to call from the init method. The logic of initialization is out of this API\n   * since this API is just a facade.\n   *\n   * @internal\n   */\n  protected initCallback!: (config: SnippetConfig) => any;\n\n  /**\n   * Callback that allows to update the snippet config. The logic of initialization is out of this\n   * API since this API is just a facade.\n   *\n   * @internal\n   */\n  protected snippetCallback!: (config: Partial<SnippetConfig>) => void;\n\n  /**\n   * Tracks that a product was added to cart from PDP.\n   *\n   * @param productId - The product id that was added to cart.\n   */\n  addProductToCart(productId?: string): void {\n    this.bus?.emit('UserClickedPDPAddToCart', productId);\n  }\n\n  /**\n   * Setter for the {@link @empathyco/x-bus#XBus}.\n   *\n   * @param bus - The {@link @empathyco/x-bus#XBus} received to emit events.\n   *\n   * @internal\n   */\n  setBus(bus: XBus<XEventsTypes, WireMetadata>): void {\n    this.bus = bus;\n  }\n\n  /**\n   * Setter for the callback to call in the init method.\n   *\n   * @param initCallback - The callback to call.\n   */\n  setInitCallback(initCallback: (config: SnippetConfig) => any): void {\n    this.initCallback = initCallback;\n  }\n\n  /**\n   * Setter for the callback to modify the snippet config.\n   *\n   * @param snippetCallback - The callback to call.\n   *\n   * @internal\n   */\n  setSnippetConfigCallback(snippetCallback: (config: Partial<SnippetConfig>) => void): void {\n    this.snippetCallback = snippetCallback;\n  }\n\n  /**\n   * Sets or updates the snippet config.\n   *\n   * @param config - A part or all the snippet config.\n   *\n   * @public\n   */\n  setSnippetConfig(config: Partial<SnippetConfig>): void {\n    this?.snippetCallback(config);\n  }\n\n  /**\n   * Searches the query parameter as user query.\n   *\n   * @param query - Query to be searched.\n   *\n   * @public\n   */\n  search(query?: string): void {\n    if (query) {\n      this.bus?.emit('UserAcceptedAQuery', query);\n    }\n    this.bus?.emit('UserClickedOpenX');\n  }\n\n  /**\n   * Initializes the Application passing the {@link SnippetConfig}.\n   *\n   * @param config - The config coming from the customer snippet.\n   *\n   * @returns A promise that will be resolved once x components are initialized.\n   *\n   * @public\n   */\n  async init(config: SnippetConfig): Promise<void> {\n    if (!this.isXInitialized) {\n      this.isXInitialized = true;\n      await this?.initCallback(config);\n    } else {\n      //eslint-disable-next-line no-console\n      console.warn('We know X is awesome, but you only need to initialize it once.');\n    }\n  }\n\n  /**\n   * Closes the Application.\n   *\n   * @public\n   */\n  close(): void {\n    this.bus?.emit('UserClickedCloseX');\n  }\n}\n","/*!\n * vue-i18n v8.21.1 \n * (c) 2020 kazuya kawaguchi\n * Released under the MIT License.\n */\n/*  */\n\n/**\n * constants\n */\n\nvar numberFormatKeys = [\n  'style',\n  'currency',\n  'currencyDisplay',\n  'useGrouping',\n  'minimumIntegerDigits',\n  'minimumFractionDigits',\n  'maximumFractionDigits',\n  'minimumSignificantDigits',\n  'maximumSignificantDigits',\n  'localeMatcher',\n  'formatMatcher',\n  'unit'\n];\n\n/**\n * utilities\n */\n\nfunction warn (msg, err) {\n  if (typeof console !== 'undefined') {\n    console.warn('[vue-i18n] ' + msg);\n    /* istanbul ignore if */\n    if (err) {\n      console.warn(err.stack);\n    }\n  }\n}\n\nfunction error (msg, err) {\n  if (typeof console !== 'undefined') {\n    console.error('[vue-i18n] ' + msg);\n    /* istanbul ignore if */\n    if (err) {\n      console.error(err.stack);\n    }\n  }\n}\n\nvar isArray = Array.isArray;\n\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nfunction isBoolean (val) {\n  return typeof val === 'boolean'\n}\n\nfunction isString (val) {\n  return typeof val === 'string'\n}\n\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\nfunction isNull (val) {\n  return val === null || val === undefined\n}\n\nfunction isFunction (val) {\n  return typeof val === 'function'\n}\n\nfunction parseArgs () {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  var locale = null;\n  var params = null;\n  if (args.length === 1) {\n    if (isObject(args[0]) || isArray(args[0])) {\n      params = args[0];\n    } else if (typeof args[0] === 'string') {\n      locale = args[0];\n    }\n  } else if (args.length === 2) {\n    if (typeof args[0] === 'string') {\n      locale = args[0];\n    }\n    /* istanbul ignore if */\n    if (isObject(args[1]) || isArray(args[1])) {\n      params = args[1];\n    }\n  }\n\n  return { locale: locale, params: params }\n}\n\nfunction looseClone (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\nfunction includes (arr, item) {\n  return !!~arr.indexOf(item)\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\nfunction merge (target) {\n  var arguments$1 = arguments;\n\n  var output = Object(target);\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments$1[i];\n    if (source !== undefined && source !== null) {\n      var key = (void 0);\n      for (key in source) {\n        if (hasOwn(source, key)) {\n          if (isObject(source[key])) {\n            output[key] = merge(output[key], source[key]);\n          } else {\n            output[key] = source[key];\n          }\n        }\n      }\n    }\n  }\n  return output\n}\n\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = isArray(a);\n      var isArrayB = isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\n/*  */\n\nfunction extend (Vue) {\n  if (!Vue.prototype.hasOwnProperty('$i18n')) {\n    // $FlowFixMe\n    Object.defineProperty(Vue.prototype, '$i18n', {\n      get: function get () { return this._i18n }\n    });\n  }\n\n  Vue.prototype.$t = function (key) {\n    var values = [], len = arguments.length - 1;\n    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n\n    var i18n = this.$i18n;\n    return i18n._t.apply(i18n, [ key, i18n.locale, i18n._getMessages(), this ].concat( values ))\n  };\n\n  Vue.prototype.$tc = function (key, choice) {\n    var values = [], len = arguments.length - 2;\n    while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];\n\n    var i18n = this.$i18n;\n    return i18n._tc.apply(i18n, [ key, i18n.locale, i18n._getMessages(), this, choice ].concat( values ))\n  };\n\n  Vue.prototype.$te = function (key, locale) {\n    var i18n = this.$i18n;\n    return i18n._te(key, i18n.locale, i18n._getMessages(), locale)\n  };\n\n  Vue.prototype.$d = function (value) {\n    var ref;\n\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n    return (ref = this.$i18n).d.apply(ref, [ value ].concat( args ))\n  };\n\n  Vue.prototype.$n = function (value) {\n    var ref;\n\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n    return (ref = this.$i18n).n.apply(ref, [ value ].concat( args ))\n  };\n}\n\n/*  */\n\nvar mixin = {\n  beforeCreate: function beforeCreate () {\n    var options = this.$options;\n    options.i18n = options.i18n || (options.__i18n ? {} : null);\n\n    if (options.i18n) {\n      if (options.i18n instanceof VueI18n) {\n        // init locale messages via custom blocks\n        if (options.__i18n) {\n          try {\n            var localeMessages = options.i18n && options.i18n.messages ? options.i18n.messages : {};\n            options.__i18n.forEach(function (resource) {\n              localeMessages = merge(localeMessages, JSON.parse(resource));\n            });\n            Object.keys(localeMessages).forEach(function (locale) {\n              options.i18n.mergeLocaleMessage(locale, localeMessages[locale]);\n            });\n          } catch (e) {\n            if (process.env.NODE_ENV !== 'production') {\n              error(\"Cannot parse locale messages via custom blocks.\", e);\n            }\n          }\n        }\n        this._i18n = options.i18n;\n        this._i18nWatcher = this._i18n.watchI18nData();\n      } else if (isPlainObject(options.i18n)) {\n        var rootI18n = this.$root && this.$root.$i18n && this.$root.$i18n instanceof VueI18n\n          ? this.$root.$i18n\n          : null;\n        // component local i18n\n        if (rootI18n) {\n          options.i18n.root = this.$root;\n          options.i18n.formatter = rootI18n.formatter;\n          options.i18n.fallbackLocale = rootI18n.fallbackLocale;\n          options.i18n.formatFallbackMessages = rootI18n.formatFallbackMessages;\n          options.i18n.silentTranslationWarn = rootI18n.silentTranslationWarn;\n          options.i18n.silentFallbackWarn = rootI18n.silentFallbackWarn;\n          options.i18n.pluralizationRules = rootI18n.pluralizationRules;\n          options.i18n.preserveDirectiveContent = rootI18n.preserveDirectiveContent;\n        }\n\n        // init locale messages via custom blocks\n        if (options.__i18n) {\n          try {\n            var localeMessages$1 = options.i18n && options.i18n.messages ? options.i18n.messages : {};\n            options.__i18n.forEach(function (resource) {\n              localeMessages$1 = merge(localeMessages$1, JSON.parse(resource));\n            });\n            options.i18n.messages = localeMessages$1;\n          } catch (e) {\n            if (process.env.NODE_ENV !== 'production') {\n              warn(\"Cannot parse locale messages via custom blocks.\", e);\n            }\n          }\n        }\n\n        var ref = options.i18n;\n        var sharedMessages = ref.sharedMessages;\n        if (sharedMessages && isPlainObject(sharedMessages)) {\n          options.i18n.messages = merge(options.i18n.messages, sharedMessages);\n        }\n\n        this._i18n = new VueI18n(options.i18n);\n        this._i18nWatcher = this._i18n.watchI18nData();\n\n        if (options.i18n.sync === undefined || !!options.i18n.sync) {\n          this._localeWatcher = this.$i18n.watchLocale();\n        }\n\n        if (rootI18n) {\n          rootI18n.onComponentInstanceCreated(this._i18n);\n        }\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn(\"Cannot be interpreted 'i18n' option.\");\n        }\n      }\n    } else if (this.$root && this.$root.$i18n && this.$root.$i18n instanceof VueI18n) {\n      // root i18n\n      this._i18n = this.$root.$i18n;\n    } else if (options.parent && options.parent.$i18n && options.parent.$i18n instanceof VueI18n) {\n      // parent i18n\n      this._i18n = options.parent.$i18n;\n    }\n  },\n\n  beforeMount: function beforeMount () {\n    var options = this.$options;\n    options.i18n = options.i18n || (options.__i18n ? {} : null);\n\n    if (options.i18n) {\n      if (options.i18n instanceof VueI18n) {\n        // init locale messages via custom blocks\n        this._i18n.subscribeDataChanging(this);\n        this._subscribing = true;\n      } else if (isPlainObject(options.i18n)) {\n        this._i18n.subscribeDataChanging(this);\n        this._subscribing = true;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn(\"Cannot be interpreted 'i18n' option.\");\n        }\n      }\n    } else if (this.$root && this.$root.$i18n && this.$root.$i18n instanceof VueI18n) {\n      this._i18n.subscribeDataChanging(this);\n      this._subscribing = true;\n    } else if (options.parent && options.parent.$i18n && options.parent.$i18n instanceof VueI18n) {\n      this._i18n.subscribeDataChanging(this);\n      this._subscribing = true;\n    }\n  },\n\n  beforeDestroy: function beforeDestroy () {\n    if (!this._i18n) { return }\n\n    var self = this;\n    this.$nextTick(function () {\n      if (self._subscribing) {\n        self._i18n.unsubscribeDataChanging(self);\n        delete self._subscribing;\n      }\n\n      if (self._i18nWatcher) {\n        self._i18nWatcher();\n        self._i18n.destroyVM();\n        delete self._i18nWatcher;\n      }\n\n      if (self._localeWatcher) {\n        self._localeWatcher();\n        delete self._localeWatcher;\n      }\n    });\n  }\n};\n\n/*  */\n\nvar interpolationComponent = {\n  name: 'i18n',\n  functional: true,\n  props: {\n    tag: {\n      type: [String, Boolean, Object],\n      default: 'span'\n    },\n    path: {\n      type: String,\n      required: true\n    },\n    locale: {\n      type: String\n    },\n    places: {\n      type: [Array, Object]\n    }\n  },\n  render: function render (h, ref) {\n    var data = ref.data;\n    var parent = ref.parent;\n    var props = ref.props;\n    var slots = ref.slots;\n\n    var $i18n = parent.$i18n;\n    if (!$i18n) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Cannot find VueI18n instance!');\n      }\n      return\n    }\n\n    var path = props.path;\n    var locale = props.locale;\n    var places = props.places;\n    var params = slots();\n    var children = $i18n.i(\n      path,\n      locale,\n      onlyHasDefaultPlace(params) || places\n        ? useLegacyPlaces(params.default, places)\n        : params\n    );\n\n    var tag = (!!props.tag && props.tag !== true) || props.tag === false ? props.tag : 'span';\n    return tag ? h(tag, data, children) : children\n  }\n};\n\nfunction onlyHasDefaultPlace (params) {\n  var prop;\n  for (prop in params) {\n    if (prop !== 'default') { return false }\n  }\n  return Boolean(prop)\n}\n\nfunction useLegacyPlaces (children, places) {\n  var params = places ? createParamsFromPlaces(places) : {};\n\n  if (!children) { return params }\n\n  // Filter empty text nodes\n  children = children.filter(function (child) {\n    return child.tag || child.text.trim() !== ''\n  });\n\n  var everyPlace = children.every(vnodeHasPlaceAttribute);\n  if (process.env.NODE_ENV !== 'production' && everyPlace) {\n    warn('`place` attribute is deprecated in next major version. Please switch to Vue slots.');\n  }\n\n  return children.reduce(\n    everyPlace ? assignChildPlace : assignChildIndex,\n    params\n  )\n}\n\nfunction createParamsFromPlaces (places) {\n  if (process.env.NODE_ENV !== 'production') {\n    warn('`places` prop is deprecated in next major version. Please switch to Vue slots.');\n  }\n\n  return Array.isArray(places)\n    ? places.reduce(assignChildIndex, {})\n    : Object.assign({}, places)\n}\n\nfunction assignChildPlace (params, child) {\n  if (child.data && child.data.attrs && child.data.attrs.place) {\n    params[child.data.attrs.place] = child;\n  }\n  return params\n}\n\nfunction assignChildIndex (params, child, index) {\n  params[index] = child;\n  return params\n}\n\nfunction vnodeHasPlaceAttribute (vnode) {\n  return Boolean(vnode.data && vnode.data.attrs && vnode.data.attrs.place)\n}\n\n/*  */\n\nvar numberComponent = {\n  name: 'i18n-n',\n  functional: true,\n  props: {\n    tag: {\n      type: [String, Boolean, Object],\n      default: 'span'\n    },\n    value: {\n      type: Number,\n      required: true\n    },\n    format: {\n      type: [String, Object]\n    },\n    locale: {\n      type: String\n    }\n  },\n  render: function render (h, ref) {\n    var props = ref.props;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    var i18n = parent.$i18n;\n\n    if (!i18n) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Cannot find VueI18n instance!');\n      }\n      return null\n    }\n\n    var key = null;\n    var options = null;\n\n    if (isString(props.format)) {\n      key = props.format;\n    } else if (isObject(props.format)) {\n      if (props.format.key) {\n        key = props.format.key;\n      }\n\n      // Filter out number format options only\n      options = Object.keys(props.format).reduce(function (acc, prop) {\n        var obj;\n\n        if (includes(numberFormatKeys, prop)) {\n          return Object.assign({}, acc, ( obj = {}, obj[prop] = props.format[prop], obj ))\n        }\n        return acc\n      }, null);\n    }\n\n    var locale = props.locale || i18n.locale;\n    var parts = i18n._ntp(props.value, locale, key, options);\n\n    var values = parts.map(function (part, index) {\n      var obj;\n\n      var slot = data.scopedSlots && data.scopedSlots[part.type];\n      return slot ? slot(( obj = {}, obj[part.type] = part.value, obj.index = index, obj.parts = parts, obj )) : part.value\n    });\n\n    var tag = (!!props.tag && props.tag !== true) || props.tag === false ? props.tag : 'span';\n    return tag\n      ? h(tag, {\n        attrs: data.attrs,\n        'class': data['class'],\n        staticClass: data.staticClass\n      }, values)\n      : values\n  }\n};\n\n/*  */\n\nfunction bind (el, binding, vnode) {\n  if (!assert(el, vnode)) { return }\n\n  t(el, binding, vnode);\n}\n\nfunction update (el, binding, vnode, oldVNode) {\n  if (!assert(el, vnode)) { return }\n\n  var i18n = vnode.context.$i18n;\n  if (localeEqual(el, vnode) &&\n    (looseEqual(binding.value, binding.oldValue) &&\n     looseEqual(el._localeMessage, i18n.getLocaleMessage(i18n.locale)))) { return }\n\n  t(el, binding, vnode);\n}\n\nfunction unbind (el, binding, vnode, oldVNode) {\n  var vm = vnode.context;\n  if (!vm) {\n    warn('Vue instance does not exists in VNode context');\n    return\n  }\n\n  var i18n = vnode.context.$i18n || {};\n  if (!binding.modifiers.preserve && !i18n.preserveDirectiveContent) {\n    el.textContent = '';\n  }\n  el._vt = undefined;\n  delete el['_vt'];\n  el._locale = undefined;\n  delete el['_locale'];\n  el._localeMessage = undefined;\n  delete el['_localeMessage'];\n}\n\nfunction assert (el, vnode) {\n  var vm = vnode.context;\n  if (!vm) {\n    warn('Vue instance does not exists in VNode context');\n    return false\n  }\n\n  if (!vm.$i18n) {\n    warn('VueI18n instance does not exists in Vue instance');\n    return false\n  }\n\n  return true\n}\n\nfunction localeEqual (el, vnode) {\n  var vm = vnode.context;\n  return el._locale === vm.$i18n.locale\n}\n\nfunction t (el, binding, vnode) {\n  var ref$1, ref$2;\n\n  var value = binding.value;\n\n  var ref = parseValue(value);\n  var path = ref.path;\n  var locale = ref.locale;\n  var args = ref.args;\n  var choice = ref.choice;\n  if (!path && !locale && !args) {\n    warn('value type not supported');\n    return\n  }\n\n  if (!path) {\n    warn('`path` is required in v-t directive');\n    return\n  }\n\n  var vm = vnode.context;\n  if (choice != null) {\n    el._vt = el.textContent = (ref$1 = vm.$i18n).tc.apply(ref$1, [ path, choice ].concat( makeParams(locale, args) ));\n  } else {\n    el._vt = el.textContent = (ref$2 = vm.$i18n).t.apply(ref$2, [ path ].concat( makeParams(locale, args) ));\n  }\n  el._locale = vm.$i18n.locale;\n  el._localeMessage = vm.$i18n.getLocaleMessage(vm.$i18n.locale);\n}\n\nfunction parseValue (value) {\n  var path;\n  var locale;\n  var args;\n  var choice;\n\n  if (isString(value)) {\n    path = value;\n  } else if (isPlainObject(value)) {\n    path = value.path;\n    locale = value.locale;\n    args = value.args;\n    choice = value.choice;\n  }\n\n  return { path: path, locale: locale, args: args, choice: choice }\n}\n\nfunction makeParams (locale, args) {\n  var params = [];\n\n  locale && params.push(locale);\n  if (args && (Array.isArray(args) || isPlainObject(args))) {\n    params.push(args);\n  }\n\n  return params\n}\n\nvar Vue;\n\nfunction install (_Vue) {\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && install.installed && _Vue === Vue) {\n    warn('already installed.');\n    return\n  }\n  install.installed = true;\n\n  Vue = _Vue;\n\n  var version = (Vue.version && Number(Vue.version.split('.')[0])) || -1;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && version < 2) {\n    warn((\"vue-i18n (\" + (install.version) + \") need to use Vue 2.0 or later (Vue: \" + (Vue.version) + \").\"));\n    return\n  }\n\n  extend(Vue);\n  Vue.mixin(mixin);\n  Vue.directive('t', { bind: bind, update: update, unbind: unbind });\n  Vue.component(interpolationComponent.name, interpolationComponent);\n  Vue.component(numberComponent.name, numberComponent);\n\n  // use simple mergeStrategies to prevent i18n instance lose '__proto__'\n  var strats = Vue.config.optionMergeStrategies;\n  strats.i18n = function (parentVal, childVal) {\n    return childVal === undefined\n      ? parentVal\n      : childVal\n  };\n}\n\n/*  */\n\nvar BaseFormatter = function BaseFormatter () {\n  this._caches = Object.create(null);\n};\n\nBaseFormatter.prototype.interpolate = function interpolate (message, values) {\n  if (!values) {\n    return [message]\n  }\n  var tokens = this._caches[message];\n  if (!tokens) {\n    tokens = parse(message);\n    this._caches[message] = tokens;\n  }\n  return compile(tokens, values)\n};\n\n\n\nvar RE_TOKEN_LIST_VALUE = /^(?:\\d)+/;\nvar RE_TOKEN_NAMED_VALUE = /^(?:\\w)+/;\n\nfunction parse (format) {\n  var tokens = [];\n  var position = 0;\n\n  var text = '';\n  while (position < format.length) {\n    var char = format[position++];\n    if (char === '{') {\n      if (text) {\n        tokens.push({ type: 'text', value: text });\n      }\n\n      text = '';\n      var sub = '';\n      char = format[position++];\n      while (char !== undefined && char !== '}') {\n        sub += char;\n        char = format[position++];\n      }\n      var isClosed = char === '}';\n\n      var type = RE_TOKEN_LIST_VALUE.test(sub)\n        ? 'list'\n        : isClosed && RE_TOKEN_NAMED_VALUE.test(sub)\n          ? 'named'\n          : 'unknown';\n      tokens.push({ value: sub, type: type });\n    } else if (char === '%') {\n      // when found rails i18n syntax, skip text capture\n      if (format[(position)] !== '{') {\n        text += char;\n      }\n    } else {\n      text += char;\n    }\n  }\n\n  text && tokens.push({ type: 'text', value: text });\n\n  return tokens\n}\n\nfunction compile (tokens, values) {\n  var compiled = [];\n  var index = 0;\n\n  var mode = Array.isArray(values)\n    ? 'list'\n    : isObject(values)\n      ? 'named'\n      : 'unknown';\n  if (mode === 'unknown') { return compiled }\n\n  while (index < tokens.length) {\n    var token = tokens[index];\n    switch (token.type) {\n      case 'text':\n        compiled.push(token.value);\n        break\n      case 'list':\n        compiled.push(values[parseInt(token.value, 10)]);\n        break\n      case 'named':\n        if (mode === 'named') {\n          compiled.push((values)[token.value]);\n        } else {\n          if (process.env.NODE_ENV !== 'production') {\n            warn((\"Type of token '\" + (token.type) + \"' and format of value '\" + mode + \"' don't match!\"));\n          }\n        }\n        break\n      case 'unknown':\n        if (process.env.NODE_ENV !== 'production') {\n          warn(\"Detect 'unknown' type of token!\");\n        }\n        break\n    }\n    index++;\n  }\n\n  return compiled\n}\n\n/*  */\n\n/**\n *  Path parser\n *  - Inspired:\n *    Vue.js Path parser\n */\n\n// actions\nvar APPEND = 0;\nvar PUSH = 1;\nvar INC_SUB_PATH_DEPTH = 2;\nvar PUSH_SUB_PATH = 3;\n\n// states\nvar BEFORE_PATH = 0;\nvar IN_PATH = 1;\nvar BEFORE_IDENT = 2;\nvar IN_IDENT = 3;\nvar IN_SUB_PATH = 4;\nvar IN_SINGLE_QUOTE = 5;\nvar IN_DOUBLE_QUOTE = 6;\nvar AFTER_PATH = 7;\nvar ERROR = 8;\n\nvar pathStateMachine = [];\n\npathStateMachine[BEFORE_PATH] = {\n  'ws': [BEFORE_PATH],\n  'ident': [IN_IDENT, APPEND],\n  '[': [IN_SUB_PATH],\n  'eof': [AFTER_PATH]\n};\n\npathStateMachine[IN_PATH] = {\n  'ws': [IN_PATH],\n  '.': [BEFORE_IDENT],\n  '[': [IN_SUB_PATH],\n  'eof': [AFTER_PATH]\n};\n\npathStateMachine[BEFORE_IDENT] = {\n  'ws': [BEFORE_IDENT],\n  'ident': [IN_IDENT, APPEND],\n  '0': [IN_IDENT, APPEND],\n  'number': [IN_IDENT, APPEND]\n};\n\npathStateMachine[IN_IDENT] = {\n  'ident': [IN_IDENT, APPEND],\n  '0': [IN_IDENT, APPEND],\n  'number': [IN_IDENT, APPEND],\n  'ws': [IN_PATH, PUSH],\n  '.': [BEFORE_IDENT, PUSH],\n  '[': [IN_SUB_PATH, PUSH],\n  'eof': [AFTER_PATH, PUSH]\n};\n\npathStateMachine[IN_SUB_PATH] = {\n  \"'\": [IN_SINGLE_QUOTE, APPEND],\n  '\"': [IN_DOUBLE_QUOTE, APPEND],\n  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],\n  ']': [IN_PATH, PUSH_SUB_PATH],\n  'eof': ERROR,\n  'else': [IN_SUB_PATH, APPEND]\n};\n\npathStateMachine[IN_SINGLE_QUOTE] = {\n  \"'\": [IN_SUB_PATH, APPEND],\n  'eof': ERROR,\n  'else': [IN_SINGLE_QUOTE, APPEND]\n};\n\npathStateMachine[IN_DOUBLE_QUOTE] = {\n  '\"': [IN_SUB_PATH, APPEND],\n  'eof': ERROR,\n  'else': [IN_DOUBLE_QUOTE, APPEND]\n};\n\n/**\n * Check if an expression is a literal value.\n */\n\nvar literalValueRE = /^\\s?(?:true|false|-?[\\d.]+|'[^']*'|\"[^\"]*\")\\s?$/;\nfunction isLiteral (exp) {\n  return literalValueRE.test(exp)\n}\n\n/**\n * Strip quotes from a string\n */\n\nfunction stripQuotes (str) {\n  var a = str.charCodeAt(0);\n  var b = str.charCodeAt(str.length - 1);\n  return a === b && (a === 0x22 || a === 0x27)\n    ? str.slice(1, -1)\n    : str\n}\n\n/**\n * Determine the type of a character in a keypath.\n */\n\nfunction getPathCharType (ch) {\n  if (ch === undefined || ch === null) { return 'eof' }\n\n  var code = ch.charCodeAt(0);\n\n  switch (code) {\n    case 0x5B: // [\n    case 0x5D: // ]\n    case 0x2E: // .\n    case 0x22: // \"\n    case 0x27: // '\n      return ch\n\n    case 0x5F: // _\n    case 0x24: // $\n    case 0x2D: // -\n      return 'ident'\n\n    case 0x09: // Tab\n    case 0x0A: // Newline\n    case 0x0D: // Return\n    case 0xA0:  // No-break space\n    case 0xFEFF:  // Byte Order Mark\n    case 0x2028:  // Line Separator\n    case 0x2029:  // Paragraph Separator\n      return 'ws'\n  }\n\n  return 'ident'\n}\n\n/**\n * Format a subPath, return its plain form if it is\n * a literal string or number. Otherwise prepend the\n * dynamic indicator (*).\n */\n\nfunction formatSubPath (path) {\n  var trimmed = path.trim();\n  // invalid leading 0\n  if (path.charAt(0) === '0' && isNaN(path)) { return false }\n\n  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed\n}\n\n/**\n * Parse a string path into an array of segments\n */\n\nfunction parse$1 (path) {\n  var keys = [];\n  var index = -1;\n  var mode = BEFORE_PATH;\n  var subPathDepth = 0;\n  var c;\n  var key;\n  var newChar;\n  var type;\n  var transition;\n  var action;\n  var typeMap;\n  var actions = [];\n\n  actions[PUSH] = function () {\n    if (key !== undefined) {\n      keys.push(key);\n      key = undefined;\n    }\n  };\n\n  actions[APPEND] = function () {\n    if (key === undefined) {\n      key = newChar;\n    } else {\n      key += newChar;\n    }\n  };\n\n  actions[INC_SUB_PATH_DEPTH] = function () {\n    actions[APPEND]();\n    subPathDepth++;\n  };\n\n  actions[PUSH_SUB_PATH] = function () {\n    if (subPathDepth > 0) {\n      subPathDepth--;\n      mode = IN_SUB_PATH;\n      actions[APPEND]();\n    } else {\n      subPathDepth = 0;\n      if (key === undefined) { return false }\n      key = formatSubPath(key);\n      if (key === false) {\n        return false\n      } else {\n        actions[PUSH]();\n      }\n    }\n  };\n\n  function maybeUnescapeQuote () {\n    var nextChar = path[index + 1];\n    if ((mode === IN_SINGLE_QUOTE && nextChar === \"'\") ||\n      (mode === IN_DOUBLE_QUOTE && nextChar === '\"')) {\n      index++;\n      newChar = '\\\\' + nextChar;\n      actions[APPEND]();\n      return true\n    }\n  }\n\n  while (mode !== null) {\n    index++;\n    c = path[index];\n\n    if (c === '\\\\' && maybeUnescapeQuote()) {\n      continue\n    }\n\n    type = getPathCharType(c);\n    typeMap = pathStateMachine[mode];\n    transition = typeMap[type] || typeMap['else'] || ERROR;\n\n    if (transition === ERROR) {\n      return // parse error\n    }\n\n    mode = transition[0];\n    action = actions[transition[1]];\n    if (action) {\n      newChar = transition[2];\n      newChar = newChar === undefined\n        ? c\n        : newChar;\n      if (action() === false) {\n        return\n      }\n    }\n\n    if (mode === AFTER_PATH) {\n      return keys\n    }\n  }\n}\n\n\n\n\n\nvar I18nPath = function I18nPath () {\n  this._cache = Object.create(null);\n};\n\n/**\n * External parse that check for a cache hit first\n */\nI18nPath.prototype.parsePath = function parsePath (path) {\n  var hit = this._cache[path];\n  if (!hit) {\n    hit = parse$1(path);\n    if (hit) {\n      this._cache[path] = hit;\n    }\n  }\n  return hit || []\n};\n\n/**\n * Get path value from path string\n */\nI18nPath.prototype.getPathValue = function getPathValue (obj, path) {\n  if (!isObject(obj)) { return null }\n\n  var paths = this.parsePath(path);\n  if (paths.length === 0) {\n    return null\n  } else {\n    var length = paths.length;\n    var last = obj;\n    var i = 0;\n    while (i < length) {\n      var value = last[paths[i]];\n      if (value === undefined) {\n        return null\n      }\n      last = value;\n      i++;\n    }\n\n    return last\n  }\n};\n\n/*  */\n\n\n\nvar htmlTagMatcher = /<\\/?[\\w\\s=\"/.':;#-\\/]+>/;\nvar linkKeyMatcher = /(?:@(?:\\.[a-z]+)?:(?:[\\w\\-_|.]+|\\([\\w\\-_|.]+\\)))/g;\nvar linkKeyPrefixMatcher = /^@(?:\\.([a-z]+))?:/;\nvar bracketsMatcher = /[()]/g;\nvar defaultModifiers = {\n  'upper': function (str) { return str.toLocaleUpperCase(); },\n  'lower': function (str) { return str.toLocaleLowerCase(); },\n  'capitalize': function (str) { return (\"\" + (str.charAt(0).toLocaleUpperCase()) + (str.substr(1))); }\n};\n\nvar defaultFormatter = new BaseFormatter();\n\nvar VueI18n = function VueI18n (options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  // Auto install if it is not done yet and `window` has `Vue`.\n  // To allow users to avoid auto-installation in some cases,\n  // this code should be placed here. See #290\n  /* istanbul ignore if */\n  if (!Vue && typeof window !== 'undefined' && window.Vue) {\n    install(window.Vue);\n  }\n\n  var locale = options.locale || 'en-US';\n  var fallbackLocale = options.fallbackLocale === false\n    ? false\n    : options.fallbackLocale || 'en-US';\n  var messages = options.messages || {};\n  var dateTimeFormats = options.dateTimeFormats || {};\n  var numberFormats = options.numberFormats || {};\n\n  this._vm = null;\n  this._formatter = options.formatter || defaultFormatter;\n  this._modifiers = options.modifiers || {};\n  this._missing = options.missing || null;\n  this._root = options.root || null;\n  this._sync = options.sync === undefined ? true : !!options.sync;\n  this._fallbackRoot = options.fallbackRoot === undefined\n    ? true\n    : !!options.fallbackRoot;\n  this._formatFallbackMessages = options.formatFallbackMessages === undefined\n    ? false\n    : !!options.formatFallbackMessages;\n  this._silentTranslationWarn = options.silentTranslationWarn === undefined\n    ? false\n    : options.silentTranslationWarn;\n  this._silentFallbackWarn = options.silentFallbackWarn === undefined\n    ? false\n    : !!options.silentFallbackWarn;\n  this._dateTimeFormatters = {};\n  this._numberFormatters = {};\n  this._path = new I18nPath();\n  this._dataListeners = [];\n  this._componentInstanceCreatedListener = options.componentInstanceCreatedListener || null;\n  this._preserveDirectiveContent = options.preserveDirectiveContent === undefined\n    ? false\n    : !!options.preserveDirectiveContent;\n  this.pluralizationRules = options.pluralizationRules || {};\n  this._warnHtmlInMessage = options.warnHtmlInMessage || 'off';\n  this._postTranslation = options.postTranslation || null;\n\n  /**\n   * @param choice {number} a choice index given by the input to $tc: `$tc('path.to.rule', choiceIndex)`\n   * @param choicesLength {number} an overall amount of available choices\n   * @returns a final choice index\n  */\n  this.getChoiceIndex = function (choice, choicesLength) {\n    var thisPrototype = Object.getPrototypeOf(this$1);\n    if (thisPrototype && thisPrototype.getChoiceIndex) {\n      var prototypeGetChoiceIndex = (thisPrototype.getChoiceIndex);\n      return (prototypeGetChoiceIndex).call(this$1, choice, choicesLength)\n    }\n\n    // Default (old) getChoiceIndex implementation - english-compatible\n    var defaultImpl = function (_choice, _choicesLength) {\n      _choice = Math.abs(_choice);\n\n      if (_choicesLength === 2) {\n        return _choice\n          ? _choice > 1\n            ? 1\n            : 0\n          : 1\n      }\n\n      return _choice ? Math.min(_choice, 2) : 0\n    };\n\n    if (this$1.locale in this$1.pluralizationRules) {\n      return this$1.pluralizationRules[this$1.locale].apply(this$1, [choice, choicesLength])\n    } else {\n      return defaultImpl(choice, choicesLength)\n    }\n  };\n\n\n  this._exist = function (message, key) {\n    if (!message || !key) { return false }\n    if (!isNull(this$1._path.getPathValue(message, key))) { return true }\n    // fallback for flat key\n    if (message[key]) { return true }\n    return false\n  };\n\n  if (this._warnHtmlInMessage === 'warn' || this._warnHtmlInMessage === 'error') {\n    Object.keys(messages).forEach(function (locale) {\n      this$1._checkLocaleMessage(locale, this$1._warnHtmlInMessage, messages[locale]);\n    });\n  }\n\n  this._initVM({\n    locale: locale,\n    fallbackLocale: fallbackLocale,\n    messages: messages,\n    dateTimeFormats: dateTimeFormats,\n    numberFormats: numberFormats\n  });\n};\n\nvar prototypeAccessors = { vm: { configurable: true },messages: { configurable: true },dateTimeFormats: { configurable: true },numberFormats: { configurable: true },availableLocales: { configurable: true },locale: { configurable: true },fallbackLocale: { configurable: true },formatFallbackMessages: { configurable: true },missing: { configurable: true },formatter: { configurable: true },silentTranslationWarn: { configurable: true },silentFallbackWarn: { configurable: true },preserveDirectiveContent: { configurable: true },warnHtmlInMessage: { configurable: true },postTranslation: { configurable: true } };\n\nVueI18n.prototype._checkLocaleMessage = function _checkLocaleMessage (locale, level, message) {\n  var paths = [];\n\n  var fn = function (level, locale, message, paths) {\n    if (isPlainObject(message)) {\n      Object.keys(message).forEach(function (key) {\n        var val = message[key];\n        if (isPlainObject(val)) {\n          paths.push(key);\n          paths.push('.');\n          fn(level, locale, val, paths);\n          paths.pop();\n          paths.pop();\n        } else {\n          paths.push(key);\n          fn(level, locale, val, paths);\n          paths.pop();\n        }\n      });\n    } else if (isArray(message)) {\n      message.forEach(function (item, index) {\n        if (isPlainObject(item)) {\n          paths.push((\"[\" + index + \"]\"));\n          paths.push('.');\n          fn(level, locale, item, paths);\n          paths.pop();\n          paths.pop();\n        } else {\n          paths.push((\"[\" + index + \"]\"));\n          fn(level, locale, item, paths);\n          paths.pop();\n        }\n      });\n    } else if (isString(message)) {\n      var ret = htmlTagMatcher.test(message);\n      if (ret) {\n        var msg = \"Detected HTML in message '\" + message + \"' of keypath '\" + (paths.join('')) + \"' at '\" + locale + \"'. Consider component interpolation with '<i18n>' to avoid XSS. See https://bit.ly/2ZqJzkp\";\n        if (level === 'warn') {\n          warn(msg);\n        } else if (level === 'error') {\n          error(msg);\n        }\n      }\n    }\n  };\n\n  fn(level, locale, message, paths);\n};\n\nVueI18n.prototype._initVM = function _initVM (data) {\n  var silent = Vue.config.silent;\n  Vue.config.silent = true;\n  this._vm = new Vue({ data: data });\n  Vue.config.silent = silent;\n};\n\nVueI18n.prototype.destroyVM = function destroyVM () {\n  this._vm.$destroy();\n};\n\nVueI18n.prototype.subscribeDataChanging = function subscribeDataChanging (vm) {\n  this._dataListeners.push(vm);\n};\n\nVueI18n.prototype.unsubscribeDataChanging = function unsubscribeDataChanging (vm) {\n  remove(this._dataListeners, vm);\n};\n\nVueI18n.prototype.watchI18nData = function watchI18nData () {\n  var self = this;\n  return this._vm.$watch('$data', function () {\n    var i = self._dataListeners.length;\n    while (i--) {\n      Vue.nextTick(function () {\n        self._dataListeners[i] && self._dataListeners[i].$forceUpdate();\n      });\n    }\n  }, { deep: true })\n};\n\nVueI18n.prototype.watchLocale = function watchLocale () {\n  /* istanbul ignore if */\n  if (!this._sync || !this._root) { return null }\n  var target = this._vm;\n  return this._root.$i18n.vm.$watch('locale', function (val) {\n    target.$set(target, 'locale', val);\n    target.$forceUpdate();\n  }, { immediate: true })\n};\n\nVueI18n.prototype.onComponentInstanceCreated = function onComponentInstanceCreated (newI18n) {\n  if (this._componentInstanceCreatedListener) {\n    this._componentInstanceCreatedListener(newI18n, this);\n  }\n};\n\nprototypeAccessors.vm.get = function () { return this._vm };\n\nprototypeAccessors.messages.get = function () { return looseClone(this._getMessages()) };\nprototypeAccessors.dateTimeFormats.get = function () { return looseClone(this._getDateTimeFormats()) };\nprototypeAccessors.numberFormats.get = function () { return looseClone(this._getNumberFormats()) };\nprototypeAccessors.availableLocales.get = function () { return Object.keys(this.messages).sort() };\n\nprototypeAccessors.locale.get = function () { return this._vm.locale };\nprototypeAccessors.locale.set = function (locale) {\n  this._vm.$set(this._vm, 'locale', locale);\n};\n\nprototypeAccessors.fallbackLocale.get = function () { return this._vm.fallbackLocale };\nprototypeAccessors.fallbackLocale.set = function (locale) {\n  this._localeChainCache = {};\n  this._vm.$set(this._vm, 'fallbackLocale', locale);\n};\n\nprototypeAccessors.formatFallbackMessages.get = function () { return this._formatFallbackMessages };\nprototypeAccessors.formatFallbackMessages.set = function (fallback) { this._formatFallbackMessages = fallback; };\n\nprototypeAccessors.missing.get = function () { return this._missing };\nprototypeAccessors.missing.set = function (handler) { this._missing = handler; };\n\nprototypeAccessors.formatter.get = function () { return this._formatter };\nprototypeAccessors.formatter.set = function (formatter) { this._formatter = formatter; };\n\nprototypeAccessors.silentTranslationWarn.get = function () { return this._silentTranslationWarn };\nprototypeAccessors.silentTranslationWarn.set = function (silent) { this._silentTranslationWarn = silent; };\n\nprototypeAccessors.silentFallbackWarn.get = function () { return this._silentFallbackWarn };\nprototypeAccessors.silentFallbackWarn.set = function (silent) { this._silentFallbackWarn = silent; };\n\nprototypeAccessors.preserveDirectiveContent.get = function () { return this._preserveDirectiveContent };\nprototypeAccessors.preserveDirectiveContent.set = function (preserve) { this._preserveDirectiveContent = preserve; };\n\nprototypeAccessors.warnHtmlInMessage.get = function () { return this._warnHtmlInMessage };\nprototypeAccessors.warnHtmlInMessage.set = function (level) {\n    var this$1 = this;\n\n  var orgLevel = this._warnHtmlInMessage;\n  this._warnHtmlInMessage = level;\n  if (orgLevel !== level && (level === 'warn' || level === 'error')) {\n    var messages = this._getMessages();\n    Object.keys(messages).forEach(function (locale) {\n      this$1._checkLocaleMessage(locale, this$1._warnHtmlInMessage, messages[locale]);\n    });\n  }\n};\n\nprototypeAccessors.postTranslation.get = function () { return this._postTranslation };\nprototypeAccessors.postTranslation.set = function (handler) { this._postTranslation = handler; };\n\nVueI18n.prototype._getMessages = function _getMessages () { return this._vm.messages };\nVueI18n.prototype._getDateTimeFormats = function _getDateTimeFormats () { return this._vm.dateTimeFormats };\nVueI18n.prototype._getNumberFormats = function _getNumberFormats () { return this._vm.numberFormats };\n\nVueI18n.prototype._warnDefault = function _warnDefault (locale, key, result, vm, values, interpolateMode) {\n  if (!isNull(result)) { return result }\n  if (this._missing) {\n    var missingRet = this._missing.apply(null, [locale, key, vm, values]);\n    if (isString(missingRet)) {\n      return missingRet\n    }\n  } else {\n    if (process.env.NODE_ENV !== 'production' && !this._isSilentTranslationWarn(key)) {\n      warn(\n        \"Cannot translate the value of keypath '\" + key + \"'. \" +\n        'Use the value of keypath as default.'\n      );\n    }\n  }\n\n  if (this._formatFallbackMessages) {\n    var parsedArgs = parseArgs.apply(void 0, values);\n    return this._render(key, interpolateMode, parsedArgs.params, key)\n  } else {\n    return key\n  }\n};\n\nVueI18n.prototype._isFallbackRoot = function _isFallbackRoot (val) {\n  return !val && !isNull(this._root) && this._fallbackRoot\n};\n\nVueI18n.prototype._isSilentFallbackWarn = function _isSilentFallbackWarn (key) {\n  return this._silentFallbackWarn instanceof RegExp\n    ? this._silentFallbackWarn.test(key)\n    : this._silentFallbackWarn\n};\n\nVueI18n.prototype._isSilentFallback = function _isSilentFallback (locale, key) {\n  return this._isSilentFallbackWarn(key) && (this._isFallbackRoot() || locale !== this.fallbackLocale)\n};\n\nVueI18n.prototype._isSilentTranslationWarn = function _isSilentTranslationWarn (key) {\n  return this._silentTranslationWarn instanceof RegExp\n    ? this._silentTranslationWarn.test(key)\n    : this._silentTranslationWarn\n};\n\nVueI18n.prototype._interpolate = function _interpolate (\n  locale,\n  message,\n  key,\n  host,\n  interpolateMode,\n  values,\n  visitedLinkStack\n) {\n  if (!message) { return null }\n\n  var pathRet = this._path.getPathValue(message, key);\n  if (isArray(pathRet) || isPlainObject(pathRet)) { return pathRet }\n\n  var ret;\n  if (isNull(pathRet)) {\n    /* istanbul ignore else */\n    if (isPlainObject(message)) {\n      ret = message[key];\n      if (!(isString(ret) || isFunction(ret))) {\n        if (process.env.NODE_ENV !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallback(locale, key)) {\n          warn((\"Value of key '\" + key + \"' is not a string or function !\"));\n        }\n        return null\n      }\n    } else {\n      return null\n    }\n  } else {\n    /* istanbul ignore else */\n    if (isString(pathRet) || isFunction(pathRet)) {\n      ret = pathRet;\n    } else {\n      if (process.env.NODE_ENV !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallback(locale, key)) {\n        warn((\"Value of key '\" + key + \"' is not a string or function!\"));\n      }\n      return null\n    }\n  }\n\n  // Check for the existence of links within the translated string\n  if (isString(ret) && (ret.indexOf('@:') >= 0 || ret.indexOf('@.') >= 0)) {\n    ret = this._link(locale, message, ret, host, 'raw', values, visitedLinkStack);\n  }\n\n  return this._render(ret, interpolateMode, values, key)\n};\n\nVueI18n.prototype._link = function _link (\n  locale,\n  message,\n  str,\n  host,\n  interpolateMode,\n  values,\n  visitedLinkStack\n) {\n  var ret = str;\n\n  // Match all the links within the local\n  // We are going to replace each of\n  // them with its translation\n  var matches = ret.match(linkKeyMatcher);\n  for (var idx in matches) {\n    // ie compatible: filter custom array\n    // prototype method\n    if (!matches.hasOwnProperty(idx)) {\n      continue\n    }\n    var link = matches[idx];\n    var linkKeyPrefixMatches = link.match(linkKeyPrefixMatcher);\n    var linkPrefix = linkKeyPrefixMatches[0];\n      var formatterName = linkKeyPrefixMatches[1];\n\n    // Remove the leading @:, @.case: and the brackets\n    var linkPlaceholder = link.replace(linkPrefix, '').replace(bracketsMatcher, '');\n\n    if (includes(visitedLinkStack, linkPlaceholder)) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn((\"Circular reference found. \\\"\" + link + \"\\\" is already visited in the chain of \" + (visitedLinkStack.reverse().join(' <- '))));\n      }\n      return ret\n    }\n    visitedLinkStack.push(linkPlaceholder);\n\n    // Translate the link\n    var translated = this._interpolate(\n      locale, message, linkPlaceholder, host,\n      interpolateMode === 'raw' ? 'string' : interpolateMode,\n      interpolateMode === 'raw' ? undefined : values,\n      visitedLinkStack\n    );\n\n    if (this._isFallbackRoot(translated)) {\n      if (process.env.NODE_ENV !== 'production' && !this._isSilentTranslationWarn(linkPlaceholder)) {\n        warn((\"Fall back to translate the link placeholder '\" + linkPlaceholder + \"' with root locale.\"));\n      }\n      /* istanbul ignore if */\n      if (!this._root) { throw Error('unexpected error') }\n      var root = this._root.$i18n;\n      translated = root._translate(\n        root._getMessages(), root.locale, root.fallbackLocale,\n        linkPlaceholder, host, interpolateMode, values\n      );\n    }\n    translated = this._warnDefault(\n      locale, linkPlaceholder, translated, host,\n      isArray(values) ? values : [values],\n      interpolateMode\n    );\n\n    if (this._modifiers.hasOwnProperty(formatterName)) {\n      translated = this._modifiers[formatterName](translated);\n    } else if (defaultModifiers.hasOwnProperty(formatterName)) {\n      translated = defaultModifiers[formatterName](translated);\n    }\n\n    visitedLinkStack.pop();\n\n    // Replace the link with the translated\n    ret = !translated ? ret : ret.replace(link, translated);\n  }\n\n  return ret\n};\n\nVueI18n.prototype._createMessageContext = function _createMessageContext (values) {\n  var _list = isArray(values) ? values : [];\n  var _named = isObject(values) ? values : {};\n  var list = function (index) { return _list[index]; };\n  var named = function (key) { return _named[key]; };\n  return {\n    list: list,\n    named: named\n  }\n};\n\nVueI18n.prototype._render = function _render (message, interpolateMode, values, path) {\n  if (isFunction(message)) {\n    return message(this._createMessageContext(values))\n  }\n\n  var ret = this._formatter.interpolate(message, values, path);\n\n  // If the custom formatter refuses to work - apply the default one\n  if (!ret) {\n    ret = defaultFormatter.interpolate(message, values, path);\n  }\n\n  // if interpolateMode is **not** 'string' ('row'),\n  // return the compiled data (e.g. ['foo', VNode, 'bar']) with formatter\n  return interpolateMode === 'string' && !isString(ret) ? ret.join('') : ret\n};\n\nVueI18n.prototype._appendItemToChain = function _appendItemToChain (chain, item, blocks) {\n  var follow = false;\n  if (!includes(chain, item)) {\n    follow = true;\n    if (item) {\n      follow = item[item.length - 1] !== '!';\n      item = item.replace(/!/g, '');\n      chain.push(item);\n      if (blocks && blocks[item]) {\n        follow = blocks[item];\n      }\n    }\n  }\n  return follow\n};\n\nVueI18n.prototype._appendLocaleToChain = function _appendLocaleToChain (chain, locale, blocks) {\n  var follow;\n  var tokens = locale.split('-');\n  do {\n    var item = tokens.join('-');\n    follow = this._appendItemToChain(chain, item, blocks);\n    tokens.splice(-1, 1);\n  } while (tokens.length && (follow === true))\n  return follow\n};\n\nVueI18n.prototype._appendBlockToChain = function _appendBlockToChain (chain, block, blocks) {\n  var follow = true;\n  for (var i = 0; (i < block.length) && (isBoolean(follow)); i++) {\n    var locale = block[i];\n    if (isString(locale)) {\n      follow = this._appendLocaleToChain(chain, locale, blocks);\n    }\n  }\n  return follow\n};\n\nVueI18n.prototype._getLocaleChain = function _getLocaleChain (start, fallbackLocale) {\n  if (start === '') { return [] }\n\n  if (!this._localeChainCache) {\n    this._localeChainCache = {};\n  }\n\n  var chain = this._localeChainCache[start];\n  if (!chain) {\n    if (!fallbackLocale) {\n      fallbackLocale = this.fallbackLocale;\n    }\n    chain = [];\n\n    // first block defined by start\n    var block = [start];\n\n    // while any intervening block found\n    while (isArray(block)) {\n      block = this._appendBlockToChain(\n        chain,\n        block,\n        fallbackLocale\n      );\n    }\n\n    // last block defined by default\n    var defaults;\n    if (isArray(fallbackLocale)) {\n      defaults = fallbackLocale;\n    } else if (isObject(fallbackLocale)) {\n      /* $FlowFixMe */\n      if (fallbackLocale['default']) {\n        defaults = fallbackLocale['default'];\n      } else {\n        defaults = null;\n      }\n    } else {\n      defaults = fallbackLocale;\n    }\n\n    // convert defaults to array\n    if (isString(defaults)) {\n      block = [defaults];\n    } else {\n      block = defaults;\n    }\n    if (block) {\n      this._appendBlockToChain(\n        chain,\n        block,\n        null\n      );\n    }\n    this._localeChainCache[start] = chain;\n  }\n  return chain\n};\n\nVueI18n.prototype._translate = function _translate (\n  messages,\n  locale,\n  fallback,\n  key,\n  host,\n  interpolateMode,\n  args\n) {\n  var chain = this._getLocaleChain(locale, fallback);\n  var res;\n  for (var i = 0; i < chain.length; i++) {\n    var step = chain[i];\n    res =\n      this._interpolate(step, messages[step], key, host, interpolateMode, args, [key]);\n    if (!isNull(res)) {\n      if (step !== locale && process.env.NODE_ENV !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {\n        warn((\"Fall back to translate the keypath '\" + key + \"' with '\" + step + \"' locale.\"));\n      }\n      return res\n    }\n  }\n  return null\n};\n\nVueI18n.prototype._t = function _t (key, _locale, messages, host) {\n    var ref;\n\n    var values = [], len = arguments.length - 4;\n    while ( len-- > 0 ) values[ len ] = arguments[ len + 4 ];\n  if (!key) { return '' }\n\n  var parsedArgs = parseArgs.apply(void 0, values);\n  var locale = parsedArgs.locale || _locale;\n\n  var ret = this._translate(\n    messages, locale, this.fallbackLocale, key,\n    host, 'string', parsedArgs.params\n  );\n  if (this._isFallbackRoot(ret)) {\n    if (process.env.NODE_ENV !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {\n      warn((\"Fall back to translate the keypath '\" + key + \"' with root locale.\"));\n    }\n    /* istanbul ignore if */\n    if (!this._root) { throw Error('unexpected error') }\n    return (ref = this._root).$t.apply(ref, [ key ].concat( values ))\n  } else {\n    ret = this._warnDefault(locale, key, ret, host, values, 'string');\n    if (this._postTranslation && ret !== null && ret !== undefined) {\n      ret = this._postTranslation(ret, key);\n    }\n    return ret\n  }\n};\n\nVueI18n.prototype.t = function t (key) {\n    var ref;\n\n    var values = [], len = arguments.length - 1;\n    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n  return (ref = this)._t.apply(ref, [ key, this.locale, this._getMessages(), null ].concat( values ))\n};\n\nVueI18n.prototype._i = function _i (key, locale, messages, host, values) {\n  var ret =\n    this._translate(messages, locale, this.fallbackLocale, key, host, 'raw', values);\n  if (this._isFallbackRoot(ret)) {\n    if (process.env.NODE_ENV !== 'production' && !this._isSilentTranslationWarn(key)) {\n      warn((\"Fall back to interpolate the keypath '\" + key + \"' with root locale.\"));\n    }\n    if (!this._root) { throw Error('unexpected error') }\n    return this._root.$i18n.i(key, locale, values)\n  } else {\n    return this._warnDefault(locale, key, ret, host, [values], 'raw')\n  }\n};\n\nVueI18n.prototype.i = function i (key, locale, values) {\n  /* istanbul ignore if */\n  if (!key) { return '' }\n\n  if (!isString(locale)) {\n    locale = this.locale;\n  }\n\n  return this._i(key, locale, this._getMessages(), null, values)\n};\n\nVueI18n.prototype._tc = function _tc (\n  key,\n  _locale,\n  messages,\n  host,\n  choice\n) {\n    var ref;\n\n    var values = [], len = arguments.length - 5;\n    while ( len-- > 0 ) values[ len ] = arguments[ len + 5 ];\n  if (!key) { return '' }\n  if (choice === undefined) {\n    choice = 1;\n  }\n\n  var predefined = { 'count': choice, 'n': choice };\n  var parsedArgs = parseArgs.apply(void 0, values);\n  parsedArgs.params = Object.assign(predefined, parsedArgs.params);\n  values = parsedArgs.locale === null ? [parsedArgs.params] : [parsedArgs.locale, parsedArgs.params];\n  return this.fetchChoice((ref = this)._t.apply(ref, [ key, _locale, messages, host ].concat( values )), choice)\n};\n\nVueI18n.prototype.fetchChoice = function fetchChoice (message, choice) {\n  /* istanbul ignore if */\n  if (!message && !isString(message)) { return null }\n  var choices = message.split('|');\n\n  choice = this.getChoiceIndex(choice, choices.length);\n  if (!choices[choice]) { return message }\n  return choices[choice].trim()\n};\n\nVueI18n.prototype.tc = function tc (key, choice) {\n    var ref;\n\n    var values = [], len = arguments.length - 2;\n    while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];\n  return (ref = this)._tc.apply(ref, [ key, this.locale, this._getMessages(), null, choice ].concat( values ))\n};\n\nVueI18n.prototype._te = function _te (key, locale, messages) {\n    var args = [], len = arguments.length - 3;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 3 ];\n\n  var _locale = parseArgs.apply(void 0, args).locale || locale;\n  return this._exist(messages[_locale], key)\n};\n\nVueI18n.prototype.te = function te (key, locale) {\n  return this._te(key, this.locale, this._getMessages(), locale)\n};\n\nVueI18n.prototype.getLocaleMessage = function getLocaleMessage (locale) {\n  return looseClone(this._vm.messages[locale] || {})\n};\n\nVueI18n.prototype.setLocaleMessage = function setLocaleMessage (locale, message) {\n  if (this._warnHtmlInMessage === 'warn' || this._warnHtmlInMessage === 'error') {\n    this._checkLocaleMessage(locale, this._warnHtmlInMessage, message);\n  }\n  this._vm.$set(this._vm.messages, locale, message);\n};\n\nVueI18n.prototype.mergeLocaleMessage = function mergeLocaleMessage (locale, message) {\n  if (this._warnHtmlInMessage === 'warn' || this._warnHtmlInMessage === 'error') {\n    this._checkLocaleMessage(locale, this._warnHtmlInMessage, message);\n  }\n  this._vm.$set(this._vm.messages, locale, merge({}, this._vm.messages[locale] || {}, message));\n};\n\nVueI18n.prototype.getDateTimeFormat = function getDateTimeFormat (locale) {\n  return looseClone(this._vm.dateTimeFormats[locale] || {})\n};\n\nVueI18n.prototype.setDateTimeFormat = function setDateTimeFormat (locale, format) {\n  this._vm.$set(this._vm.dateTimeFormats, locale, format);\n  this._clearDateTimeFormat(locale, format);\n};\n\nVueI18n.prototype.mergeDateTimeFormat = function mergeDateTimeFormat (locale, format) {\n  this._vm.$set(this._vm.dateTimeFormats, locale, merge(this._vm.dateTimeFormats[locale] || {}, format));\n  this._clearDateTimeFormat(locale, format);\n};\n\nVueI18n.prototype._clearDateTimeFormat = function _clearDateTimeFormat (locale, format) {\n  for (var key in format) {\n    var id = locale + \"__\" + key;\n\n    if (!this._dateTimeFormatters.hasOwnProperty(id)) {\n      continue\n    }\n\n    delete this._dateTimeFormatters[id];\n  }\n};\n\nVueI18n.prototype._localizeDateTime = function _localizeDateTime (\n  value,\n  locale,\n  fallback,\n  dateTimeFormats,\n  key\n) {\n  var _locale = locale;\n  var formats = dateTimeFormats[_locale];\n\n  var chain = this._getLocaleChain(locale, fallback);\n  for (var i = 0; i < chain.length; i++) {\n    var current = _locale;\n    var step = chain[i];\n    formats = dateTimeFormats[step];\n    _locale = step;\n    // fallback locale\n    if (isNull(formats) || isNull(formats[key])) {\n      if (step !== locale && process.env.NODE_ENV !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {\n        warn((\"Fall back to '\" + step + \"' datetime formats from '\" + current + \"' datetime formats.\"));\n      }\n    } else {\n      break\n    }\n  }\n\n  if (isNull(formats) || isNull(formats[key])) {\n    return null\n  } else {\n    var format = formats[key];\n    var id = _locale + \"__\" + key;\n    var formatter = this._dateTimeFormatters[id];\n    if (!formatter) {\n      formatter = this._dateTimeFormatters[id] = new Intl.DateTimeFormat(_locale, format);\n    }\n    return formatter.format(value)\n  }\n};\n\nVueI18n.prototype._d = function _d (value, locale, key) {\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && !VueI18n.availabilities.dateTimeFormat) {\n    warn('Cannot format a Date value due to not supported Intl.DateTimeFormat.');\n    return ''\n  }\n\n  if (!key) {\n    return new Intl.DateTimeFormat(locale).format(value)\n  }\n\n  var ret =\n    this._localizeDateTime(value, locale, this.fallbackLocale, this._getDateTimeFormats(), key);\n  if (this._isFallbackRoot(ret)) {\n    if (process.env.NODE_ENV !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {\n      warn((\"Fall back to datetime localization of root: key '\" + key + \"'.\"));\n    }\n    /* istanbul ignore if */\n    if (!this._root) { throw Error('unexpected error') }\n    return this._root.$i18n.d(value, key, locale)\n  } else {\n    return ret || ''\n  }\n};\n\nVueI18n.prototype.d = function d (value) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  var locale = this.locale;\n  var key = null;\n\n  if (args.length === 1) {\n    if (isString(args[0])) {\n      key = args[0];\n    } else if (isObject(args[0])) {\n      if (args[0].locale) {\n        locale = args[0].locale;\n      }\n      if (args[0].key) {\n        key = args[0].key;\n      }\n    }\n  } else if (args.length === 2) {\n    if (isString(args[0])) {\n      key = args[0];\n    }\n    if (isString(args[1])) {\n      locale = args[1];\n    }\n  }\n\n  return this._d(value, locale, key)\n};\n\nVueI18n.prototype.getNumberFormat = function getNumberFormat (locale) {\n  return looseClone(this._vm.numberFormats[locale] || {})\n};\n\nVueI18n.prototype.setNumberFormat = function setNumberFormat (locale, format) {\n  this._vm.$set(this._vm.numberFormats, locale, format);\n  this._clearNumberFormat(locale, format);\n};\n\nVueI18n.prototype.mergeNumberFormat = function mergeNumberFormat (locale, format) {\n  this._vm.$set(this._vm.numberFormats, locale, merge(this._vm.numberFormats[locale] || {}, format));\n  this._clearNumberFormat(locale, format);\n};\n\nVueI18n.prototype._clearNumberFormat = function _clearNumberFormat (locale, format) {\n  for (var key in format) {\n    var id = locale + \"__\" + key;\n\n    if (!this._numberFormatters.hasOwnProperty(id)) {\n      continue\n    }\n\n    delete this._numberFormatters[id];\n  }\n};\n\nVueI18n.prototype._getNumberFormatter = function _getNumberFormatter (\n  value,\n  locale,\n  fallback,\n  numberFormats,\n  key,\n  options\n) {\n  var _locale = locale;\n  var formats = numberFormats[_locale];\n\n  var chain = this._getLocaleChain(locale, fallback);\n  for (var i = 0; i < chain.length; i++) {\n    var current = _locale;\n    var step = chain[i];\n    formats = numberFormats[step];\n    _locale = step;\n    // fallback locale\n    if (isNull(formats) || isNull(formats[key])) {\n      if (step !== locale && process.env.NODE_ENV !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {\n        warn((\"Fall back to '\" + step + \"' number formats from '\" + current + \"' number formats.\"));\n      }\n    } else {\n      break\n    }\n  }\n\n  if (isNull(formats) || isNull(formats[key])) {\n    return null\n  } else {\n    var format = formats[key];\n\n    var formatter;\n    if (options) {\n      // If options specified - create one time number formatter\n      formatter = new Intl.NumberFormat(_locale, Object.assign({}, format, options));\n    } else {\n      var id = _locale + \"__\" + key;\n      formatter = this._numberFormatters[id];\n      if (!formatter) {\n        formatter = this._numberFormatters[id] = new Intl.NumberFormat(_locale, format);\n      }\n    }\n    return formatter\n  }\n};\n\nVueI18n.prototype._n = function _n (value, locale, key, options) {\n  /* istanbul ignore if */\n  if (!VueI18n.availabilities.numberFormat) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn('Cannot format a Number value due to not supported Intl.NumberFormat.');\n    }\n    return ''\n  }\n\n  if (!key) {\n    var nf = !options ? new Intl.NumberFormat(locale) : new Intl.NumberFormat(locale, options);\n    return nf.format(value)\n  }\n\n  var formatter = this._getNumberFormatter(value, locale, this.fallbackLocale, this._getNumberFormats(), key, options);\n  var ret = formatter && formatter.format(value);\n  if (this._isFallbackRoot(ret)) {\n    if (process.env.NODE_ENV !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {\n      warn((\"Fall back to number localization of root: key '\" + key + \"'.\"));\n    }\n    /* istanbul ignore if */\n    if (!this._root) { throw Error('unexpected error') }\n    return this._root.$i18n.n(value, Object.assign({}, { key: key, locale: locale }, options))\n  } else {\n    return ret || ''\n  }\n};\n\nVueI18n.prototype.n = function n (value) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  var locale = this.locale;\n  var key = null;\n  var options = null;\n\n  if (args.length === 1) {\n    if (isString(args[0])) {\n      key = args[0];\n    } else if (isObject(args[0])) {\n      if (args[0].locale) {\n        locale = args[0].locale;\n      }\n      if (args[0].key) {\n        key = args[0].key;\n      }\n\n      // Filter out number format options only\n      options = Object.keys(args[0]).reduce(function (acc, key) {\n          var obj;\n\n        if (includes(numberFormatKeys, key)) {\n          return Object.assign({}, acc, ( obj = {}, obj[key] = args[0][key], obj ))\n        }\n        return acc\n      }, null);\n    }\n  } else if (args.length === 2) {\n    if (isString(args[0])) {\n      key = args[0];\n    }\n    if (isString(args[1])) {\n      locale = args[1];\n    }\n  }\n\n  return this._n(value, locale, key, options)\n};\n\nVueI18n.prototype._ntp = function _ntp (value, locale, key, options) {\n  /* istanbul ignore if */\n  if (!VueI18n.availabilities.numberFormat) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn('Cannot format to parts a Number value due to not supported Intl.NumberFormat.');\n    }\n    return []\n  }\n\n  if (!key) {\n    var nf = !options ? new Intl.NumberFormat(locale) : new Intl.NumberFormat(locale, options);\n    return nf.formatToParts(value)\n  }\n\n  var formatter = this._getNumberFormatter(value, locale, this.fallbackLocale, this._getNumberFormats(), key, options);\n  var ret = formatter && formatter.formatToParts(value);\n  if (this._isFallbackRoot(ret)) {\n    if (process.env.NODE_ENV !== 'production' && !this._isSilentTranslationWarn(key)) {\n      warn((\"Fall back to format number to parts of root: key '\" + key + \"' .\"));\n    }\n    /* istanbul ignore if */\n    if (!this._root) { throw Error('unexpected error') }\n    return this._root.$i18n._ntp(value, locale, key, options)\n  } else {\n    return ret || []\n  }\n};\n\nObject.defineProperties( VueI18n.prototype, prototypeAccessors );\n\nvar availabilities;\n// $FlowFixMe\nObject.defineProperty(VueI18n, 'availabilities', {\n  get: function get () {\n    if (!availabilities) {\n      var intlDefined = typeof Intl !== 'undefined';\n      availabilities = {\n        dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== 'undefined',\n        numberFormat: intlDefined && typeof Intl.NumberFormat !== 'undefined'\n      };\n    }\n\n    return availabilities\n  }\n});\n\nVueI18n.install = install;\nVueI18n.version = '8.21.1';\n\nexport default VueI18n;\n","import { isObject } from '@empathyco/x-utils';\n\nenum Behaviour {\n  Replace = 'replace',\n  DeepMerge = 'deep-merge'\n}\n\n/**\n * Clones deeply all of the sources objects values into the target, except the arrays,\n * which only generates a new one, but keeping the references of the sources one.\n *\n * TODO Make it work with circular references.\n *\n * @param target - The object which will be used as the base to clone all the sources into.\n * @param sources - One or more objects to clone to the target.\n *\n * @returns The target modified.\n */\nexport function deepMerge(target: any, ...sources: any[]): any {\n  return sources.reduce(cloneSourcesProperties, target || {});\n}\n\nconst behaviourMap = new WeakMap();\n\n/**\n * When setting replace behaviour to an object, target properties will not be used,\n * only the source ones.\n *\n * @param obj - The object to set its merge behavior.\n * @example\n * ```ts\n * const target = { children: { a: 1, b: 2, c: 3 } };\n * const firstSource = { children: replaceBehaviour({ c: 4, d: 5 }) };\n * deepMerge(target, firstSource);\n * // `target` is now { children: { c: 4, d: 5 } }\n * ```\n *\n * @returns The same object with the new behaviour.\n */\nexport function replaceBehaviour<T extends Record<string, unknown>>(obj: T): T {\n  behaviourMap.set(obj, Behaviour.Replace);\n  return obj;\n}\n\n/**\n * When setting deep merge behaviour, target and source properties will be used. This is the default\n * behavior.\n *\n * @param obj - The object to set its merge behavior.\n *\n * @returns The same object with the new behaviour.\n */\nexport function deepMergeBehaviour<T extends Record<string, unknown>>(obj: T): T {\n  behaviourMap.set(obj, Behaviour.DeepMerge);\n  return obj;\n}\n\n/**\n * A function which clones the properties of two sources.\n *\n * @param target - The target object to clone in.\n * @param source - The source objet to clone.\n *\n * @returns The union of the target and source.\n */\nfunction cloneSourcesProperties(target: any, source: any): (source: any) => void {\n  if (source) {\n    return Object.entries(source).reduce(cloneObjectProperties, target);\n  } else {\n    return target || {};\n  }\n}\n\n/**\n * A function which clones the properties of two object.\n *\n * @param target - The target object to clone in.\n * @param source - Key-Value to clone into the target object.\n *\n * @returns The target object updated with the entry parameter.\n */\nfunction cloneObjectProperties(target: any, [key, value]: any): any {\n  if (value === undefined) {\n    delete target[key];\n  } else if (isObject(value)) {\n    mergeObject(target, [key, value]);\n  } else if (Array.isArray(value)) {\n    target[key] = [...value];\n  } else {\n    target[key] = value;\n  }\n  return target;\n}\n\n/**\n * A function which merges two sources.\n *\n * @param target - The target object to clone in.\n * @param source - Key-Value to clone into the target object.\n *\n */\nfunction mergeObject(target: any, [key, value]: any): void {\n  const mergeBehaviour = getMergeBehaviour(target[key], value);\n  if (mergeBehaviour === Behaviour.Replace) {\n    target[key] = deepMerge({}, value);\n    replaceBehaviour(target[key]);\n  } else if (mergeBehaviour === Behaviour.DeepMerge) {\n    target[key] = deepMerge(target[key] || {}, value);\n    deepMergeBehaviour(target[key]);\n  } else {\n    target[key] = deepMerge(isObject(target[key]) ? target[key] : {}, value);\n  }\n}\n\n/**\n * A function which detects the merge behaviour.\n *\n * @param targetValue - The target object.\n * @param sourceValue - The source objet.\n *\n * @returns The correct behaviour.\n */\nfunction getMergeBehaviour(targetValue: any, sourceValue: any): Behaviour {\n  return behaviourMap.get(sourceValue) || behaviourMap.get(targetValue);\n}\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.push(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.push(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","import { isObject } from '@empathyco/x-utils';\nimport VueI18n from 'vue-i18n';\nimport { deepMerge } from '@empathyco/x-deep-merge';\n\n/**\r\n * I18n settings manager.\r\n *\r\n * @public\r\n */\r\nclass I18n {\r\n    /**\r\n     * Constructs a new {@link I18n} instance with the passed {@link I18nOptions | i18n options}.\r\n     *\r\n     * @param options - The new {@link I18nOptions | i18n options}.\r\n     */\r\n    constructor({ locale, messages, device, fallbackLocale }) {\r\n        this.locale = locale;\r\n        this.device = device;\r\n        this.messages = messages;\r\n        this.fallbackLocale = fallbackLocale;\r\n    }\r\n    /**\r\n     * Creates a new {@link I18n} instance.\r\n     *\r\n     * @param options - The new {@link I18nOptions | i18n options}.\r\n     *\r\n     * @returns The new instance.\r\n     */\r\n    static async create(options) {\r\n        const instance = new I18n(options);\r\n        instance.currentMessages = await instance.getCurrentMessages();\r\n        return instance;\r\n    }\r\n    /**\r\n     * Installs VueI18n plugin.\r\n     *\r\n     * @param vue - The Vue instance.\r\n     */\r\n    install(vue) {\r\n        vue.use(VueI18n);\r\n        this.vueI18n = new VueI18n({\r\n            locale: this.locale,\r\n            messages: this.currentMessages ? { [this.locale]: this.currentMessages } : {},\r\n            silentFallbackWarn: true,\r\n            missing: (locale, key) => {\r\n                var _a;\r\n                return ((_a = this.getMessageWithDotsInKey(key)) !== null && _a !== void 0 ? _a : `[i18n] Key '${key}' is missing for locale: '${locale}'`);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Tries to get a value from the messages object accessing it key by key.\r\n     * When a key fails, takes the remaining key parts and tries to access the message\r\n     * joining them into a single key.\r\n     *\r\n     * @param path - A dot separated key to access the message object.\r\n     * @returns The message corresponding to the provided key, or empty string if it doesn't exist.\r\n     */\r\n    getMessageWithDotsInKey(path) {\r\n        // TO-DO Support function or array messages\r\n        const message = path\r\n            .split('.')\r\n            .reduce((messages, key, index, pathParts) => {\r\n            var _a;\r\n            return isObject(messages)\r\n                ? (_a = messages[key]) !== null && _a !== void 0 ? _a : messages[pathParts.slice(index).join('.')]\r\n                : messages;\r\n        }, this.currentMessages);\r\n        return typeof message === 'string' ? message : null;\r\n    }\r\n    /**\r\n     * Sets the new locale and updates the messages accordingly.\r\n     *\r\n     * @param newLocale - The new locale.\r\n     *\r\n     * @returns The new messages.\r\n     */\r\n    async setLocale(newLocale) {\r\n        if (this.locale !== newLocale) {\r\n            this.locale = newLocale;\r\n            await this.changeMessages();\r\n            this.vueI18n.locale = this.locale;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the new device and updates the messages accordingly.\r\n     *\r\n     * @param newDevice - The new device.\r\n     *\r\n     * @returns The new messages.\r\n     */\r\n    async setDevice(newDevice) {\r\n        if (this.device !== newDevice) {\r\n            this.device = newDevice;\r\n            await this.changeMessages();\r\n        }\r\n    }\r\n    /**\r\n     * Updates the current messages based on the new locale and/or device.\r\n     */\r\n    async changeMessages() {\r\n        this.currentMessages = await this.getCurrentMessages();\r\n        this.vueI18n.setLocaleMessage(this.locale, this.currentMessages);\r\n    }\r\n    /**\r\n     * Retrieves the corresponding messages for the set locale and device.\r\n     *\r\n     * @remarks By default, it merges `base` messages with the specific `device` ones. If there are\r\n     * no messages for the current locale, the fallback locale is used instead.\r\n     *\r\n     * @returns The messages for the current locale and device.\r\n     */\r\n    async getCurrentMessages() {\r\n        const rawMessages = this.locale in this.messages\r\n            ? this.messages[this.locale]\r\n            : this.messages[this.fallbackLocale];\r\n        const messages = areLazyMessages(rawMessages) ? (await rawMessages()).default : rawMessages;\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\r\n        return deepMerge({}, messages.base, messages[this.device]);\r\n    }\r\n}\r\n/**\r\n * Type-guard to check if the passed messages should be lazy-loaded.\r\n *\r\n * @param messages - The messages to check.\r\n *\r\n * @returns True if the messages are lazy or false otherwise.\r\n */\r\nfunction areLazyMessages(messages) {\r\n    return typeof messages === 'function';\r\n}\n\nexport { I18n };\n","import { TaggingRequest } from '@empathyco/x-types';\nimport { track } from './actions/track.action';\nimport { TaggingXStoreModule } from './types';\n\n/**\n * {@link XStoreModule} For the tagging module.\n *\n * @internal\n */\nexport const taggingXStoreModule: TaggingXStoreModule = {\n  state: () => ({\n    config: {\n      sessionTTLMs: 30 * 60 * 1000,\n      queryTaggingDebounceMs: 2000,\n      clickedResultStorageKey: null,\n      clickedResultStorageTTLMs: null\n    },\n    consent: null,\n    queryTaggingInfo: null\n  }),\n  getters: {},\n  mutations: {\n    setConsent(state, consent) {\n      state.consent = consent;\n    },\n    setQueryTaggingInfo(state, queryTaggingInfo: TaggingRequest) {\n      state.queryTaggingInfo = queryTaggingInfo;\n    },\n    setTaggingConfig(state, taggingConfig) {\n      Object.assign(state.config, taggingConfig);\n    }\n  },\n  actions: {\n    track\n  }\n};\n","import { TaggingRequest } from '@empathyco/x-types';\nimport { DefaultSessionService } from '@empathyco/x-utils';\nimport { XPlugin } from '../../../../plugins/x-plugin';\nimport { TaggingXStoreModule } from '../types';\n\n/**\n * Default implementation for the {@link TaggingActions.track}.\n *\n * @param context - The {@link https://vuex.vuejs.org/guide/actions.html | context} of the actions,\n * provided by Vuex.\n * @param taggingInfo - The information of the event to track.\n *\n * @public\n */\nexport const track: TaggingXStoreModule['actions']['track'] = ({ state }, taggingInfo) => {\n  const { consent } = state;\n  const taggingInfos = Array.isArray(taggingInfo) ? taggingInfo : [taggingInfo];\n  const sessionId = getSessionId(consent);\n  // TODO EX-5061 - Remove this validation when the adapter ignores undefined values.\n  const session = sessionId && { session: sessionId };\n\n  taggingInfos.forEach(({ url, params }: TaggingRequest) => {\n    XPlugin.adapter.tagging({\n      url,\n      params: {\n        ...params,\n        ...session\n      }\n    });\n  });\n};\n\n/**\n * Returns the session id if the consent is true.\n *\n * @param consent - User consent to retrieve the session id.\n *\n * @returns The user session id or undefined.\n *\n * @internal\n */\nfunction getSessionId(consent: boolean | null): string | undefined {\n  return consent ? DefaultSessionService.instance.getSessionId() : undefined;\n}\n","import { createStoreEmitters } from '../../../store/utils/store-emitters.utils';\nimport { taggingXStoreModule } from './module';\n\n/**\n * {@link StoreEmitters} For the tagging module.\n *\n * @internal\n */\nexport const taggingEmitters = createStoreEmitters(taggingXStoreModule, {\n  ConsentChanged: state => state.consent!,\n  SearchTaggingReceived: state => state.queryTaggingInfo!,\n  ResultURLTrackingEnabled: {\n    selector: state => state.config.clickedResultStorageKey!,\n    filter: newValue => newValue === 'url'\n  }\n});\n","import { Store } from 'vuex';\nimport { Result } from '@empathyco/x-types';\nimport { BrowserStorageService, StorageService } from '@empathyco/x-storage-service';\nimport { RootXStoreState } from '../../../store/index';\nimport { XPlugin } from '../../../plugins/index';\nimport { PDPAddToCartService } from './types';\n\n/**\n * Default implementation for the {@link PDPAddToCartService}.\n *\n * @public\n */\nexport class DefaultPDPAddToCartService implements PDPAddToCartService {\n  /**\n   * Session id key to use as key in the storage.\n   *\n   * @public\n   */\n  public static readonly RESULT_CLICKED_ID_KEY = 'add-to-cart';\n\n  /**\n   * Global instance of the {@link PDPAddToCartService}.\n   */\n  public static instance: PDPAddToCartService = new DefaultPDPAddToCartService();\n\n  public constructor(\n    protected localStorageService: StorageService = new BrowserStorageService(localStorage, 'x'),\n    protected sessionStorageService: StorageService = new BrowserStorageService(sessionStorage, 'x')\n  ) {}\n\n  protected get store(): Store<RootXStoreState> {\n    return XPlugin.store;\n  }\n\n  protected get clickedResultStorageKey(): string {\n    return this.store.state.x.tagging.config.clickedResultStorageKey as string;\n  }\n\n  protected get clickedResultStorageTTLMs(): number {\n    return this.store.state.x.tagging.config.clickedResultStorageTTLMs as number;\n  }\n\n  /**\n   * Stores in the local storage the information from the Result clicked by the user\n   * in order to be able to track later on.\n   *\n   * @param result - The result to store.\n   *\n   * @public\n   */\n  storeResultClicked(result: Result): void {\n    const key = result[this.clickedResultStorageKey as keyof Result] as string;\n    const storageId = this.getStorageId(key);\n    if (storageId) {\n      this.localStorageService.setItem(storageId, result, this.clickedResultStorageTTLMs);\n    }\n  }\n\n  /**\n   * Checks if the local storage contains a result information for the given id and moves\n   * the result info from the local storage to the session storage.\n   *\n   * @param id - The id of the result to move to the session storage.\n   *\n   * @public\n   */\n  moveToSessionStorage(id?: string): void {\n    const storageId = this.getStorageId(id);\n    if (storageId) {\n      const result = this.localStorageService.removeItem(storageId);\n      if (result) {\n        this.sessionStorageService.setItem(storageId, result);\n      }\n    }\n  }\n\n  /**\n   * Checks if the session storage contains a result information for given id or the current url\n   * and tracks the add to cart if exists.\n   *\n   * @param id - The id of the result to track.\n   *\n   * @public\n   */\n  trackAddToCart(id?: string): void {\n    const storageId =\n      this.clickedResultStorageKey === 'url' ? this.getStorageId() : this.getStorageId(id);\n    if (storageId) {\n      const result = this.sessionStorageService.getItem<Result>(storageId);\n      if (result?.tagging?.add2cart) {\n        result.tagging.add2cart.params.location = 'pdp';\n        this.store.dispatch('x/tagging/track', result.tagging.add2cart);\n      }\n    }\n  }\n\n  /**\n   * Calculates the browser storage key for the given id.\n   *\n   * @param id - The id to be used for the storage key.\n   *\n   * @returns The complete key to be used for storage.\n   *\n   * @internal\n   */\n  protected getStorageId(id?: string): string | null {\n    if (this.clickedResultStorageKey === 'url') {\n      let url = id ?? window.location.href;\n      url = url.replace(/\\s|\\+/g, '%20');\n      const pathName = this.getPathName(url);\n      return `${DefaultPDPAddToCartService.RESULT_CLICKED_ID_KEY}-${pathName}`;\n    } else if (id) {\n      return `${DefaultPDPAddToCartService.RESULT_CLICKED_ID_KEY}-${id}`;\n    } else {\n      this.showWarningMessage();\n      return null;\n    }\n  }\n\n  /**\n   * Logs a warning message in case the tracking cannot be done.\n   *\n   * @internal\n   */\n  protected showWarningMessage(): void {\n    if (this.clickedResultStorageKey !== 'url') {\n      //TODO: add here logger\n      //eslint-disable-next-line no-console\n      console.warn('No product id was provided but the storage was not configured to use the url');\n    }\n  }\n\n  /**\n   * Returns the pathname for a given url.\n   *\n   * @param url - The url to get the pathname from.\n   *\n   * @returns The pathname of the url.\n   *\n   * @internal\n   */\n  protected getPathName(url: string): string {\n    let urlObject: URL;\n    try {\n      // Check if the url is relative or absolute path\n      if (/^(\\.\\.\\/|\\.\\/|\\/)/.test(url)) {\n        urlObject = new URL(url, location.origin);\n      } else {\n        urlObject = new URL(url);\n      }\n      return urlObject.pathname;\n    } catch (e) {\n      //TODO: add here logger\n      //eslint-disable-next-line no-console\n      console.warn(`There was a problem with url ${url}`);\n      return url;\n    }\n  }\n}\n","import { Taggable, Tagging, TaggingRequest } from '@empathyco/x-types';\nimport { DefaultSessionService } from '@empathyco/x-utils';\nimport {\n  namespacedWireCommit,\n  namespacedWireDispatch\n} from '../../wiring/namespaced-wires.factory';\nimport { namespacedDebounce } from '../../wiring/namespaced-wires.operators';\nimport { wireService, wireServiceWithoutPayload } from '../../wiring/wires.factory';\nimport { filter, mapWire } from '../../wiring/wires.operators';\nimport { DisplayWireMetadata, Wire } from '../../wiring/wiring.types';\nimport { createWiring } from '../../wiring/wiring.utils';\nimport { createOrigin } from '../../utils/index';\nimport { FeatureLocation } from '../../types/index';\nimport { DefaultPDPAddToCartService } from './service/pdp-add-to-cart.service';\n\n/**\n * `tagging` {@link XModuleName | XModule name}.\n *\n * @internal\n */\nconst moduleName = 'tagging';\n\n/**\n * Debounce function for the module.\n */\nconst moduleDebounce = namespacedDebounce(moduleName);\n\n/**\n * WireCommit for {@link TaggingXModule}.\n *\n * @internal\n */\nconst wireCommit = namespacedWireCommit(moduleName);\n\n/**\n * WireDispatch for {@link TaggingXModule}.\n *\n * @internal\n */\nconst wireDispatch = namespacedWireDispatch(moduleName);\n\n/**\n * Wires without payload factory for {@link DefaultSessionService}.\n */\nconst wireSessionServiceWithoutPayload = wireServiceWithoutPayload(DefaultSessionService.instance);\n\n/**\n * Wires factory for {@link DefaultPDPAddToCartService}.\n */\nconst wirePDPAddToCartService = wireService(DefaultPDPAddToCartService.instance);\n\n/**\n * Stores the given result on the local storage.\n *\n * @public\n */\nconst storeClickedResultWire = wirePDPAddToCartService('storeResultClicked');\n\n/**\n * Moves the result information from the local storage to session storage.\n *\n * @public\n */\nconst moveClickedResultToSessionWire = mapWire(\n  wirePDPAddToCartService('moveToSessionStorage'),\n  (payload: string) => {\n    return payload === 'url' ? undefined : payload;\n  }\n);\n\n/**\n * Triggers the add to cart tracking.\n *\n * @public\n */\nconst trackAddToCartFromSessionStorage = wirePDPAddToCartService('trackAddToCart');\n\n/**\n * Clears the session id.\n *\n * @public\n */\nconst clearSessionWire = filter(\n  wireSessionServiceWithoutPayload('clearSessionId'),\n  ({ eventPayload: consent }) => !consent\n);\n\n/**\n * Sets the tagging state `consent`.\n *\n * @public\n */\nexport const setConsent = wireCommit('setConsent');\n\n/**\n * Sets the tagging config state.\n *\n * @public\n */\nexport const setTaggingConfig = wireCommit('setTaggingConfig');\n\n/**\n * Tracks the tagging of the query.\n *\n * @public\n */\nexport const trackQueryWire = wireDispatch('track');\n\n/**\n * Sets the tagging state of the query tagging info using a debounce which ends if the user\n * accepts a query.\n *\n * @public\n */\nexport const setQueryTaggingInfo = moduleDebounce(\n  wireCommit('setQueryTaggingInfo'),\n  ({ state }) => state.config.queryTaggingDebounceMs,\n  {\n    cancelOn: 'UserClearedQuery',\n    forceOn: [\n      'UserClickedAResult',\n      'UserClickedAPromoted',\n      'UserClickedABanner',\n      'UserClickedARedirection',\n      'UserReachedResultsListEnd'\n    ]\n  }\n);\n\n/**\n * Tracks the tagging of the result.\n *\n * @public\n */\nexport const trackResultClickedWire = createTrackWire('click');\n\n/**\n * Tracks the tagging of the banner.\n *\n * @public\n */\nexport const trackBannerClickedWire = createTrackWire('click');\n\n/**\n * Performs a track of a result added to the cart.\n *\n * @public\n */\nexport const trackAddToCartWire = createTrackWire('add2cart');\n\n/**\n * Performs a track of a display result being clicked.\n *\n * @public\n */\nexport const trackDisplayClickedWire = createTrackDisplayWire('displayClick');\n\n/**\n * Factory helper to create a wire for the track of a taggable element.\n *\n * @param property - Key of the tagging object to track.\n * @returns A new wire for the given property of the taggable element.\n *\n * @public\n */\nexport function createTrackWire(property: keyof Tagging): Wire<Taggable> {\n  return filter(\n    wireDispatch('track', ({ eventPayload: { tagging }, metadata: { location } }) => {\n      const taggingInfo: TaggingRequest = tagging[property];\n      taggingInfo.params.location = location as string;\n      return taggingInfo;\n    }),\n    ({ eventPayload: { tagging }, metadata: { ignoreInModules } }) =>\n      !!tagging?.[property] && !ignoreInModules?.includes(moduleName)\n  );\n}\n\n/**\n * Factory helper to create a wire for the track of the display click.\n *\n * @param property - Key of the tagging object to track.\n * @returns A new wire for the display click of the taggable element.\n *\n * @public\n */\nexport function createTrackDisplayWire(property: keyof Tagging): Wire<Taggable> {\n  return filter(\n    wireDispatch('track', ({ eventPayload: { tagging }, metadata }) => {\n      const taggingInfo: TaggingRequest = tagging[property];\n      const location = metadata.location as FeatureLocation;\n\n      taggingInfo.params.location = location;\n      taggingInfo.params.displayFamily = createOrigin({\n        feature: metadata.feature,\n        location\n      })!;\n      taggingInfo.params.q = (metadata as DisplayWireMetadata).displayOriginalQuery;\n\n      return taggingInfo;\n    }),\n    ({ eventPayload: { tagging } }) => !!tagging?.[property]\n  );\n}\n\n/**\n * Wiring configuration for the {@link TaggingXModule | tagging module}.\n *\n * @internal\n */\nexport const taggingWiring = createWiring({\n  ConsentProvided: {\n    setConsent\n  },\n  ConsentChanged: {\n    clearSessionWire\n  },\n  PDPIsLoaded: {\n    moveClickedResultToSessionWire\n  },\n  ResultURLTrackingEnabled: {\n    moveClickedResultToSessionWire\n  },\n  SearchTaggingChanged: {\n    setQueryTaggingInfo\n  },\n  SearchTaggingReceived: {\n    trackQueryWire\n  },\n  TaggingConfigProvided: {\n    setTaggingConfig\n  },\n  UserClickedAResult: {\n    trackResultClickedWire,\n    storeClickedResultWire\n  },\n  UserClickedResultAddToCart: {\n    trackAddToCartWire,\n    trackResultClickedWire\n  },\n  UserClickedPDPAddToCart: {\n    trackAddToCartFromSessionStorage\n  },\n  UserClickedABanner: {\n    trackBannerClickedWire\n  },\n  UserClickedADisplayResult: {\n    trackDisplayClickedWire\n  }\n});\n","import { XModule } from '../x-modules.types';\nimport { taggingEmitters } from './store/emitters';\nimport { taggingXStoreModule } from './store/module';\nimport { TaggingXStoreModule } from './store/types';\nimport { taggingWiring } from './wiring';\n\n/**\n * Tagging {@link XModule} alias.\n *\n * @public\n */\nexport type TaggingXModule = XModule<TaggingXStoreModule>;\n\n/**\n * Tagging {@link XModule} implementation. This module is auto-registered as soon as you\n * import any component from the `empathize` entry point.\n *\n * @public\n */\nexport const taggingXModule: TaggingXModule = {\n  name: 'tagging',\n  storeModule: taggingXStoreModule,\n  storeEmitters: taggingEmitters,\n  wiring: taggingWiring\n};\n","\n  import Vue from 'vue';\n  import { Component, Inject, Prop } from 'vue-property-decorator';\n  import { XEmit } from '../../../components/decorators/bus.decorators';\n  import { xComponentMixin } from '../../../components/x-component.mixin';\n  import { SnippetConfig } from '../../../x-installer/api/api.types';\n  import { taggingXModule } from '../x-module';\n  import { TaggingConfig } from '../config.types';\n\n  /**\n   * This component enables and manages the sending of information to the\n   * {@link https://docs.empathy.co/develop-empathy-platform/api-reference/tagging-api.html |\n   * Empathy Tagging API}. It allows to enable or disable the session id management through the\n   * `consent` prop.\n   *\n   * @public\n   */\n  @Component({\n    mixins: [xComponentMixin(taggingXModule)]\n  })\n  export default class Tagging extends Vue {\n    /**\n     * The TTL in milliseconds for storing the clicked result info.\n     *\n     * @public\n     */\n    @Prop({ default: 30000 })\n    public clickedResultStorageTTLMs!: number;\n\n    /**\n     * The Object key of the {@link @empathyco/x-types#Result | result} clicked by the user\n     * that will be used as id for the storage. By default, the Result url will be used.\n     *\n     * @public\n     */\n    @Prop({ default: 'url' })\n    public clickedResultStorageKey!: string;\n\n    /**\n     * It injects {@link SnippetConfig} provided by an ancestor as snippetConfig.\n     *\n     * @internal\n     */\n    @Inject('snippetConfig')\n    protected snippetConfig?: SnippetConfig;\n\n    /**\n     * The session TTL in milliseconds.\n     *\n     * @internal\n     */\n    @Prop()\n    public sessionTTLMs: number | undefined;\n\n    /**\n     * The debounce time in milliseconds to track the query.\n     *\n     * @internal\n     */\n    @Prop()\n    public queryTaggingDebounceMs: number | undefined;\n\n    /**\n     * The consent to be emitted.\n     *\n     * @public\n     */\n    @Prop()\n    protected consent?: boolean;\n\n    /**\n     * The active consent, selected from the `consent` prop and the `snippetConfig.consent`\n     * property. False by default.\n     *\n     * @remarks If the consent is undefined in the prop and in the snippetConfig, it will return\n     * false.\n     *\n     * @returns A boolean that represents if the consent is accepted or not.\n     */\n    @XEmit('ConsentProvided')\n    public get activeConsent(): boolean {\n      return this.consent ?? this.snippetConfig?.consent ?? false;\n    }\n\n    @XEmit('TaggingConfigProvided')\n    public get config(): TaggingConfig {\n      return {\n        queryTaggingDebounceMs: this.queryTaggingDebounceMs as number,\n        sessionTTLMs: this.sessionTTLMs as number,\n        clickedResultStorageTTLMs: this.clickedResultStorageTTLMs,\n        clickedResultStorageKey: this.clickedResultStorageKey\n      };\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    render(): void {}\n\n    /**\n     * To emit the event that PDP is loaded  just when the snippet config includes a product id.\n     */\n    created(): void {\n      this.emitEvents();\n    }\n\n    /**\n     * Emits the {@link TaggingXEvents.PDPIsLoaded} XEvent if the snippet config contains\n     * a product id.\n     *\n     * @internal\n     */\n    protected emitEvents(): void {\n      if (this.snippetConfig?.productId) {\n        this.$x.emit('PDPIsLoaded', this.snippetConfig.productId);\n      }\n    }\n  }\n","<script lang=\"ts\">\n  import Vue from 'vue';\n  import { Component, Inject, Prop } from 'vue-property-decorator';\n  import { XEmit } from '../../../components/decorators/bus.decorators';\n  import { xComponentMixin } from '../../../components/x-component.mixin';\n  import { SnippetConfig } from '../../../x-installer/api/api.types';\n  import { taggingXModule } from '../x-module';\n  import { TaggingConfig } from '../config.types';\n\n  /**\n   * This component enables and manages the sending of information to the\n   * {@link https://docs.empathy.co/develop-empathy-platform/api-reference/tagging-api.html |\n   * Empathy Tagging API}. It allows to enable or disable the session id management through the\n   * `consent` prop.\n   *\n   * @public\n   */\n  @Component({\n    mixins: [xComponentMixin(taggingXModule)]\n  })\n  export default class Tagging extends Vue {\n    /**\n     * The TTL in milliseconds for storing the clicked result info.\n     *\n     * @public\n     */\n    @Prop({ default: 30000 })\n    public clickedResultStorageTTLMs!: number;\n\n    /**\n     * The Object key of the {@link @empathyco/x-types#Result | result} clicked by the user\n     * that will be used as id for the storage. By default, the Result url will be used.\n     *\n     * @public\n     */\n    @Prop({ default: 'url' })\n    public clickedResultStorageKey!: string;\n\n    /**\n     * It injects {@link SnippetConfig} provided by an ancestor as snippetConfig.\n     *\n     * @internal\n     */\n    @Inject('snippetConfig')\n    protected snippetConfig?: SnippetConfig;\n\n    /**\n     * The session TTL in milliseconds.\n     *\n     * @internal\n     */\n    @Prop()\n    public sessionTTLMs: number | undefined;\n\n    /**\n     * The debounce time in milliseconds to track the query.\n     *\n     * @internal\n     */\n    @Prop()\n    public queryTaggingDebounceMs: number | undefined;\n\n    /**\n     * The consent to be emitted.\n     *\n     * @public\n     */\n    @Prop()\n    protected consent?: boolean;\n\n    /**\n     * The active consent, selected from the `consent` prop and the `snippetConfig.consent`\n     * property. False by default.\n     *\n     * @remarks If the consent is undefined in the prop and in the snippetConfig, it will return\n     * false.\n     *\n     * @returns A boolean that represents if the consent is accepted or not.\n     */\n    @XEmit('ConsentProvided')\n    public get activeConsent(): boolean {\n      return this.consent ?? this.snippetConfig?.consent ?? false;\n    }\n\n    @XEmit('TaggingConfigProvided')\n    public get config(): TaggingConfig {\n      return {\n        queryTaggingDebounceMs: this.queryTaggingDebounceMs as number,\n        sessionTTLMs: this.sessionTTLMs as number,\n        clickedResultStorageTTLMs: this.clickedResultStorageTTLMs,\n        clickedResultStorageKey: this.clickedResultStorageKey\n      };\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    render(): void {}\n\n    /**\n     * To emit the event that PDP is loaded  just when the snippet config includes a product id.\n     */\n    created(): void {\n      this.emitEvents();\n    }\n\n    /**\n     * Emits the {@link TaggingXEvents.PDPIsLoaded} XEvent if the snippet config contains\n     * a product id.\n     *\n     * @internal\n     */\n    protected emitEvents(): void {\n      if (this.snippetConfig?.productId) {\n        this.$x.emit('PDPIsLoaded', this.snippetConfig.productId);\n      }\n    }\n  }\n</script>\n\n<docs lang=\"mdx\">\n## Events\n\nThis component emits the following events:\n\n- [`ConsentProvided`](./../../api/x-components.taggingxevents.consentprovided.md)\n- [`TaggingConfigProvided`](./../../api/x-components.taggingxevents.taggingconfigprovided.md)\n\n## See it in action\n\nThis component manages the tagging of the API to track the different features. This component\ndoesn't render elements to the DOM.\n\n```vue\n<template>\n  <Tagging />\n</template>\n\n<script>\n  import { Tagging } from '@empathyco/x-components/tagging';\n\n  export default {\n    name: 'TaggingDemo',\n    components: {\n      Tagging\n    }\n  };\n</script>\n```\n\n### Play with props\n\nIn this example, the `Tagging` component will emit `ConsentProvided` with payload false by default\nif the consent is not provided, the `TaggingConfigProvided` event will be emitted only if the props\n`queryTaggingDebounceMs`, `sessionDurationMs`, `clickedResultStorageTTLMs` or\n`clickedResultStorageKey`are defined.\n\nEvery time the user clicks a result the information for the clicked product will be stored on the\nbrowser during 30 seconds which is the default value for the prop `clickedResultStorageTTLMs`. To\ndistinguish the storage information for the different results the product url will be used since\n`clickedResultStorageKey` default value is 'url'.\n\n```vue\n<template>\n  <Tagging :consent=\"true\" :queryTaggingDebounceMs=\"300\" :sessionDurationMs=\"30000\" />\n</template>\n\n<script>\n  import { Tagging } from '@empathyco/x-components/tagging';\n\n  export default {\n    name: 'TaggingDemo',\n    components: {\n      Tagging\n    }\n  };\n</script>\n```\n\nIn this example, the clicked result information will be stored on the browser during 60 seconds and\nthe product id will be used as storage key.\n\n```vue\n<template>\n  <Tagging :clickedResultStorageTTLMs=\"60000\" :clickedResultStorageKey=\"'id'\" />\n</template>\n\n<script>\n  import { Tagging } from '@empathyco/x-components/tagging';\n\n  export default {\n    name: 'TaggingDemo',\n    components: {\n      Tagging\n    }\n  };\n</script>\n```\n\n### Play with events\n\nThe `Tagging` will emit the `ConsentProvided` when the component is loaded and the consent is set by\nthe prop or getting the value from the snippet config.\n\nThe `Tagging` will emit the `TaggingConfigProvided` when the component is loaded with the new\n[`TaggingConfig`](./../../api/x-components.taggingconfig.md) using the prop values.\n</docs>\n","/**\n * vue-global-events v1.2.1\n * (c) 2020 Damian Dulisz <damian.dulisz@gmail.com>, Eduardo San Martin Morote <posva13@gmail.com>\n * @license MIT\n */\n\nvar _isIE;\nfunction isIE () {\n  return _isIE == null\n    ? (_isIE = /msie|trident/.test(window.navigator.userAgent.toLowerCase()))\n    : _isIE\n}\n\nvar modifiersRE = /^[~!&]*/;\nvar nonEventNameCharsRE = /\\W+/;\nvar names = {\n  '!': 'capture',\n  '~': 'once',\n  '&': 'passive'\n};\n\nfunction extractEventOptions (eventDescriptor) {\n  var ref = eventDescriptor.match(modifiersRE);\n  var modifiers = ref[0];\n\n  // IE only supports capture option and it has to be a boolean\n  // https://github.com/shentao/vue-global-events/issues/14\n  if (isIE()) {\n    return modifiers.indexOf('!') > -1\n  }\n\n  return modifiers.split('').reduce(function (options, modifier) {\n    options[names[modifier]] = true;\n    return options\n  }, {})\n}\n\nvar index = {\n  name: 'GlobalEvents',\n  props: {\n    target: {\n      type: String,\n      default: 'document'\n    },\n    filter: {\n      type: Function,\n      default: function (e) { return true; }\n    }\n  },\n\n  // track keep-alive active state\n  data: function () { return ({ isActive: true }); },\n  activated: function activated () {\n    this.isActive = true;\n  },\n  deactivated: function deactivated () {\n    this.isActive = false;\n  },\n\n  render: function (h) { return h(); },\n\n  mounted: function mounted () {\n    var this$1 = this;\n\n    this._listeners = Object.create(null);\n    Object.keys(this.$listeners).forEach(function (event) {\n      var listener = this$1.$listeners[event];\n      var handler = function (e) {\n        this$1.isActive && this$1.filter(e, listener, event) && listener(e);\n      };\n      window[this$1.target].addEventListener(\n        event.replace(nonEventNameCharsRE, ''),\n        handler,\n        extractEventOptions(event)\n      );\n      this$1._listeners[event] = handler;\n    });\n  },\n\n  beforeDestroy: function beforeDestroy () {\n    var this$1 = this;\n\n    for (var event in this$1._listeners) {\n      window[this$1.target].removeEventListener(\n        event.replace(nonEventNameCharsRE, ''),\n        this$1._listeners[event],\n        extractEventOptions(event)\n      );\n    }\n  }\n};\n\nexport default index;\n","import { UrlParams } from '../../../types/url-params';\n\n/**\n * The initial state of the Url store module. This is exported and used in other parts of the code\n * to use as default values for {@link UrlState}.\n *\n * @internal\n */\nexport const initialUrlState: Readonly<UrlParams> = {\n  query: '',\n  page: 1,\n  filter: [],\n  sort: '',\n  scroll: '',\n  tag: []\n};\n","import { RelatedTag } from '@empathyco/x-types';\n\n/**\n * Query state type, containing a property to hold the current query of the module.\n *\n * @public\n */\nexport interface QueryState {\n  /** The query of the module. Different modules may have queries that differ in value\n   * or time. */\n  query: string;\n}\n\n/**\n * The {@link QueryState} mutations.\n *\n * @public\n */\nexport interface QueryMutations {\n  /**\n   * Sets the query.\n   *\n   * @param query - The new query.\n   */\n  setQuery(query: string): void;\n}\n\n/**\n * Options to create a getter that combines the query with the selected related tags.\n *\n * @public\n */\nexport interface CreateRelatedTagsQueryGetterOptions<State, Getters> {\n  /**\n   * Retrieves the selected related tags of the module.\n   *\n   * @param state - The state of the module.\n   * @param getters - The getters of the module.\n   * @returns The list of selected related tags.\n   */\n  getRelatedTags: (state: State, getters: Getters) => RelatedTag[];\n}\n\n/**\n * Sets the query of the module.\n *\n * @param state - State of the module.\n * @param query - The new query to set.\n * @public\n */\nexport function setQuery(state: QueryState, query: string): void {\n  state.query = query;\n}\n\n/**\n * Creates a getter that combines the current selected related tags and the query of the module.\n *\n * @param options - Options on how the getter should behave.\n * @returns A getter that combines the selected related tags with the query.\n * @public\n */\nexport function createRelatedTagsQueryGetter<State extends QueryState, Getters>({\n  getRelatedTags\n}: CreateRelatedTagsQueryGetterOptions<State, Getters>): (\n  state: State,\n  getters: Getters\n) => string {\n  return function relatedTagsQuery(state, getters) {\n    const query = state.query.trim();\n    return query ? getRelatedTags(state, getters).reduce(concatRelatedTag, query).trim() : '';\n  };\n}\n\n/**\n * Joins a query and a related tag respecting the tag position.\n *\n * @param partialQuery - The query to concatenate the related tag with.\n * @param relatedTag - The related tag to concatenate.\n * @returns The query and the related tag joined.\n * @internal\n */\nfunction concatRelatedTag(\n  partialQuery: string,\n  { tag, query: relatedTagQuery }: RelatedTag\n): string {\n  return relatedTagQuery.startsWith(tag) ? `${tag} ${partialQuery}` : `${partialQuery} ${tag}`;\n}\n","import { objectFilter } from '@empathyco/x-utils';\nimport { initialUrlState } from '../initial-state';\nimport { UrlParamValue, UrlXStoreModule } from '../types';\n\n/**\n * Default implementation for the {@link UrlGetters.urlParams} getter.\n *\n * @param state - Current {@link https://vuex.vuejs.org/guide/state.html | state} of the url module.\n *\n * @returns The url params.\n *\n * @public\n */\nexport const urlParams: UrlXStoreModule['getters']['urlParams'] = ({\n  initialExtraParams,\n  ...params\n}) =>\n  objectFilter(params, (paramKey, paramValue) => {\n    return paramKey in initialUrlState\n      ? isNotDefaultValue(paramKey, paramValue, initialUrlState)\n      : isNotEmptyParam(paramValue) && isNotDefaultValue(paramKey, paramValue, initialExtraParams);\n  });\n\n/**\n * Checks if a parameter is not empty to avoid adding it to the URL.\n *\n * @param value - The value of the key parameter.\n *\n * @returns True if is not empty, False otherwise.\n */\nfunction isNotEmptyParam(value: UrlParamValue | unknown): boolean {\n  return Array.isArray(value) ? value.length > 0 : value != null && value !== '';\n}\n\n/**\n * Checks if a parameter is not the default state value to avoid adding it to the URL.\n *\n * @param key - The key parameter.\n * @param value - The value of the key parameter.\n * @param defaultValues - The default values to compare.\n *\n * @returns True if is not the default state value, False otherwise.\n */\nfunction isNotDefaultValue<Key extends string | number, Value extends UrlParamValue | unknown>(\n  key: Key,\n  value: Value,\n  defaultValues: Record<Key, Value>\n): boolean {\n  return Array.isArray(value) ? value.length > 0 : defaultValues[key] !== value;\n}\n","import { setQuery } from '../../../store/utils/query.utils';\nimport { urlParams } from './getters/url-params.getter';\nimport { initialUrlState } from './initial-state';\nimport { setParams } from './mutations/set-params.mutation';\nimport { UrlXStoreModule } from './types';\n\n/**\n * {@link XStoreModule} For the URL module.\n *\n * @internal\n */\nexport const urlXStoreModule: UrlXStoreModule = {\n  state: () => ({\n    ...initialUrlState,\n    initialExtraParams: {}\n  }),\n  getters: {\n    urlParams\n  },\n  mutations: {\n    setParams,\n    setQuery,\n    setRelatedTags(state, relatedTags) {\n      state.tag = relatedTags.map(relatedTag => relatedTag.tag);\n    },\n    setFilters(state, newFilters) {\n      state.filter = newFilters.map(filter => filter.id as string);\n    },\n    setPage(state, page) {\n      state.page = page;\n    },\n    setSort(state, sort) {\n      state.sort = sort;\n    },\n    setInitialExtraParams(state, extraParams) {\n      state.initialExtraParams = extraParams;\n    },\n    setScroll(state, scroll) {\n      state.scroll = scroll;\n    }\n  },\n  actions: {}\n};\n","import { forEach } from '@empathyco/x-utils';\nimport Vue from 'vue';\nimport { UrlXStoreModule } from '../types';\n\n/**\n * Default implementation for the {@link UrlMutations.setParams} mutation.\n *\n * @param state - Current {@link https://vuex.vuejs.org/guide/state.html | state} of the history\n * queries module.\n * @param params - The mutation payload with the extra params to set in the state.\n * @remarks The change is done using `Vue.set` because we are adding new fields to the state. So\n * this is necessary to make them reactive.\n * @public\n */\nexport const setParams: UrlXStoreModule['mutations']['setParams'] = (state, params) => {\n  forEach(params, (key, value) => {\n    Vue.set(state, key, value);\n  });\n};\n","import { createStoreEmitters } from '../../../store';\nimport { UrlParams } from '../../../types/url-params';\nimport { urlXStoreModule } from './module';\nimport { UrlParamKey } from './types';\n\n/**\n * The params from {@link UrlParams} that provokes a replace instead of a push in the browser URL\n * state.\n *\n * @internal\n */\nexport const replaceableParams: UrlParamKey[] = ['scroll', 'page'];\n\n/**\n * Compares new and old {@link UrlParams} to know if not replaceable params have changed.\n *\n * @param newParams - The new {@link UrlParams} to compare.\n * @param oldParams - The old {@link UrlParams} to compare.\n *\n * @returns True if is pushable change, false otherwise.\n */\nfunction shouldPushUrl(\n  newParams: Partial<UrlParams> = {},\n  oldParams: Partial<UrlParams> = {}\n): boolean {\n  const keys = Object.keys({ ...oldParams, ...newParams });\n  return keys.some(key => !replaceableParams.includes(key) && oldParams[key] !== newParams[key]);\n}\n\n/**\n * Compares new and old {@link UrlParams} to know if replaceable params have changed.\n *\n * @param newParams - The new {@link UrlParams} to compare.\n * @param oldParams - The old {@link UrlParams} to compare.\n *\n * @returns True if is pushable change, false otherwise.\n */\nfunction shouldReplaceUrl(\n  newParams: Partial<UrlParams> = {},\n  oldParams: Partial<UrlParams> = {}\n): boolean {\n  const keys = Object.keys({ ...oldParams, ...newParams });\n  return (\n    keys.some(key => replaceableParams.includes(key) && oldParams[key] !== newParams[key]) &&\n    !shouldPushUrl(newParams, oldParams)\n  );\n}\n\n/**\n * {@link StoreEmitters} For the URL module.\n *\n * @internal\n */\nexport const urlEmitters = createStoreEmitters(urlXStoreModule, {\n  PushableUrlStateUpdated: {\n    selector: (_, getters) => getters.urlParams,\n    filter: shouldPushUrl,\n    metadata: { replaceable: false }\n  },\n  ReplaceableUrlStateUpdated: {\n    selector: (_, getters) => getters.urlParams,\n    filter: shouldReplaceUrl,\n    metadata: { replaceable: false }\n  }\n});\n","import { namespacedWireCommit } from '../../wiring/namespaced-wires.factory';\nimport { createWiring } from '../../wiring/wiring.utils';\n\n/**\n * WireCommit for {@link UrlXModule}.\n *\n * @internal\n */\nconst wireCommit = namespacedWireCommit('url');\n\n/**\n * Sets the {@link RelatedTag | related tags }.\n *\n * @public\n */\nexport const setUrlRelatedTags = wireCommit('setRelatedTags');\n\n/**\n * Sets the query of the url module.\n *\n * @public\n */\nexport const setUrlQuery = wireCommit('setQuery');\n\n/**\n * Sets the page of the url module.\n *\n * @public\n */\nexport const setUrlPage = wireCommit('setPage');\n\n/**\n * Sets the sort of the url module.\n *\n * @public\n */\nexport const setUrlSort = wireCommit('setSort');\n\n/**\n * Sets the extra params of the url module.\n *\n * @public\n */\nexport const setParams = wireCommit('setParams');\n\n/**\n * Sets the scroll of the url module.\n *\n * @public\n */\nexport const setUrlScroll = wireCommit('setScroll');\n\n/**\n * Sets the initial provided extra params.\n *\n * @public\n */\nexport const setInitialExtraParams = wireCommit('setInitialExtraParams');\n\n/**\n * Sets the filters of the url module.\n *\n * @public\n */\nexport const setUrlFilters = wireCommit('setFilters');\n\n/**\n * Wiring configuration for the {@link UrlXModule | url module}.\n *\n * @internal\n */\nexport const urlWiring = createWiring({\n  ParamsLoadedFromUrl: {\n    setParams\n  },\n  UserAcceptedAQuery: {\n    setUrlQuery\n  },\n  UserClearedQuery: {\n    setUrlQuery\n  },\n  SelectedRelatedTagsChanged: {\n    setUrlRelatedTags\n  },\n  SelectedFiltersForRequestChanged: {\n    setUrlFilters\n  },\n  PageChanged: {\n    setUrlPage\n  },\n  SortChanged: {\n    setUrlSort\n  },\n  ExtraParamsChanged: {\n    setParams\n  },\n  ExtraParamsInitialized: {\n    setInitialExtraParams\n  },\n  UserScrolledToElement: {\n    setUrlScroll\n  }\n});\n","import { XModule } from '../x-modules.types';\nimport { urlEmitters, urlXStoreModule, UrlXStoreModule } from './store';\nimport { urlWiring } from './wiring';\n\n/**\n * URL {@link XModule} alias.\n *\n * @public\n */\nexport type UrlXModule = XModule<UrlXStoreModule>;\n\n/**\n * URL {@link XModule} implementation. This module is auto-registered as soon as you\n * import any component from the `url` entry point.\n *\n * @public\n */\nexport const urlXModule: UrlXModule = {\n  name: 'url',\n  storeModule: urlXStoreModule,\n  storeEmitters: urlEmitters,\n  wiring: urlWiring\n};\n","\n\n\n\n\n  import { Dictionary, objectFilter } from '@empathyco/x-utils';\n  import Vue from 'vue';\n  import GlobalEvents from 'vue-global-events';\n  import { Component, Inject } from 'vue-property-decorator';\n  import { State } from '../../../components';\n  import { XOn } from '../../../components/decorators/bus.decorators';\n  import { xComponentMixin } from '../../../components/x-component.mixin';\n  import { FeatureLocation } from '../../../types/origin';\n  import { UrlParams } from '../../../types/url-params';\n  import { isArrayEmpty } from '../../../utils/array';\n  import { WireMetadata } from '../../../wiring/wiring.types';\n  import { SnippetConfig } from '../../../x-installer/api/api.types';\n  import { initialUrlState } from '../store/initial-state';\n  import { UrlParamValue } from '../store/types';\n  import { urlXModule } from '../x-module';\n\n  interface ParsedUrlParams {\n    all: UrlParams;\n    extra: Dictionary<unknown>;\n  }\n\n  /**\n   * This component manages the browser URL parameters to preserve them through reloads and browser\n   * history navigation. It allow to configure the default url parameter names using its attributes.\n   * This component doesn't render elements to the DOM.\n   *\n   * @public\n   */\n  @Component({\n    components: {\n      GlobalEvents\n    },\n    mixins: [xComponentMixin(urlXModule)]\n  })\n  export default class UrlHandler extends Vue {\n    /**\n     * The {@link SnippetConfig} provided by an ancestor.\n     *\n     * @internal\n     */\n    @Inject({ default: undefined })\n    protected snippetConfig?: SnippetConfig;\n\n    /**\n     * Flag to know if the params were already loaded from the URL.\n     *\n     * @internal\n     */\n    protected urlLoaded = false;\n\n    /**\n     * The page URL. It is used to compare against the current URL to check navigation state.\n     *\n     * @internal\n     */\n    protected url?: URL;\n\n    /**\n     * Flag to know if the page has been persisted by the browser's back-forward cache.\n     *\n     * @internal\n     */\n    protected isPagePersisted = false;\n\n    /**\n     * Computed to know which params we must get from URL. It gets the params names from the initial\n     * state, to get all default params names, and also from the `$attrs` to get the extra params\n     * names to take into account.\n     *\n     * @returns An array with the name of the params.\n     *\n     * @internal\n     */\n    protected get managedParamsNames(): string[] {\n      return Object.keys({ ...initialUrlState, ...this.$attrs });\n    }\n\n    @State('url', 'initialExtraParams')\n    public initialExtraParams!: Dictionary<unknown>;\n\n    /**\n     * Returns the mapping of the param keys used in the URL is configured through $attrs. This way\n     * we can support any param and extra param, no matters its name.\n     *\n     * @param paramName - The param name to get the Url key.\n     * @returns The key used in the URL for the `paramName` passed.\n     *\n     * @internal\n     */\n    protected getUrlKey(paramName: string): string {\n      return this.$attrs[paramName] ?? paramName;\n    }\n\n    /**\n     * To emit the Url events just when the URL is load, and before the components mounted events\n     * and state changes, we do it in the created of this component.\n     */\n    created(): void {\n      this.emitEvents();\n    }\n\n    /**\n     * Updates the browser URL with the new {@link UrlParams} using the history `pushState` method.\n     *\n     * @param newUrlParams - The new params to update browser URL.\n     */\n    @XOn('PushableUrlStateUpdated')\n    updateUrlWithPush(newUrlParams: UrlParams): void {\n      this.updateUrl(newUrlParams, window.history.pushState.bind(window.history));\n    }\n\n    /**\n     * Updates the browser URL with the new {@link UrlParams} using the history `replaceState`\n     * method.\n     *\n     * @param newUrlParams - The new params to update browser URL.\n     */\n    @XOn('ReplaceableUrlStateUpdated')\n    updateUrlWithReplace(newUrlParams: UrlParams): void {\n      this.updateUrl(newUrlParams, window.history.replaceState.bind(window.history));\n    }\n\n    /**\n     * Handler of the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/pageshow_event | pageshow }\n     * event.\n     *\n     * @remarks The pageshow event is listened to check if the browser has performed a navigation\n     * using the back-forward cache. This information is available in the\n     * PageTransitionEvent.persisted property.\n     *\n     * @param event - The page transition event.\n     * @internal\n     */\n    protected onPageShow(event: PageTransitionEvent): void {\n      this.isPagePersisted = event.persisted;\n      if (event.persisted) {\n        // The internal url is reset due to the back-forward cache storing the previous value which\n        // is no longer valid.\n        this.url = undefined;\n      }\n    }\n\n    /**\n     * Emits the {@link UrlXEvents.ParamsLoadedFromUrl} XEvent,\n     * the {@link UrlXEvents.ExtraParamsLoadedFromUrl} XEvent and, if there is query, also emits\n     * the {@link XEventsTypes.UserOpenXProgrammatically}.\n     *\n     * @internal\n     */\n    protected emitEvents(): void {\n      const { all, extra } = this.parseUrlParams();\n      const metadata = this.createWireMetadata();\n      this.$x.emit('ParamsLoadedFromUrl', all, metadata);\n      this.$x.emit('ExtraParamsLoadedFromUrl', extra, metadata);\n      // TODO: Move this logic from here.\n      if (all.query) {\n        this.$x.emit('UserOpenXProgrammatically', undefined, metadata);\n      }\n      this.urlLoaded = true;\n    }\n\n    /**\n     * Creates the wire metadata to include in every emitted {@link XEvent | XEvents}.\n     *\n     * @returns The {@link WireMetadata | metadata}.\n     * @internal\n     */\n    protected createWireMetadata(): Pick<WireMetadata, 'feature' | 'location'> {\n      return {\n        feature: 'url',\n        location: this.detectLocation()\n      };\n    }\n\n    /**\n     * Detects the {@link FeatureLocation | location} used to build the\n     * {@link QueryOriginInit | events metadata origin}.\n     *\n     * @returns The {@link FeatureLocation | location}.\n     * @internal\n     */\n    protected detectLocation(): FeatureLocation {\n      const currentUrl = new URL(window.location.href);\n      const previousUrl = this.url;\n      this.url = currentUrl;\n\n      const isInternalNavigation =\n        previousUrl?.search !== currentUrl.search && previousUrl?.pathname === currentUrl.pathname;\n      if (isInternalNavigation) {\n        return 'url_history';\n      }\n\n      if (this.isNavigatingFromPdp()) {\n        return 'url_history_pdp';\n      }\n\n      return 'external';\n    }\n\n    /**\n     * Check if the navigation is from a product page.\n     *\n     * @remarks Due to Safari 14 not supporting the new and standard PerformanceNavigationTiming\n     * API, we are falling back to the deprecated one, PerformanceNavigation. We also fallback to\n     * this API whenever we get a navigationType equal to reload, because Safari has a bug that the\n     * navigationType is permanently set to reload after you have reload the page and it never\n     * resets. As some browsers have a back-forward cache implemented, we also take into account if\n     * the page is persisted.\n     *\n     * @returns True if the navigation is from a product page, false otherwise.\n     * @internal\n     */\n    protected isNavigatingFromPdp(): boolean {\n      const isPagePersisted = this.isPagePersisted;\n      const navigationEntries = window.performance.getEntriesByType('navigation');\n      const navigationType = (navigationEntries[0] as PerformanceNavigationTiming)?.type;\n      const useFallbackStrategy =\n        window.performance.navigation &&\n        (isArrayEmpty(navigationEntries) || navigationType === 'reload');\n\n      // Reset internal isPagePersisted property value\n      this.isPagePersisted = false;\n\n      if (useFallbackStrategy) {\n        const {\n          type: fallbackNavigationType,\n          TYPE_BACK_FORWARD,\n          TYPE_NAVIGATE\n        } = window.performance.navigation;\n        const isNavigatingInSpa =\n          !!this.snippetConfig?.isSpa && fallbackNavigationType === TYPE_NAVIGATE;\n        return fallbackNavigationType === TYPE_BACK_FORWARD || isNavigatingInSpa || isPagePersisted;\n      } else {\n        const isNavigatingInSpa = !!this.snippetConfig?.isSpa && navigationType === 'navigate';\n        return navigationType === 'back_forward' || isNavigatingInSpa || isPagePersisted;\n      }\n    }\n\n    /**\n     * Gets the {@link UrlParams} from the URL, including only the params defined by `paramsNames`.\n     *\n     * @returns ParsedUrlParams obtained from URL.\n     * @internal\n     */\n    protected parseUrlParams(): ParsedUrlParams {\n      const urlSearchParams = new URL(window.location.href).searchParams;\n      return this.managedParamsNames.reduce<ParsedUrlParams>(\n        (params, name) => {\n          const urlKey = this.getUrlKey(name);\n          if (urlSearchParams.has(urlKey)) {\n            if (name in initialUrlState) {\n              const urlValue = urlSearchParams.getAll(urlKey);\n              params.all[name] = this.parseUrlParam(name, urlValue);\n            } else {\n              params.all[name] = params.extra[name] = urlSearchParams.get(urlKey);\n            }\n          }\n          return params;\n        },\n        { all: { ...initialUrlState }, extra: { ...this.initialExtraParams } }\n      );\n    }\n\n    /**\n     * Updates the browser URL with the passed `newUrlParams` and using the browser history method\n     * passed as `historyMethod`. It only updates the browser history if the new URL is different\n     * from the current.\n     *\n     * @param newUrlParams - The new params to add to the browser URL.\n     * @param historyMethod - The browser history method used to add the new URL.\n     *\n     * @internal\n     */\n    protected updateUrl(\n      newUrlParams: UrlParams,\n      historyMethod: History['pushState'] | History['replaceState']\n    ): void {\n      if (this.urlLoaded) {\n        const url = new URL(window.location.href);\n        this.deleteUrlParameters(url);\n        this.setUrlParameters(url, newUrlParams);\n\n        url.href = url.href.replace(/\\+/g, '%20');\n\n        if (url.href !== window.location.href) {\n          historyMethod({ ...window.history.state }, document.title, url.href);\n        }\n        this.url = url;\n      }\n    }\n\n    /**\n     * Deletes all the parameters in the passed URL.\n     *\n     * @param url - The URL to remove parameters from.\n     * @internal\n     */\n    protected deleteUrlParameters(url: URL): void {\n      this.managedParamsNames.forEach(paramName =>\n        url.searchParams.delete(this.getUrlKey(paramName))\n      );\n    }\n\n    /**\n     * Set all the provided parameters to the url with the mapped key.\n     *\n     * @param url - The current URL.\n     * @param urlParams - The list of parameters to add.\n     * @remarks The params are filtered because there maybe received extra params which will not be\n     * managed by URL. This is defined by the `managedParamsNames` computed. Also, the parameters\n     * are sorted Alphabetically to produce always the same URL with the same parameters.This is\n     * important for SEO purposes.\n     *\n     * @internal\n     */\n    protected setUrlParameters(url: URL, urlParams: UrlParams): void {\n      // Only when there is a query the rest of the parameters are valid.\n      if (!urlParams.query) {\n        return;\n      }\n      const filteredParams = objectFilter(urlParams, paramName =>\n        this.managedParamsNames.includes(paramName as string)\n      );\n      const sortedParameters = this.sortParams(filteredParams);\n      sortedParameters.forEach(([paramName, paramValue]) => {\n        const urlParamKey = this.getUrlKey(paramName);\n        if (Array.isArray(paramValue)) {\n          paramValue.forEach(value => {\n            url.searchParams.append(urlParamKey, String(value));\n          });\n        } else {\n          url.searchParams.set(urlParamKey, String(paramValue));\n        }\n      });\n    }\n\n    /**\n     * Sorts the params in a tuple array [key,value] to generate always the same URL with the params\n     * in the same order.\n     *\n     * @param urlParams - The {@link UrlParams} to sort.\n     * @returns An array of tuples with the key-value of each paramter, sorted by key.\n     * @internal\n     */\n    protected sortParams(urlParams: UrlParams): Array<[string, unknown]> {\n      return Object.entries(urlParams).sort(([param1], [param2]) => {\n        return param1 < param2 ? -1 : 1;\n      });\n    }\n\n    /**\n     * Returns the URL param value parsed depending on its type in the initial store state. As we\n     * can not know what type can have an extra param, all extra params are parsed as strings. We\n     * know if it is an extra param because it is not in the initial state.\n     *\n     * @param name - The name of the param in {@link UrlParams}.\n     * @param value - The `URLSearchParams` value as an arry of strings.\n     * @returns The parsed value.\n     *\n     * @internal\n     */\n    protected parseUrlParam(name: string, value: string[]): UrlParamValue {\n      switch (typeof initialUrlState[name]) {\n        case 'number':\n          return Number(value[0]);\n        case 'boolean':\n          return value[0].toLowerCase() === 'true';\n        case 'string':\n          return value[0];\n        default:\n          // array\n          return value;\n      }\n    }\n  }\n","<template>\n  <GlobalEvents @pageshow=\"onPageShow\" @popstate=\"emitEvents\" target=\"window\" />\n</template>\n\n<script lang=\"ts\">\n  import { Dictionary, objectFilter } from '@empathyco/x-utils';\n  import Vue from 'vue';\n  import GlobalEvents from 'vue-global-events';\n  import { Component, Inject } from 'vue-property-decorator';\n  import { State } from '../../../components';\n  import { XOn } from '../../../components/decorators/bus.decorators';\n  import { xComponentMixin } from '../../../components/x-component.mixin';\n  import { FeatureLocation } from '../../../types/origin';\n  import { UrlParams } from '../../../types/url-params';\n  import { isArrayEmpty } from '../../../utils/array';\n  import { WireMetadata } from '../../../wiring/wiring.types';\n  import { SnippetConfig } from '../../../x-installer/api/api.types';\n  import { initialUrlState } from '../store/initial-state';\n  import { UrlParamValue } from '../store/types';\n  import { urlXModule } from '../x-module';\n\n  interface ParsedUrlParams {\n    all: UrlParams;\n    extra: Dictionary<unknown>;\n  }\n\n  /**\n   * This component manages the browser URL parameters to preserve them through reloads and browser\n   * history navigation. It allow to configure the default url parameter names using its attributes.\n   * This component doesn't render elements to the DOM.\n   *\n   * @public\n   */\n  @Component({\n    components: {\n      GlobalEvents\n    },\n    mixins: [xComponentMixin(urlXModule)]\n  })\n  export default class UrlHandler extends Vue {\n    /**\n     * The {@link SnippetConfig} provided by an ancestor.\n     *\n     * @internal\n     */\n    @Inject({ default: undefined })\n    protected snippetConfig?: SnippetConfig;\n\n    /**\n     * Flag to know if the params were already loaded from the URL.\n     *\n     * @internal\n     */\n    protected urlLoaded = false;\n\n    /**\n     * The page URL. It is used to compare against the current URL to check navigation state.\n     *\n     * @internal\n     */\n    protected url?: URL;\n\n    /**\n     * Flag to know if the page has been persisted by the browser's back-forward cache.\n     *\n     * @internal\n     */\n    protected isPagePersisted = false;\n\n    /**\n     * Computed to know which params we must get from URL. It gets the params names from the initial\n     * state, to get all default params names, and also from the `$attrs` to get the extra params\n     * names to take into account.\n     *\n     * @returns An array with the name of the params.\n     *\n     * @internal\n     */\n    protected get managedParamsNames(): string[] {\n      return Object.keys({ ...initialUrlState, ...this.$attrs });\n    }\n\n    @State('url', 'initialExtraParams')\n    public initialExtraParams!: Dictionary<unknown>;\n\n    /**\n     * Returns the mapping of the param keys used in the URL is configured through $attrs. This way\n     * we can support any param and extra param, no matters its name.\n     *\n     * @param paramName - The param name to get the Url key.\n     * @returns The key used in the URL for the `paramName` passed.\n     *\n     * @internal\n     */\n    protected getUrlKey(paramName: string): string {\n      return this.$attrs[paramName] ?? paramName;\n    }\n\n    /**\n     * To emit the Url events just when the URL is load, and before the components mounted events\n     * and state changes, we do it in the created of this component.\n     */\n    created(): void {\n      this.emitEvents();\n    }\n\n    /**\n     * Updates the browser URL with the new {@link UrlParams} using the history `pushState` method.\n     *\n     * @param newUrlParams - The new params to update browser URL.\n     */\n    @XOn('PushableUrlStateUpdated')\n    updateUrlWithPush(newUrlParams: UrlParams): void {\n      this.updateUrl(newUrlParams, window.history.pushState.bind(window.history));\n    }\n\n    /**\n     * Updates the browser URL with the new {@link UrlParams} using the history `replaceState`\n     * method.\n     *\n     * @param newUrlParams - The new params to update browser URL.\n     */\n    @XOn('ReplaceableUrlStateUpdated')\n    updateUrlWithReplace(newUrlParams: UrlParams): void {\n      this.updateUrl(newUrlParams, window.history.replaceState.bind(window.history));\n    }\n\n    /**\n     * Handler of the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/pageshow_event | pageshow }\n     * event.\n     *\n     * @remarks The pageshow event is listened to check if the browser has performed a navigation\n     * using the back-forward cache. This information is available in the\n     * PageTransitionEvent.persisted property.\n     *\n     * @param event - The page transition event.\n     * @internal\n     */\n    protected onPageShow(event: PageTransitionEvent): void {\n      this.isPagePersisted = event.persisted;\n      if (event.persisted) {\n        // The internal url is reset due to the back-forward cache storing the previous value which\n        // is no longer valid.\n        this.url = undefined;\n      }\n    }\n\n    /**\n     * Emits the {@link UrlXEvents.ParamsLoadedFromUrl} XEvent,\n     * the {@link UrlXEvents.ExtraParamsLoadedFromUrl} XEvent and, if there is query, also emits\n     * the {@link XEventsTypes.UserOpenXProgrammatically}.\n     *\n     * @internal\n     */\n    protected emitEvents(): void {\n      const { all, extra } = this.parseUrlParams();\n      const metadata = this.createWireMetadata();\n      this.$x.emit('ParamsLoadedFromUrl', all, metadata);\n      this.$x.emit('ExtraParamsLoadedFromUrl', extra, metadata);\n      // TODO: Move this logic from here.\n      if (all.query) {\n        this.$x.emit('UserOpenXProgrammatically', undefined, metadata);\n      }\n      this.urlLoaded = true;\n    }\n\n    /**\n     * Creates the wire metadata to include in every emitted {@link XEvent | XEvents}.\n     *\n     * @returns The {@link WireMetadata | metadata}.\n     * @internal\n     */\n    protected createWireMetadata(): Pick<WireMetadata, 'feature' | 'location'> {\n      return {\n        feature: 'url',\n        location: this.detectLocation()\n      };\n    }\n\n    /**\n     * Detects the {@link FeatureLocation | location} used to build the\n     * {@link QueryOriginInit | events metadata origin}.\n     *\n     * @returns The {@link FeatureLocation | location}.\n     * @internal\n     */\n    protected detectLocation(): FeatureLocation {\n      const currentUrl = new URL(window.location.href);\n      const previousUrl = this.url;\n      this.url = currentUrl;\n\n      const isInternalNavigation =\n        previousUrl?.search !== currentUrl.search && previousUrl?.pathname === currentUrl.pathname;\n      if (isInternalNavigation) {\n        return 'url_history';\n      }\n\n      if (this.isNavigatingFromPdp()) {\n        return 'url_history_pdp';\n      }\n\n      return 'external';\n    }\n\n    /**\n     * Check if the navigation is from a product page.\n     *\n     * @remarks Due to Safari 14 not supporting the new and standard PerformanceNavigationTiming\n     * API, we are falling back to the deprecated one, PerformanceNavigation. We also fallback to\n     * this API whenever we get a navigationType equal to reload, because Safari has a bug that the\n     * navigationType is permanently set to reload after you have reload the page and it never\n     * resets. As some browsers have a back-forward cache implemented, we also take into account if\n     * the page is persisted.\n     *\n     * @returns True if the navigation is from a product page, false otherwise.\n     * @internal\n     */\n    protected isNavigatingFromPdp(): boolean {\n      const isPagePersisted = this.isPagePersisted;\n      const navigationEntries = window.performance.getEntriesByType('navigation');\n      const navigationType = (navigationEntries[0] as PerformanceNavigationTiming)?.type;\n      const useFallbackStrategy =\n        window.performance.navigation &&\n        (isArrayEmpty(navigationEntries) || navigationType === 'reload');\n\n      // Reset internal isPagePersisted property value\n      this.isPagePersisted = false;\n\n      if (useFallbackStrategy) {\n        const {\n          type: fallbackNavigationType,\n          TYPE_BACK_FORWARD,\n          TYPE_NAVIGATE\n        } = window.performance.navigation;\n        const isNavigatingInSpa =\n          !!this.snippetConfig?.isSpa && fallbackNavigationType === TYPE_NAVIGATE;\n        return fallbackNavigationType === TYPE_BACK_FORWARD || isNavigatingInSpa || isPagePersisted;\n      } else {\n        const isNavigatingInSpa = !!this.snippetConfig?.isSpa && navigationType === 'navigate';\n        return navigationType === 'back_forward' || isNavigatingInSpa || isPagePersisted;\n      }\n    }\n\n    /**\n     * Gets the {@link UrlParams} from the URL, including only the params defined by `paramsNames`.\n     *\n     * @returns ParsedUrlParams obtained from URL.\n     * @internal\n     */\n    protected parseUrlParams(): ParsedUrlParams {\n      const urlSearchParams = new URL(window.location.href).searchParams;\n      return this.managedParamsNames.reduce<ParsedUrlParams>(\n        (params, name) => {\n          const urlKey = this.getUrlKey(name);\n          if (urlSearchParams.has(urlKey)) {\n            if (name in initialUrlState) {\n              const urlValue = urlSearchParams.getAll(urlKey);\n              params.all[name] = this.parseUrlParam(name, urlValue);\n            } else {\n              params.all[name] = params.extra[name] = urlSearchParams.get(urlKey);\n            }\n          }\n          return params;\n        },\n        { all: { ...initialUrlState }, extra: { ...this.initialExtraParams } }\n      );\n    }\n\n    /**\n     * Updates the browser URL with the passed `newUrlParams` and using the browser history method\n     * passed as `historyMethod`. It only updates the browser history if the new URL is different\n     * from the current.\n     *\n     * @param newUrlParams - The new params to add to the browser URL.\n     * @param historyMethod - The browser history method used to add the new URL.\n     *\n     * @internal\n     */\n    protected updateUrl(\n      newUrlParams: UrlParams,\n      historyMethod: History['pushState'] | History['replaceState']\n    ): void {\n      if (this.urlLoaded) {\n        const url = new URL(window.location.href);\n        this.deleteUrlParameters(url);\n        this.setUrlParameters(url, newUrlParams);\n\n        url.href = url.href.replace(/\\+/g, '%20');\n\n        if (url.href !== window.location.href) {\n          historyMethod({ ...window.history.state }, document.title, url.href);\n        }\n        this.url = url;\n      }\n    }\n\n    /**\n     * Deletes all the parameters in the passed URL.\n     *\n     * @param url - The URL to remove parameters from.\n     * @internal\n     */\n    protected deleteUrlParameters(url: URL): void {\n      this.managedParamsNames.forEach(paramName =>\n        url.searchParams.delete(this.getUrlKey(paramName))\n      );\n    }\n\n    /**\n     * Set all the provided parameters to the url with the mapped key.\n     *\n     * @param url - The current URL.\n     * @param urlParams - The list of parameters to add.\n     * @remarks The params are filtered because there maybe received extra params which will not be\n     * managed by URL. This is defined by the `managedParamsNames` computed. Also, the parameters\n     * are sorted Alphabetically to produce always the same URL with the same parameters.This is\n     * important for SEO purposes.\n     *\n     * @internal\n     */\n    protected setUrlParameters(url: URL, urlParams: UrlParams): void {\n      // Only when there is a query the rest of the parameters are valid.\n      if (!urlParams.query) {\n        return;\n      }\n      const filteredParams = objectFilter(urlParams, paramName =>\n        this.managedParamsNames.includes(paramName as string)\n      );\n      const sortedParameters = this.sortParams(filteredParams);\n      sortedParameters.forEach(([paramName, paramValue]) => {\n        const urlParamKey = this.getUrlKey(paramName);\n        if (Array.isArray(paramValue)) {\n          paramValue.forEach(value => {\n            url.searchParams.append(urlParamKey, String(value));\n          });\n        } else {\n          url.searchParams.set(urlParamKey, String(paramValue));\n        }\n      });\n    }\n\n    /**\n     * Sorts the params in a tuple array [key,value] to generate always the same URL with the params\n     * in the same order.\n     *\n     * @param urlParams - The {@link UrlParams} to sort.\n     * @returns An array of tuples with the key-value of each paramter, sorted by key.\n     * @internal\n     */\n    protected sortParams(urlParams: UrlParams): Array<[string, unknown]> {\n      return Object.entries(urlParams).sort(([param1], [param2]) => {\n        return param1 < param2 ? -1 : 1;\n      });\n    }\n\n    /**\n     * Returns the URL param value parsed depending on its type in the initial store state. As we\n     * can not know what type can have an extra param, all extra params are parsed as strings. We\n     * know if it is an extra param because it is not in the initial state.\n     *\n     * @param name - The name of the param in {@link UrlParams}.\n     * @param value - The `URLSearchParams` value as an arry of strings.\n     * @returns The parsed value.\n     *\n     * @internal\n     */\n    protected parseUrlParam(name: string, value: string[]): UrlParamValue {\n      switch (typeof initialUrlState[name]) {\n        case 'number':\n          return Number(value[0]);\n        case 'boolean':\n          return value[0].toLowerCase() === 'true';\n        case 'string':\n          return value[0];\n        default:\n          // array\n          return value;\n      }\n    }\n  }\n</script>\n\n<docs lang=\"mdx\">\n## Events\n\nThis component emits the following events:\n\n- [`ParamsLoadedFromUrl`](./../../api/x-components.urlxevents.paramsloadedfromurl.md)\n- [`ExtraParamsLoadedFromUrl`](./../../api/x-components.urlxevents.extraparamsloadedfromurl.md)\n- [`UserOpenXProgrammatically`](./../../api/x-components.xeventstypes.useropenxprogrammatically.md)\n\n## See it in action\n\nThis component manages the browser URL parameters to preserve them through reloads and browser\nhistory navigation. It allow to configure the default url parameter names using its attributes. This\ncomponent doesn't render elements to the DOM.\n\n_Try to make some requests and take a look to the url!_\n\n```vue\n<template>\n  <UrlHandler />\n</template>\n\n<script>\n  import { UrlHandler } from '@empathyco/x-components/url-handler';\n\n  export default {\n    name: 'UrlHandlerDemo',\n    components: {\n      UrlHandler\n    }\n  };\n</script>\n```\n\n### Play with props\n\nIn this example, the `UrlHandler` component changes the following query parameter names:\n\n- `query` to be `q`.\n- `page` to be `p`.\n- `filter` to be `f`\n- `sort` to be `s`\n\n_Try to make some requests and take a look to the url!_\n\n```vue\n<template>\n  <UrlHandler query=\"q\" page=\"p\" filter=\"f\" sort=\"s\" />\n</template>\n\n<script>\n  import { UrlHandler } from '@empathyco/x-components/url-handler';\n\n  export default {\n    name: 'UrlHandlerDemo',\n    components: {\n      UrlHandler\n    }\n  };\n</script>\n```\n\n### Play with events\n\nThe `UrlHandler` will emit the `ParamsLoadedFromUrl` when the page is loaded.\n\nThe `UrlHandler` will emit the `ExtraParamsLoadedFromUrl` when the page is loaded with an extra\nparam configured and with a value in URL.\n\nThe `UrlHandler` will emit the `UserOpenXProgrammatically` when the page is loaded with a query in\nthe URL.\n</docs>\n","import { ExtraParamsXStoreModule } from './types';\n\n/**\n * {@link XStoreModule} For the ExtraParams module.\n *\n * @internal\n */\nexport const extraParamsXStoreModule: ExtraParamsXStoreModule = {\n  state: () => ({\n    params: {}\n  }),\n  getters: {},\n  mutations: {\n    setParams(state, params) {\n      state.params = { ...state.params, ...params };\n    }\n  },\n  actions: {}\n};\n","import { createStoreEmitters } from '../../../store';\nimport { extraParamsXStoreModule } from './module';\n\n/**\n * {@link StoreEmitters} For the {@link ExtraParamsXModule}.\n *\n * @internal\n */\nexport const extraParamsEmitters = createStoreEmitters(extraParamsXStoreModule, {\n  ExtraParamsChanged: {\n    selector: state => state.params,\n    metadata: { priority: 9 }\n  }\n});\n","import { namespacedWireCommit } from '../../wiring';\nimport { createWiring } from '../../wiring/wiring.utils';\n\n/**\n * WireCommit for {@link ExtraParamsXModule}.\n *\n * @internal\n */\nconst wireCommit = namespacedWireCommit('extraParams');\n\n/**\n * Sets the extra params of the {@link ExtraParamsXModule}.\n *\n * @public\n */\nexport const setExtraParams = wireCommit('setParams');\n\n/**\n * Wiring configuration for the {@link ExtraParamsXModule | extraParams module}.\n *\n * @internal\n */\nexport const extraParamsWiring = createWiring({\n  UserChangedExtraParams: {\n    setExtraParams\n  },\n  ExtraParamsProvided: {\n    setExtraParams\n  },\n  ExtraParamsLoadedFromUrl: {\n    setExtraParams\n  }\n});\n","import { XModule } from '../x-modules.types';\nimport { extraParamsEmitters } from './store/emitters';\nimport { extraParamsXStoreModule } from './store/module';\nimport { ExtraParamsXStoreModule } from './store/types';\nimport { extraParamsWiring } from './wiring';\n\n/**\n * ExtraParams {@link XModule} alias.\n *\n * @public\n */\nexport type ExtraParamsXModule = XModule<ExtraParamsXStoreModule>;\n\n/**\n * ExtraParams {@link XModule} implementation. This module is auto-registered as soon as you\n * import any component from the `extraParams` entry point.\n *\n * @public\n */\nexport const extraParamsXModule: ExtraParamsXModule = {\n  name: 'extraParams',\n  storeModule: extraParamsXStoreModule,\n  storeEmitters: extraParamsEmitters,\n  wiring: extraParamsWiring\n};\n","\n  import { Dictionary } from '@empathyco/x-utils';\n  import Vue from 'vue';\n  import { Component, Prop } from 'vue-property-decorator';\n  import { State, xComponentMixin, XEmit } from '../../../components';\n  import { extraParamsXModule } from '../x-module';\n\n  /**\n   * It emits a {@link ExtraParamsXEvents.ExtraParamsProvided} with the values\n   * received as a prop.\n   *\n   * @public\n   */\n  @Component({\n    mixins: [xComponentMixin(extraParamsXModule)]\n  })\n  export default class ExtraParams extends Vue {\n    /**\n     * Emits the initial extra params, overriding with the state extra params, just in case, those\n     * values were already set by XComponents initialization (url, plugin config, etc.).\n     */\n    created(): void {\n      this.$x.emit('ExtraParamsInitialized', { ...this.values });\n      this.$x.emit('ExtraParamsProvided', { ...this.values, ...this.storeExtraParams });\n    }\n\n    /**\n     * (Required) A Dictionary where the keys are the extra param names and its values.\n     *\n     * @remarks Emits the {@link ExtraParamsXEvents.ExtraParamsProvided} when the\n     * component is rendered or the values changed.\n     *\n     * @public\n     */\n    @XEmit('ExtraParamsProvided', { immediate: false, deep: true })\n    @Prop({ required: true })\n    public values!: Dictionary<unknown>;\n\n    /**\n     * State extra params. Used to override the initial extra params.\n     */\n    @State('extraParams', 'params')\n    public storeExtraParams!: Dictionary<unknown>;\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    render(): void {}\n  }\n","<script lang=\"ts\">\n  import { Dictionary } from '@empathyco/x-utils';\n  import Vue from 'vue';\n  import { Component, Prop } from 'vue-property-decorator';\n  import { State, xComponentMixin, XEmit } from '../../../components';\n  import { extraParamsXModule } from '../x-module';\n\n  /**\n   * It emits a {@link ExtraParamsXEvents.ExtraParamsProvided} with the values\n   * received as a prop.\n   *\n   * @public\n   */\n  @Component({\n    mixins: [xComponentMixin(extraParamsXModule)]\n  })\n  export default class ExtraParams extends Vue {\n    /**\n     * Emits the initial extra params, overriding with the state extra params, just in case, those\n     * values were already set by XComponents initialization (url, plugin config, etc.).\n     */\n    created(): void {\n      this.$x.emit('ExtraParamsInitialized', { ...this.values });\n      this.$x.emit('ExtraParamsProvided', { ...this.values, ...this.storeExtraParams });\n    }\n\n    /**\n     * (Required) A Dictionary where the keys are the extra param names and its values.\n     *\n     * @remarks Emits the {@link ExtraParamsXEvents.ExtraParamsProvided} when the\n     * component is rendered or the values changed.\n     *\n     * @public\n     */\n    @XEmit('ExtraParamsProvided', { immediate: false, deep: true })\n    @Prop({ required: true })\n    public values!: Dictionary<unknown>;\n\n    /**\n     * State extra params. Used to override the initial extra params.\n     */\n    @State('extraParams', 'params')\n    public storeExtraParams!: Dictionary<unknown>;\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    render(): void {}\n  }\n</script>\n\n<docs lang=\"mdx\">\n## Events\n\n- [`ExtraParamsProvided`][1]\n\n[1](./../../api/x-components.extraparamsxevents.extraparamsprovided.md)\n\n## See it in action\n\n_See how the event is triggered when the component is rendered._\n\n```vue\n<template>\n  <ExtraParams :values=\"values\" />\n</template>\n\n<script>\n  import { ExtraParams } from '@empathyco/x-components/extra-params';\n\n  export default {\n    name: 'ExtraParamsDemo',\n    components: {\n      ExtraParams\n    },\n    data() {\n      return {\n        values: {\n          warehouse: 1234\n        }\n      };\n    }\n  };\n</script>\n```\n</docs>\n","\n\n\n\n\n  import { forEach, Dictionary } from '@empathyco/x-utils';\n  import Vue from 'vue';\n  import { Component, Inject, Prop } from 'vue-property-decorator';\n  import { xComponentMixin } from '../../../components/x-component.mixin';\n  import { SnippetConfig } from '../../../x-installer/api/api.types';\n  import { extraParamsXModule } from '../x-module';\n  import ExtraParams from './extra-params.vue';\n\n  /**\n   * Extracts the extra parameters from the {@link SnippetConfig} and syncs it with the request\n   * objects of every x-module.\n   *\n   * @public\n   */\n  @Component({\n    components: { ExtraParams },\n    mixins: [xComponentMixin(extraParamsXModule)]\n  })\n  export default class SnippetConfigExtraParams extends Vue {\n    /**\n     * It injects {@link SnippetConfig} provided by an ancestor as snippetConfig.\n     *\n     * @internal\n     */\n    @Inject('snippetConfig')\n    public snippetConfig!: SnippetConfig;\n\n    /**\n     * A Dictionary where the keys are the extra param names and its values.\n     *\n     * @public\n     */\n    @Prop()\n    protected values?: Dictionary<unknown>;\n\n    /**\n     * Custom object containing the extra params from the snippet config and the values prop.\n     *\n     * @remarks This object keeps manually the desired snippet config properties to avoid\n     * unnecessary re-renders.\n     *\n     * @returns A dictionary with the extra params.\n     *\n     * @internal\n     */\n    protected get extraParams(): Dictionary<unknown> {\n      const newExtraParams = {};\n\n      forEach({ ...this.values, ...this.snippetConfig }, (name, value) => {\n        if (!this.excludedExtraParams.includes(name)) {\n          this.$set(newExtraParams, name, value);\n        }\n      });\n\n      return newExtraParams;\n    }\n\n    /**\n     * Collection of properties from the snippet config to exclude from the\n     * extra params object.\n     *\n     * @public\n     */\n    @Prop({\n      default: (): Array<keyof SnippetConfig> => [\n        'callbacks',\n        'productId',\n        'uiLang',\n        'consent',\n        'documentDirection',\n        'currency',\n        'filters',\n        'isSpa',\n        'queriesPreview'\n      ]\n    })\n    protected excludedExtraParams!: Array<keyof SnippetConfig>;\n  }\n","<template>\n  <ExtraParams :values=\"extraParams\" />\n</template>\n\n<script lang=\"ts\">\n  import { forEach, Dictionary } from '@empathyco/x-utils';\n  import Vue from 'vue';\n  import { Component, Inject, Prop } from 'vue-property-decorator';\n  import { xComponentMixin } from '../../../components/x-component.mixin';\n  import { SnippetConfig } from '../../../x-installer/api/api.types';\n  import { extraParamsXModule } from '../x-module';\n  import ExtraParams from './extra-params.vue';\n\n  /**\n   * Extracts the extra parameters from the {@link SnippetConfig} and syncs it with the request\n   * objects of every x-module.\n   *\n   * @public\n   */\n  @Component({\n    components: { ExtraParams },\n    mixins: [xComponentMixin(extraParamsXModule)]\n  })\n  export default class SnippetConfigExtraParams extends Vue {\n    /**\n     * It injects {@link SnippetConfig} provided by an ancestor as snippetConfig.\n     *\n     * @internal\n     */\n    @Inject('snippetConfig')\n    public snippetConfig!: SnippetConfig;\n\n    /**\n     * A Dictionary where the keys are the extra param names and its values.\n     *\n     * @public\n     */\n    @Prop()\n    protected values?: Dictionary<unknown>;\n\n    /**\n     * Custom object containing the extra params from the snippet config and the values prop.\n     *\n     * @remarks This object keeps manually the desired snippet config properties to avoid\n     * unnecessary re-renders.\n     *\n     * @returns A dictionary with the extra params.\n     *\n     * @internal\n     */\n    protected get extraParams(): Dictionary<unknown> {\n      const newExtraParams = {};\n\n      forEach({ ...this.values, ...this.snippetConfig }, (name, value) => {\n        if (!this.excludedExtraParams.includes(name)) {\n          this.$set(newExtraParams, name, value);\n        }\n      });\n\n      return newExtraParams;\n    }\n\n    /**\n     * Collection of properties from the snippet config to exclude from the\n     * extra params object.\n     *\n     * @public\n     */\n    @Prop({\n      default: (): Array<keyof SnippetConfig> => [\n        'callbacks',\n        'productId',\n        'uiLang',\n        'consent',\n        'documentDirection',\n        'currency',\n        'filters',\n        'isSpa',\n        'queriesPreview'\n      ]\n    })\n    protected excludedExtraParams!: Array<keyof SnippetConfig>;\n  }\n</script>\n\n<docs lang=\"mdx\">\n## See it in action\n\n_See how the snippet config is injected and passed to the SnippetConfigExtraParams component._\n\n```vue\n<template>\n  <Provider>\n    <SnippetConfigExtraParams />\n  </Provider>\n</template>\n\n<script>\n  import { SnippetConfigExtraParams } from '@empathyco/x-components/extra-params';\n\n  const Provider = {\n    provide: {\n      snippetConfig: {\n        instance: 'demo',\n        lang: 'es',\n        warehouse: 1234\n      }\n    }\n  };\n\n  export default {\n    name: 'SnippetConfigExtraParamsDemo',\n    components: {\n      Provider,\n      SnippetConfigExtraParams\n    }\n  };\n</script>\n```\n</docs>\n","/** vue-property-decorator verson 8.2.2 MIT LICENSE copyright 2019 kaorun343 */\n/// <reference types='reflect-metadata'/>\n'use strict';\nimport Vue from 'vue';\nimport Component, { createDecorator, mixins } from 'vue-class-component';\nexport { Component, Vue, mixins as Mixins };\n/** Used for keying reactive provide/inject properties */\nvar reactiveInjectKey = '__reactiveInject__';\n/**\n * decorator of an inject\n * @param from key\n * @return PropertyDecorator\n */\nexport function Inject(options) {\n    return createDecorator(function (componentOptions, key) {\n        if (typeof componentOptions.inject === 'undefined') {\n            componentOptions.inject = {};\n        }\n        if (!Array.isArray(componentOptions.inject)) {\n            componentOptions.inject[key] = options || key;\n        }\n    });\n}\n/**\n * decorator of a reactive inject\n * @param from key\n * @return PropertyDecorator\n */\nexport function InjectReactive(options) {\n    return createDecorator(function (componentOptions, key) {\n        if (typeof componentOptions.inject === 'undefined') {\n            componentOptions.inject = {};\n        }\n        if (!Array.isArray(componentOptions.inject)) {\n            var fromKey_1 = !!options ? options.from || options : key;\n            var defaultVal_1 = (!!options && options.default) || undefined;\n            if (!componentOptions.computed)\n                componentOptions.computed = {};\n            componentOptions.computed[key] = function () {\n                var obj = this[reactiveInjectKey];\n                return obj ? obj[fromKey_1] : defaultVal_1;\n            };\n            componentOptions.inject[reactiveInjectKey] = reactiveInjectKey;\n        }\n    });\n}\n/**\n * decorator of a provide\n * @param key key\n * @return PropertyDecorator | void\n */\nexport function Provide(key) {\n    return createDecorator(function (componentOptions, k) {\n        var provide = componentOptions.provide;\n        if (typeof provide !== 'function' || !provide.managed) {\n            var original_1 = componentOptions.provide;\n            provide = componentOptions.provide = function () {\n                var rv = Object.create((typeof original_1 === 'function' ? original_1.call(this) : original_1) ||\n                    null);\n                for (var i in provide.managed)\n                    rv[provide.managed[i]] = this[i];\n                return rv;\n            };\n            provide.managed = {};\n        }\n        provide.managed[k] = key || k;\n    });\n}\n/**\n * decorator of a reactive provide\n * @param key key\n * @return PropertyDecorator | void\n */\nexport function ProvideReactive(key) {\n    return createDecorator(function (componentOptions, k) {\n        var provide = componentOptions.provide;\n        // inject parent reactive services (if any)\n        if (!Array.isArray(componentOptions.inject)) {\n            componentOptions.inject = componentOptions.inject || {};\n            componentOptions.inject[reactiveInjectKey] = { from: reactiveInjectKey, default: {} };\n        }\n        if (typeof provide !== 'function' || !provide.managedReactive) {\n            var original_2 = componentOptions.provide;\n            provide = componentOptions.provide = function () {\n                var _this = this;\n                var rv = typeof original_2 === 'function'\n                    ? original_2.call(this)\n                    : original_2;\n                rv = Object.create(rv || null);\n                // set reactive services (propagates previous services if necessary)\n                rv[reactiveInjectKey] = this[reactiveInjectKey] || {};\n                var _loop_1 = function (i) {\n                    rv[provide.managedReactive[i]] = this_1[i]; // Duplicates the behavior of `@Provide`\n                    Object.defineProperty(rv[reactiveInjectKey], provide.managedReactive[i], {\n                        enumerable: true,\n                        get: function () { return _this[i]; },\n                    });\n                };\n                var this_1 = this;\n                for (var i in provide.managedReactive) {\n                    _loop_1(i);\n                }\n                return rv;\n            };\n            provide.managedReactive = {};\n        }\n        provide.managedReactive[k] = key || k;\n    });\n}\n/** @see {@link https://github.com/vuejs/vue-class-component/blob/master/src/reflect.ts} */\nvar reflectMetadataIsSupported = typeof Reflect !== 'undefined' && typeof Reflect.getMetadata !== 'undefined';\nfunction applyMetadata(options, target, key) {\n    if (reflectMetadataIsSupported) {\n        if (!Array.isArray(options) &&\n            typeof options !== 'function' &&\n            typeof options.type === 'undefined') {\n            options.type = Reflect.getMetadata('design:type', target, key);\n        }\n    }\n}\n/**\n * decorator of model\n * @param  event event name\n * @param options options\n * @return PropertyDecorator\n */\nexport function Model(event, options) {\n    if (options === void 0) { options = {}; }\n    return function (target, key) {\n        applyMetadata(options, target, key);\n        createDecorator(function (componentOptions, k) {\n            ;\n            (componentOptions.props || (componentOptions.props = {}))[k] = options;\n            componentOptions.model = { prop: k, event: event || k };\n        })(target, key);\n    };\n}\n/**\n * decorator of a prop\n * @param  options the options for the prop\n * @return PropertyDecorator | void\n */\nexport function Prop(options) {\n    if (options === void 0) { options = {}; }\n    return function (target, key) {\n        applyMetadata(options, target, key);\n        createDecorator(function (componentOptions, k) {\n            ;\n            (componentOptions.props || (componentOptions.props = {}))[k] = options;\n        })(target, key);\n    };\n}\n/**\n * decorator of a synced prop\n * @param propName the name to interface with from outside, must be different from decorated property\n * @param options the options for the synced prop\n * @return PropertyDecorator | void\n */\nexport function PropSync(propName, options) {\n    if (options === void 0) { options = {}; }\n    // @ts-ignore\n    return function (target, key) {\n        applyMetadata(options, target, key);\n        createDecorator(function (componentOptions, k) {\n            ;\n            (componentOptions.props || (componentOptions.props = {}))[propName] = options;\n            (componentOptions.computed || (componentOptions.computed = {}))[k] = {\n                get: function () {\n                    return this[propName];\n                },\n                set: function (value) {\n                    // @ts-ignore\n                    this.$emit(\"update:\" + propName, value);\n                },\n            };\n        })(target, key);\n    };\n}\n/**\n * decorator of a watch function\n * @param  path the path or the expression to observe\n * @param  WatchOption\n * @return MethodDecorator\n */\nexport function Watch(path, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.deep, deep = _a === void 0 ? false : _a, _b = options.immediate, immediate = _b === void 0 ? false : _b;\n    return createDecorator(function (componentOptions, handler) {\n        if (typeof componentOptions.watch !== 'object') {\n            componentOptions.watch = Object.create(null);\n        }\n        var watch = componentOptions.watch;\n        if (typeof watch[path] === 'object' && !Array.isArray(watch[path])) {\n            watch[path] = [watch[path]];\n        }\n        else if (typeof watch[path] === 'undefined') {\n            watch[path] = [];\n        }\n        watch[path].push({ handler: handler, deep: deep, immediate: immediate });\n    });\n}\n// Code copied from Vue/src/shared/util.js\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = function (str) { return str.replace(hyphenateRE, '-$1').toLowerCase(); };\n/**\n * decorator of an event-emitter function\n * @param  event The name of the event\n * @return MethodDecorator\n */\nexport function Emit(event) {\n    return function (_target, key, descriptor) {\n        key = hyphenate(key);\n        var original = descriptor.value;\n        descriptor.value = function emitter() {\n            var _this = this;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var emit = function (returnValue) {\n                if (returnValue !== undefined)\n                    args.unshift(returnValue);\n                _this.$emit.apply(_this, [event || key].concat(args));\n            };\n            var returnValue = original.apply(this, args);\n            if (isPromise(returnValue)) {\n                returnValue.then(function (returnValue) {\n                    emit(returnValue);\n                });\n            }\n            else {\n                emit(returnValue);\n            }\n            return returnValue;\n        };\n    };\n}\n/**\n * decorator of a ref prop\n * @param refKey the ref key defined in template\n */\nexport function Ref(refKey) {\n    return createDecorator(function (options, key) {\n        options.computed = options.computed || {};\n        options.computed[key] = {\n            cache: false,\n            get: function () {\n                return this.$refs[refKey || key];\n            },\n        };\n    });\n}\nfunction isPromise(obj) {\n    return obj instanceof Promise || (obj && typeof obj.then === 'function');\n}\n","export const breakpoints = {\n  mobile: 0,\n  tablet: 744,\n  desktop: 1280,\n  large: 2560\n};\n","import { createUseDevice } from '@empathyco/x-components';\nimport { breakpoints } from '../device-breakpoints';\n\nexport const useDevice = createUseDevice(breakpoints);\n","export default {\n  EUR: 'i.iii,dd €',\n  USD: '$i,iii.dd'\n} as Record<string, string>;\n","\n\n\n\n\n\n\n\n\n\n\n  import {\n    QueryPreviewInfo,\n    SnippetCallbacks,\n    SnippetConfig,\n    XOn,\n    XProvide\n  } from '@empathyco/x-components';\n  import { Tagging } from '@empathyco/x-components/tagging';\n  import { UrlHandler } from '@empathyco/x-components/url';\n  import { SnippetConfigExtraParams } from '@empathyco/x-components/extra-params';\n  import { Component, Inject, Provide, Vue, Watch } from 'vue-property-decorator';\n  import { useDevice } from './composables/use-device.composable';\n  import currencies from './i18n/currencies';\n  import './tailwind/index.css';\n\n  @Component({\n    components: {\n      SnippetCallbacks,\n      SnippetConfigExtraParams,\n      Tagging,\n      UrlHandler,\n      MainModal: () => import('./components/custom-main-modal.vue').then(m => m.default)\n    }\n  })\n  export default class App extends Vue {\n    protected isOpen = false;\n\n    @XOn(['UserOpenXProgrammatically', 'UserClickedOpenX'])\n    open(): void {\n      this.isOpen = true;\n    }\n\n    @Inject('snippetConfig')\n    protected snippetConfig!: SnippetConfig;\n    protected device = useDevice();\n\n    protected get documentDirection(): string {\n      return (\n        document.documentElement.dir ||\n        document.body.dir ||\n        (this.snippetConfig.documentDirection ?? 'ltr')\n      );\n    }\n\n    @Provide('currencyFormat')\n    public get currencyFormat(): string {\n      return currencies[this.snippetConfig.currency!];\n    }\n\n    @XProvide('queriesPreviewInfo')\n    public get queriesPreviewInfo(): QueryPreviewInfo[] | undefined {\n      return this.snippetConfig.queriesPreview;\n    }\n\n    @Watch('snippetConfig.uiLang')\n    syncLang(uiLang: string): void {\n      this.$setLocale(uiLang);\n    }\n\n    @Watch('device.deviceName')\n    syncDevice(deviceName: string): void {\n      this.$setLocaleDevice(deviceName);\n    }\n  }\n","<template>\n  <div class=\"x\" data-test=\"x\" :dir=\"documentDirection\">\n    <SnippetConfigExtraParams />\n    <SnippetCallbacks />\n    <Tagging />\n    <UrlHandler />\n    <MainModal v-if=\"isOpen\" />\n  </div>\n</template>\n\n<script lang=\"ts\">\n  import {\n    QueryPreviewInfo,\n    SnippetCallbacks,\n    SnippetConfig,\n    XOn,\n    XProvide\n  } from '@empathyco/x-components';\n  import { Tagging } from '@empathyco/x-components/tagging';\n  import { UrlHandler } from '@empathyco/x-components/url';\n  import { SnippetConfigExtraParams } from '@empathyco/x-components/extra-params';\n  import { Component, Inject, Provide, Vue, Watch } from 'vue-property-decorator';\n  import { useDevice } from './composables/use-device.composable';\n  import currencies from './i18n/currencies';\n  import './tailwind/index.css';\n\n  @Component({\n    components: {\n      SnippetCallbacks,\n      SnippetConfigExtraParams,\n      Tagging,\n      UrlHandler,\n      MainModal: () => import('./components/custom-main-modal.vue').then(m => m.default)\n    }\n  })\n  export default class App extends Vue {\n    protected isOpen = false;\n\n    @XOn(['UserOpenXProgrammatically', 'UserClickedOpenX'])\n    open(): void {\n      this.isOpen = true;\n    }\n\n    @Inject('snippetConfig')\n    protected snippetConfig!: SnippetConfig;\n    protected device = useDevice();\n\n    protected get documentDirection(): string {\n      return (\n        document.documentElement.dir ||\n        document.body.dir ||\n        (this.snippetConfig.documentDirection ?? 'ltr')\n      );\n    }\n\n    @Provide('currencyFormat')\n    public get currencyFormat(): string {\n      return currencies[this.snippetConfig.currency!];\n    }\n\n    @XProvide('queriesPreviewInfo')\n    public get queriesPreviewInfo(): QueryPreviewInfo[] | undefined {\n      return this.snippetConfig.queriesPreview;\n    }\n\n    @Watch('snippetConfig.uiLang')\n    syncLang(uiLang: string): void {\n      this.$setLocale(uiLang);\n    }\n\n    @Watch('device.deviceName')\n    syncDevice(deviceName: string): void {\n      this.$setLocaleDevice(deviceName);\n    }\n  }\n</script>\n\n<style scoped>\n  .x-modal::v-deep .x-modal__content {\n    width: 100%;\n    height: 100%;\n    background-color: white;\n    overflow: auto;\n  }\n</style>\n<style lang=\"scss\">\n  *:not(.x-keyboard-navigation *) {\n    outline: none;\n  }\n\n  .x-banner,\n  .x-promoted {\n    &__title {\n      display: none;\n    }\n  }\n</style>\n","/*\n  Export the messages in this file to be auto-loaded.\n\n  A normal re-export like `export { default as en } from './en.messages'`,\n  will make the `en` to be loaded immediately and included in the main chunk.\n\n  If you instead prefer the messages to be loaded only when they are needed, export instead\n  a function that imports the messages. This way, messages for a specific locale would be loaded\n  when the active locale matches them.\n */\n\n// Example of how to make the english language be loaded immediately\n// export { default as en } from './en.messages.json';\n// export { default as es } from './es.messages.json';\n\n// Example of how to make the spanish messages be lazy loaded, only when the locale is set to `es`\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\nexport const es = () => import('./es.messages.json');\nexport const en = () => import('./en.messages.json');\nexport const fr = () => import('./fr.messages.json');\nexport const pt = () => import('./pt.messages.json');\nexport const it = () => import('./it.messages.json');\n/* eslint-enable @typescript-eslint/explicit-function-return-type */\n","import Vue from 'vue';\nimport Vuex, { Store } from 'vuex';\n\nVue.use(Vuex);\n\nexport default new Store({\n  strict: process.env.NODE_ENV !== 'production',\n  state: {},\n  mutations: {},\n  actions: {},\n  modules: {}\n});\n","import { isObject } from '@empathyco/x-utils';\n\nenum Behaviour {\n  Replace = 'replace',\n  DeepMerge = 'deep-merge'\n}\n\n/**\n * Clones deeply all of the sources objects values into the target, except the arrays,\n * which only generates a new one, but keeping the references of the sources one.\n *\n * TODO Make it work with circular references.\n *\n * @param target - The object which will be used as the base to clone all the sources into.\n * @param sources - One or more objects to clone to the target.\n *\n * @returns The target modified.\n */\nexport function deepMerge(target: any, ...sources: any[]): any {\n  return sources.reduce(cloneSourcesProperties, target || {});\n}\n\nconst behaviourMap = new WeakMap();\n\n/**\n * When setting replace behaviour to an object, target properties will not be used,\n * only the source ones.\n *\n * @param obj - The object to set its merge behavior.\n * @example\n * ```ts\n * const target = { children: { a: 1, b: 2, c: 3 } };\n * const firstSource = { children: replaceBehaviour({ c: 4, d: 5 }) };\n * deepMerge(target, firstSource);\n * // `target` is now { children: { c: 4, d: 5 } }\n * ```\n *\n * @returns The same object with the new behaviour.\n */\nexport function replaceBehaviour<T extends Record<string, unknown>>(obj: T): T {\n  behaviourMap.set(obj, Behaviour.Replace);\n  return obj;\n}\n\n/**\n * When setting deep merge behaviour, target and source properties will be used. This is the default\n * behavior.\n *\n * @param obj - The object to set its merge behavior.\n *\n * @returns The same object with the new behaviour.\n */\nexport function deepMergeBehaviour<T extends Record<string, unknown>>(obj: T): T {\n  behaviourMap.set(obj, Behaviour.DeepMerge);\n  return obj;\n}\n\n/**\n * A function which clones the properties of two sources.\n *\n * @param target - The target object to clone in.\n * @param source - The source objet to clone.\n *\n * @returns The union of the target and source.\n */\nfunction cloneSourcesProperties(target: any, source: any): (source: any) => void {\n  if (source) {\n    return Object.entries(source).reduce(cloneObjectProperties, target);\n  } else {\n    return target || {};\n  }\n}\n\n/**\n * A function which clones the properties of two object.\n *\n * @param target - The target object to clone in.\n * @param source - Key-Value to clone into the target object.\n *\n * @returns The target object updated with the entry parameter.\n */\nfunction cloneObjectProperties(target: any, [key, value]: any): any {\n  if (value === undefined) {\n    delete target[key];\n  } else if (isObject(value)) {\n    mergeObject(target, [key, value]);\n  } else if (Array.isArray(value)) {\n    target[key] = [...value];\n  } else {\n    target[key] = value;\n  }\n  return target;\n}\n\n/**\n * A function which merges two sources.\n *\n * @param target - The target object to clone in.\n * @param source - Key-Value to clone into the target object.\n *\n */\nfunction mergeObject(target: any, [key, value]: any): void {\n  const mergeBehaviour = getMergeBehaviour(target[key], value);\n  if (mergeBehaviour === Behaviour.Replace) {\n    target[key] = deepMerge({}, value);\n    replaceBehaviour(target[key]);\n  } else if (mergeBehaviour === Behaviour.DeepMerge) {\n    target[key] = deepMerge(target[key] || {}, value);\n    deepMergeBehaviour(target[key]);\n  } else {\n    target[key] = deepMerge(isObject(target[key]) ? target[key] : {}, value);\n  }\n}\n\n/**\n * A function which detects the merge behaviour.\n *\n * @param targetValue - The target object.\n * @param sourceValue - The source objet.\n *\n * @returns The correct behaviour.\n */\nfunction getMergeBehaviour(targetValue: any, sourceValue: any): Behaviour {\n  return behaviourMap.get(sourceValue) || behaviourMap.get(targetValue);\n}\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n};\n","/**\n * The `RequestError` object is thrown when a runtime `request` error occurs.\n *\n * @public\n */\nexport class RequestError extends Error {\n  /**\n   * Creates a new `RequestError` object.\n   *\n   * @param message - The error message.\n   * @param response - The response from the request that triggered the error.\n   *\n   * @public\n   */\n  public constructor(public readonly message: string, public readonly response: Response) {\n    super(message);\n  }\n}\n","import { Dictionary, forEach } from '@empathyco/x-utils';\nimport { RequestError } from './errors/request-error';\n\n/**\n * Formats a response object to JSON.\n *\n * @remarks If the `response.ok` is falsy, a `RequestError` object is thrown.\n *\n * @param response - The response to convert to JSON format.\n * @returns - The resultant promise of formatting the response to JSON.\n *\n * @public\n */\nexport function toJson(response: Response): Promise<any> {\n  if (response.ok) {\n    return response.text().then(text => (text ? JSON.parse(text) : {}));\n  } else {\n    throw new RequestError('Request failed', response);\n  }\n}\n\n/**\n * Builds a URL object based on the passed endpoint and the request parameters.\n *\n * @param endpoint - The endpoint.\n * @param params - The request parameters.\n *\n * @returns The `href` property of the newly built `URL` object.\n *\n * @public\n */\nexport function buildUrl(endpoint: string, params: Dictionary<unknown> = {}): URL['href'] {\n  const url = new URL(endpoint);\n  forEach(params, (key, value) =>\n    (Array.isArray(value) ? value : [value]).forEach(arrayItemValue =>\n      url.searchParams.append(key, String(arrayItemValue))\n    )\n  );\n  return url.href;\n}\n","import { Dictionary, cleanEmpty, flatObject } from '@empathyco/x-utils';\nimport { HttpClient } from './types';\nimport { buildUrl, toJson } from './utils';\n\n/**\n * The `fetchHttpClient()` function is a http client implementation using the `fetch` WebAPI.\n *\n * @param endpoint - The endpoint to make the request to.\n * @param options - The request options.\n *\n * @returns A `Promise` object.\n *\n * @public\n */\nexport const fetchHttpClient: HttpClient = (\n  endpoint,\n  { id = endpoint, cancelable = true, parameters = {}, properties, sendParamsInBody = false } = {}\n) => {\n  const signal = cancelable ? { signal: abortAndGetNewAbortSignal(id) } : {};\n  const flatParameters = flatObject(parameters);\n  const url = sendParamsInBody ? endpoint : buildUrl(endpoint, cleanEmpty(flatParameters));\n  const bodyParameters = sendParamsInBody ? { body: JSON.stringify(cleanEmpty(parameters)) } : {};\n\n  return fetch(url, {\n    ...properties,\n    ...bodyParameters,\n    ...signal\n  }).then(toJson);\n};\n\n/**\n * Dictionary with the request id as key and an `AbortController` as value.\n */\nconst requestAbortControllers: Dictionary<AbortController> = {};\n\n/**\n * Function that cancels previous request with the same `id` and returns a new `AbortSignal` for\n * the new request.\n *\n * @param id - The identifier of the request to cancel and create a new `AbortSignal`.\n *\n * @returns The new `AbortSignal`.\n */\nfunction abortAndGetNewAbortSignal(id: string): AbortSignal {\n  requestAbortControllers[id]?.abort();\n  requestAbortControllers[id] = new AbortController();\n  return requestAbortControllers[id].signal;\n}\n","/**\n * Maps an entity to itself.\n *\n * @param value - The entity to map.\n *\n * @returns The mapped entity.\n * @public\n */\nexport function identityMapper<Something>(value: Something): Something {\n  return value;\n}\n","import { getSafePropertyChain } from '@empathyco/x-utils';\n\n/**\n * Syntax to detect and extract string parameters. A string parameter contains a property name\n * with an optional header or tail to concatenate wrapped in curly braces (`{}`).\n * The different parts of a string parameter are explained in {@link STRING_PARAMETER_CONTENT}.\n *\n * @example Different string parameters\n * ```js\n *   \"\\{env\\}\" // No optional head or tail.\n *   \"\\{(.)env\\}\" // Optional `.` head.\n *   \"\\{env(-api)\\}\" // Optional `-api` tail.\n *   \"\\{(api-)env(.)\\}\" // Optional `api-` head and `.` tail.\n * ```\n * @internal\n */\nconst STRING_PARAMETERS = /{([^}]+)}/g;\n\n/**\n * Shape of the optional head and tail parts of the {@link STRING_PARAMETER_CONTENT} regex.\n * This can be anything wrapped into parentheses.\n *\n * @internal\n */\nconst HEAD_OR_TAIL = '(?:\\\\((.+)\\\\))?';\n/**\n * Syntax of a single string parameter. A string parameter shape is composed by\n * the name of the property that should be replaced. This property name can be preceded\n * or followed by an optional string to prepend or to append to the property value\n * in case it is defined.\n *\n * @example Valid string parameters content\n * ```js\n *   \"env\" // No optional head or tail to concatenate.\n *   \"(.)env\" // The `.` character will be prepended as long as the `env` property is defined.\n *   \"env(-api)\" // The `-api` string will be appended as long as the `env` property is defined.\n *   \"(api-)env(.)\" // The `api-` string and the `.` character will be added as long as\n *   // the `env` property is defined.\n * ```\n * @internal\n */\nconst STRING_PARAMETER_CONTENT = new RegExp(`^${HEAD_OR_TAIL}([^(]+)${HEAD_OR_TAIL}$`, 'g');\n\n/**\n * Interpolates different parameters into a string.\n * The provided string can set the parameters to replace wrapping a parameter name in curly\n * braces. This will then be replaced by the parameter value as long as it is defined. If it\n * is not provided, the parameter  name will just be removed from the final string.\n *\n * @param string - The string to interpolate different parameters in.\n * @param parameters - Value of the different parameters to interpolate.\n * @returns The interpolated string.\n * @example Different usages of the interpolate function.\n * ```js\n *  interpolate('https://{env}.empathy.co/{instance}', {\n *    env: 'live',\n *    instance: 'demo'\n *  })     // 'https://live.empathy.co/demo'\n *\n *  interpolate('https://{(api-)env}.empathy.co/{instance}', {\n *    env: 'live',\n *    instance: 'demo'\n *  }) // 'https://api-live.empathy.co/demo'\n *\n *  interpolate('https://api.{env(.)}empathy.co/{instance}', {\n *    env: 'live',\n *    instance: 'demo'\n *  }) // 'https://api.live.empathy.co/demo'\n *\n *  interpolate('https://{(api-)env(.)}empathy.co/{instance}', {\n *    env: 'live',\n *    instance: 'demo'\n *  }) // 'https://api-live.empathy.co/demo'\n *\n *  interpolate('https://{env}.empathy.co/{instance}', {\n *    env: 'live'\n *  }) // 'https://live.empathy.co/'\n *\n *  interpolate('https://search{(api-)env}.empathy.co/{instance}', {\n *    instance: 'demo'\n *  }) // 'https://search.empathy.co/demo'\n *\n *  interpolate('https://api.{env(.)}empathy.co/{instance}', {\n *    instance: 'demo'\n *  }) // 'https://api.empathy.co/demo'\n *\n *  interpolate('https://search.{(api-)env(.)}empathy.co/{instance}', {\n *    instance: 'demo'\n *  }) // 'https://search.empathy.co/demo'\n * ```\n * @public\n */\nexport function interpolate(string: string, parameters: Record<string, unknown>): string {\n  return string.replace(STRING_PARAMETERS, (_match, propertyToReplace: string) =>\n    propertyToReplace.replace(\n      STRING_PARAMETER_CONTENT,\n      (_match, head = '', property: string, tail = '') => {\n        const value = getSafePropertyChain(parameters, property);\n        /* As the replacer function has a very dynamic signature, it is typed as a function with\n         * `any` arguments. This makes it impossible for TS to infer the correct `string`\n         * type that we are using as default values here. */\n        return value ? `${String(head)}${String(value)}${String(tail)}` : '';\n      }\n    )\n  );\n}\n","import { deepMerge } from '@empathyco/x-deep-merge';\nimport { fetchHttpClient } from '../http-clients/fetch.http-client';\nimport { identityMapper } from '../mappers/identity.mapper';\nimport { Mapper } from '../mappers/types';\nimport { interpolate } from '../utils/interpolate';\nimport { EndpointAdapterFactory, EndpointAdapterOptions, ExtendableEndpointAdapter } from './types';\n\n/**\n * Factory to create {@link ExtendableEndpointAdapter | endpoint adapters} with the given\n * {@link EndpointAdapterOptions | options}.\n *\n * @param options - The {@link EndpointAdapterOptions | options} to create a new\n * {@link ExtendableEndpointAdapter} with.\n *\n * @returns A brand new {@link ExtendableEndpointAdapter} object.\n * @public\n */\nexport const endpointAdapterFactory: EndpointAdapterFactory = <Request, Response>(\n  options: EndpointAdapterOptions<Request, Response>\n) => {\n  const endpointAdapter: ExtendableEndpointAdapter<Request, Response> = (\n    request,\n    { endpoint: requestEndpoint, ...requestOptions } = {}\n  ) => {\n    const {\n      endpoint: rawEndpoint,\n      httpClient = fetchHttpClient,\n      requestMapper = identityMapper,\n      responseMapper = identityMapper,\n      defaultRequestOptions = {}\n    }: EndpointAdapterOptions<Request, Response> = options;\n\n    const endpoint = getEndpoint(requestEndpoint ?? rawEndpoint, request);\n    const requestParameters = requestMapper(request, { endpoint });\n\n    return httpClient(\n      endpoint,\n      deepMerge({}, defaultRequestOptions, requestOptions, { parameters: requestParameters })\n    ).then(response => responseMapper(response, { endpoint, requestParameters }));\n  };\n\n  endpointAdapter.extends = <NewRequest, NewResponse>(\n    extendedOptions: Partial<EndpointAdapterOptions<NewRequest, NewResponse>>\n  ) =>\n    endpointAdapterFactory<NewRequest, NewResponse>({\n      ...options,\n      ...extendedOptions\n    } as EndpointAdapterOptions<NewRequest, NewResponse>);\n\n  return endpointAdapter;\n};\n\n/**\n * Returns an endpoint.\n *\n * @param endpoint - The endpoint to process.\n * @param request - The request object.\n *\n * @returns The endpoint.\n * @internal\n */\nfunction getEndpoint<Request>(\n  endpoint: string | Mapper<Request, string> | undefined,\n  request: Request\n): string {\n  if (!endpoint) {\n    throw Error('Tried to make a request without an endpoint');\n  }\n\n  return typeof endpoint === 'function'\n    ? endpoint(request, {})\n    : interpolate(endpoint, request as Record<string, unknown>);\n}\n","import { deepMerge } from '@empathyco/x-deep-merge';\nimport { forEach, isFunction, isObject } from '@empathyco/x-utils';\nimport { MutableSchema, Schema } from './types';\n\n/**\n * Collection of internal method names for {@link MutableSchema | mutable schemas}.\n */\nconst mutableSchemasInternalMethods: string[] = ['$replace', '$override', '$extends', 'toString'];\n\n/**\n * Creates a {@link MutableSchema | mutable schema } version of a given {@link Schema | schema}.\n *\n * @param schema - The {@link Schema | schema} to make mutable.\n *\n * @returns A {@link MutableSchema | mutable schema} version of the given {@link Schema | schema}.\n *\n * @public\n */\nexport function createMutableSchema<Source, Target>(\n  schema: Schema<Source, Target>\n): MutableSchema<Source, Target> {\n  return {\n    ...schema,\n    $replace(newSchema) {\n      forEach(this, key => {\n        if (isInternalMethod(key as string)) {\n          return;\n        }\n        delete this[key];\n      });\n      Object.assign(this, newSchema);\n      /* We are replacing the schema with a completely new schema , so it makes sense that TS\n       complains that the old schema and the new one are not the same. */\n      return this as any;\n    },\n    $override(newSchema) {\n      return deepMerge(this, newSchema);\n    },\n    $extends(newSchema: unknown) {\n      return deepMerge({}, this, newSchema);\n    },\n    toString(includeInternalMethods = false) {\n      return serialize(this, !!includeInternalMethods);\n    }\n  };\n}\n\n/**\n * Checks if the given key is a {@link MutableSchema | mutableSchema} method.\n *\n * @param name - The key to check.\n *\n * @returns True if it is a {@link MutableSchema | mutableSchema} method,\n * false otherwise.\n *\n * @public\n */\nexport function isInternalMethod(name: string): boolean {\n  return mutableSchemasInternalMethods.includes(name);\n}\n\n/**\n * Returns a string representing of the given object.\n *\n * @param data - The object to get the string representation from.\n * @param includeInternalMethods - Flag to include in the string representation\n * the internal methods. Disabled by default.\n * @param deep - The level of indentation.\n * @returns The string representation.\n */\nfunction serialize(\n  data: Record<string, unknown>,\n  includeInternalMethods: boolean,\n  deep = 0\n): string {\n  const indentation = '  '.repeat(deep);\n  let output = '';\n  forEach(data, (key, value) => {\n    if (isObject(value)) {\n      output += `${indentation}${key}: {\\n${serialize(\n        value,\n        includeInternalMethods,\n        ++deep\n      )}${indentation}},\\n`;\n    } else if (!isFunction(value) || !isInternalMethod(key) || includeInternalMethods) {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      output += `${indentation}${key}: ${value},\\n`;\n    }\n  });\n  return output;\n}\n","import { deepMerge } from '@empathyco/x-deep-merge';\nimport {\n  Dictionary,\n  ExtractPath,\n  getSafePropertyChain,\n  isArray,\n  isFunction,\n  isObject,\n  isPath,\n  reduce\n} from '@empathyco/x-utils';\nimport { MutableSchema, Schema, SubSchemaTransformer } from '../schemas/types';\nimport { createMutableSchema, isInternalMethod } from '../schemas/utils';\nimport { Mapper, MapperContext } from './types';\n\n/**\n * The 'schemaMapperFactory' function creates a {@link Mapper | mapper function} for a given\n * {@link Schema | schema}.\n *\n * @param schema - The {@link Schema | schema} to apply in the {@link Mapper | mapper function}.\n * @returns A {@link Mapper | mapper function} that applies the given {@link Schema | schema}.\n * @public\n */\nexport function schemaMapperFactory<Source, Target>(\n  schema: Schema<Source, Target> | MutableSchema<Source, Target>\n): Mapper<Source, Target> {\n  return function mapper(source: Source, context: MapperContext): Target {\n    return mapSchema(source, schema, context);\n  };\n}\n\n/**\n * The `mapSchema()` function creates a new object populated with the transformations defined by a\n * {@link Schema} applied to a source object.\n *\n * @param source - The object to apply the transformations to.\n * @param schema - The object that defines the transformations to apply.\n * @param context - The {@link MapperContext | mapper context} to feed the transformations with.\n * @returns A new object with each element being the result of the applied transformation.\n * @internal\n */\nfunction mapSchema<Source, Target>(\n  source: Source,\n  schema: Schema<Source, Target>,\n  context: MapperContext\n): Target {\n  if (!source) {\n    //eslint-disable-next-line no-console\n    console.warn('This schema cannot be applied', createMutableSchema(schema));\n    return undefined as any;\n  }\n  return reduce(\n    schema,\n    (target, key, transformer) => {\n      type TargetKey = Target[keyof Target];\n      if (typeof transformer === 'string' && isPath(source, transformer)) {\n        target[key] = getSafePropertyChain(source, transformer) as TargetKey;\n      } else if (isFunction(transformer) && !isInternalMethod(transformer.name)) {\n        target[key] = transformer(source, context);\n      } else if (isObject(transformer)) {\n        const value =\n          '$subSchema' in transformer\n            ? (applySubSchemaTransformer<Source, TargetKey>(\n                source,\n                transformer as SubSchemaTransformer<Source, TargetKey>,\n                context,\n                schema as unknown as Schema<Source, TargetKey>\n              ) as TargetKey)\n            : mapSchema<Source, TargetKey>(source, transformer, context);\n\n        if (value) {\n          target[key] = value;\n        }\n      }\n      return target;\n    },\n    {} as Target\n  );\n}\n\n/**\n * The `applySubSchemaTransformer()` function executes a `mapSchema()` function applying the defined\n * {@link SubSchemaTransformer.$subSchema}.\n *\n * @param source - The object to feed the schema.\n * @param subSchemaTransformer - The {@link SubSchemaTransformer} object with a $path, $subSchema\n * and $context options.\n * @param subSchemaTransformer.$path\n * @param subSchemaTransformer.$subSchema\n * @param rawContext - The {@link MapperContext | mapper context} to feed the mapSchema function.\n * @param subSchemaTransformer.$context\n * @param schema - The {@link Schema} to apply.\n * @returns The result of calling `mapSchema()` with the source, schema and context arguments.\n * @internal\n */\nfunction applySubSchemaTransformer<Source, Target>(\n  source: Source,\n  { $subSchema, $path, $context }: SubSchemaTransformer<Source, Target>,\n  rawContext: MapperContext,\n  schema: Schema<Source, Target>\n): Target | Target[] | undefined {\n  const subSource = getSafePropertyChain(source, $path);\n\n  if (!subSource) {\n    return;\n  }\n\n  const extendedContext: Dictionary = {};\n  if ($context) {\n    Object.entries($context).forEach(([key, value]) => {\n      if (['requestParameters', 'endpoint', 'mappedValue'].includes(key)) {\n        return;\n      }\n      extendedContext[key] = isFunction(value)\n        ? value(source)\n        : getSafePropertyChain(source, value as ExtractPath<typeof source>);\n    });\n  }\n\n  const context = deepMerge({}, rawContext, $context, extendedContext);\n  let subSchema: typeof $subSchema | typeof schema;\n  if ($subSchema === '$self') {\n    subSchema = schema;\n  } else if (isFunction($subSchema)) {\n    subSchema = $subSchema(source);\n  } else {\n    subSchema = $subSchema;\n  }\n  return isArray(subSource)\n    ? subSource.map(item => mapSchema(item, subSchema, context) as Target)\n    : mapSchema<typeof subSource, Target>(\n        subSource,\n        subSchema as Schema<typeof subSource, Target>,\n        context\n      );\n}\n","/**\r\n * Type guard to check if a filter is a {@link HierarchicalFilter}.\r\n *\r\n * @param filter - The filter to check.\r\n *\r\n * @returns True if the filter is a {@link HierarchicalFilter}, false otherwise.\r\n *\r\n * @public\r\n */\r\nfunction isHierarchicalFilter(filter) {\r\n    return filter.modelName === 'HierarchicalFilter';\r\n}\n\nexport { isHierarchicalFilter };\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { isHierarchicalFilter, SearchRequest } from '@empathyco/x-types';\nimport { reduce } from '@empathyco/x-utils';\nimport { PlatformSearchRequest } from '../../types/requests/search-request.model';\n\n/**\n * Default implementation for the SearchRequestSchema.\n *\n * @public\n */\nexport const searchRequestSchema = createMutableSchema<SearchRequest, PlatformSearchRequest>({\n  query: 'query',\n  origin: 'origin',\n  start: 'start',\n  rows: 'rows',\n  sort: 'sort',\n  filter: mapFilters,\n  extraParams: 'extraParams'\n});\n\n/**\n * Converts the filters to the shape the Platform's API is expecting.\n *\n * @param filters - The filters from our internal request.\n * @example\n * ```ts\n * const filters = {\n *     offer: [\n *     {\n *       facetId: 'offer',\n *       modelName: 'SimpleFilter',\n *       id: 'price:[0 TO 10]',\n *       selected: true,\n *       label: 'In Offer'\n *     } as SimpleFilter\n *   ],\n *     categoryPaths: [\n *     {\n *       facetId: 'categoryPaths',\n *       id: 'categoryIds:ffc61e1e9__be257cb26',\n *       label: 'Fragrance',\n *       modelName: 'HierarchicalFilter',\n *       parentId: 'categoryIds:ffc61e1e9',\n *       selected: true,\n *       totalResults: 1\n *     },\n *     {\n *       facetId: 'categoryPaths',\n *       id: 'categoryIds:ffc61e1e9__fa5ef54f2',\n *       label: 'Fragrance',\n *       modelName: 'HierarchicalFilter',\n *       parentId: 'categoryIds:ffc61e1e9',\n *       selected: true,\n *       totalResults: 1\n *     },\n *     {\n *       children: ['categoryIds:ffc61e1e9__be257cb26', 'categoryIds:ffc61e1e9__fa5ef54f2'],\n *       facetId: 'categoryPaths',\n *       id: 'categoryIds:ffc61e1e9',\n *       label: 'Personal Care',\n *       modelName: 'HierarchicalFilter',\n *       parentId: null,\n *       selected: true,\n *       totalResults: 1\n *     }]\n * };\n *\n * const mappedFilters = mapFilters({ filters });\n * // mappedFilters is [\n * //      'price:[0 TO 10]',\n * //        'categoryIds:ffc61e1e9__be257cb26',\n * //        'categoryIds:ffc61e1e9__fa5ef54f2'\n * //      ];\n *\n * ```\n * @returns The filters ready for the API.\n */\nfunction mapFilters({ filters }: SearchRequest): string[] {\n  return reduce(\n    filters,\n    (accumulator, _, filters) => [\n      ...accumulator,\n      ...filters\n        .filter(\n          filter =>\n            !isHierarchicalFilter(filter) ||\n            !filters.some(child => isHierarchicalFilter(child) && child.parentId === filter.id)\n        )\n        .map(filter => filter.id.toString())\n    ],\n    [] as string[]\n  );\n}\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { SearchRequest } from '@empathyco/x-types';\nimport { searchRequestSchema } from '../../schemas/requests/search-request.schema';\nimport { PlatformSearchRequest } from '../../types/requests/search-request.model';\n\n/**\n * Default implementation for the SearchRequestMapper.\n *\n * @public\n */\nexport const searchRequestMapper = schemaMapperFactory<SearchRequest, PlatformSearchRequest>(\n  searchRequestSchema\n);\n","import { TaggingRequest } from '@empathyco/x-types';\n\n/**\n * Extracts the tagging info from a URL.\n *\n * @param taggingUrl - The url containing the tagging info.\n *\n * @returns The object with the tagging info.\n *\n * @public\n */\nexport function getTaggingInfoFromUrl(taggingUrl: string): TaggingRequest {\n  const { url, params } = extractUrlParameters(taggingUrl);\n  return {\n    url,\n    params: {\n      ...params,\n      follow: false\n    }\n  };\n}\n\n/**\n * Generates the displayClick tagging info.\n *\n * @param displayTaggingUrl - The url containing the displayClick tagging info.\n * @returns The object with the tagging info.\n *\n * @public\n */\nexport function getDisplayClickTagging(displayTaggingUrl: string): TaggingRequest {\n  const displayClickTagging = getTaggingInfoFromUrl(displayTaggingUrl);\n  const displayClickTaggingParams = displayClickTagging.params;\n\n  displayClickTaggingParams.displayId = displayClickTaggingParams.q ?? 'no_query';\n  delete displayClickTaggingParams.q;\n\n  return displayClickTagging;\n}\n\n/**\n * Returns the base url path and an object with the query parameters.\n *\n * @param url - The url string to manipulate.\n *\n * @returns The object with the url information.\n *\n * @public\n */\nexport function extractUrlParameters(url: string): {\n  url: string;\n  params?: Record<string, string[] | string>;\n} {\n  const searchParams = new Map<string, string | string[]>();\n  try {\n    const urlObject = new URL(url);\n    urlObject.searchParams.forEach((value, key) => {\n      const param = searchParams.get(key);\n      if (Array.isArray(param)) {\n        searchParams.set(key, [...param, value]);\n      } else if (param) {\n        searchParams.set(key, [param, value]);\n      } else {\n        searchParams.set(key, value);\n      }\n    });\n    return {\n      url: `${urlObject.origin}${urlObject.pathname}`,\n      params: Object.fromEntries(searchParams)\n    };\n  } catch (e) {\n    //eslint-disable-next-line no-console\n    console.warn('Invalid url', url); // TODO Use Empathy's logger\n    return {\n      url\n    };\n  }\n}\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { Banner } from '@empathyco/x-types';\nimport { getTaggingInfoFromUrl } from '../../mappers/url.utils';\nimport { PlatformBanner } from '../../types/models/banner.model';\n\n/**\n * Default implementation for the BannerSchema.\n *\n * @public\n */\nexport const bannerSchema = createMutableSchema<PlatformBanner, Banner>({\n  id: 'id',\n  title: 'title',\n  url: 'url',\n  image: 'image_url',\n  position: 'position',\n  modelName: () => 'Banner',\n  tagging: {\n    query: ({ tagging }) => getTaggingInfoFromUrl(tagging?.query ?? ''),\n    click: ({ tagging }) => getTaggingInfoFromUrl(tagging?.click ?? '')\n  }\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { HierarchicalFilter } from '@empathyco/x-types';\nimport { PlatformHierarchicalFilter } from '../../../types/models/facet.model';\n\n/**\n * Default implementation for the HierarchicalFilterSchema.\n *\n * @public\n */\nexport const hierarchicalFilterSchema = createMutableSchema<\n  PlatformHierarchicalFilter,\n  HierarchicalFilter\n>({\n  facetId: (_, $context) => $context?.facetId as string,\n  label: 'value',\n  id: 'filter',\n  totalResults: 'count',\n  parentId: (_, $context) => ($context?.parentId as string) ?? null,\n  selected: () => false,\n  modelName: () => 'HierarchicalFilter',\n  children: {\n    $path: 'children.values',\n    $subSchema: '$self',\n    $context: {\n      parentId: 'filter'\n    }\n  }\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { NumberRangeFilter } from '@empathyco/x-types';\nimport { PlatformFilter } from '../../../types/models/facet.model';\n\n/**\n * Default implementation for the NumberFilterSchema.\n *\n * @public\n */\nexport const numberFilterSchema = createMutableSchema<PlatformFilter, NumberRangeFilter>({\n  id: 'filter',\n  facetId: (_, $context) => $context?.facetId as string,\n  label: 'value',\n  totalResults: 'count',\n  selected: () => false,\n  modelName: () => 'NumberRangeFilter',\n  range: {\n    min: ({ value }) => {\n      const min = Number(value.split('-')[0]);\n      return Number.isNaN(min) ? null : min;\n    },\n    max: ({ value }) => {\n      const max = Number(value.split('-')[1]);\n      return Number.isNaN(max) ? null : max;\n    }\n  }\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { SimpleFilter } from '@empathyco/x-types';\nimport { PlatformFilter } from '../../../types/models/facet.model';\n\n/**\n * Default implementation for the SimpleFilterSchema.\n *\n * @public\n */\nexport const simpleFilterSchema = createMutableSchema<PlatformFilter, SimpleFilter>({\n  facetId: (_, $context) => $context?.facetId as string,\n  label: 'value',\n  id: 'filter',\n  totalResults: 'count',\n  selected: () => false,\n  modelName: () => 'SimpleFilter'\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { EditableNumberRangeFilter } from '@empathyco/x-types';\nimport { PlatformFilter } from '../../../types/models/facet.model';\n\n/**\n * Default implementation for the NumberFilterSchema.\n *\n * @public\n */\nexport const editableNumberFilterSchema = createMutableSchema<\n  PlatformFilter,\n  EditableNumberRangeFilter\n>({\n  id: 'filter',\n  facetId: (_, $context) => $context?.facetId as string,\n  selected: () => false,\n  modelName: () => 'EditableNumberRangeFilter',\n  range: {\n    min: ({ value }) => {\n      const min = Number(value.split('-')[0]);\n      return Number.isNaN(min) ? null : min;\n    },\n    max: ({ value }) => {\n      const max = Number(value.split('-')[1]);\n      return Number.isNaN(max) ? null : max;\n    }\n  }\n});\n","import { PlatformFacetType } from '../../types/models/facet.model';\nimport { hierarchicalFilterSchema } from '../models/filters/hierarchical-filter.schema';\nimport { numberFilterSchema } from '../models/filters/number-filter.schema';\nimport { simpleFilterSchema } from '../models/filters/simple-filter.schema';\nimport { editableNumberFilterSchema } from '../models/filters/editable-number-filter.schema';\nimport { FacetConfig } from './types';\n\n/**\n * Returns the facet's config.\n *\n * @param type - The facet type to resolve the configuration.\n * @returns The facet's config.\n *\n * @public\n */\nexport function getFacetConfig(type: PlatformFacetType): FacetConfig {\n  const typeConfigs: Record<PlatformFacetType, FacetConfig> = {\n    value: {\n      modelName: 'SimpleFacet',\n      schema: simpleFilterSchema\n    },\n    hierarchical: {\n      modelName: 'HierarchicalFacet',\n      schema: hierarchicalFilterSchema\n    },\n    range: {\n      modelName: 'NumberRangeFacet',\n      schema: numberFilterSchema\n    },\n    'editable-range': {\n      modelName: 'EditableNumberRangeFacet',\n      schema: editableNumberFilterSchema\n    }\n  };\n  return typeConfigs[type] ?? typeConfigs.value;\n}\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport {\n  EditableNumberRangeFacet,\n  HierarchicalFacet,\n  NumberRangeFacet,\n  SimpleFacet\n} from '@empathyco/x-types';\nimport { PlatformFacet } from '../../types/models/facet.model';\nimport { getFacetConfig } from '../facets/utils';\n\n/**\n * Default implementation for the FacetSchema.\n *\n * @public\n */\nexport const facetSchema = createMutableSchema<\n  PlatformFacet,\n  HierarchicalFacet | NumberRangeFacet | SimpleFacet | EditableNumberRangeFacet\n>({\n  id: 'facet',\n  label: 'facet',\n  modelName: ({ type }) => getFacetConfig(type).modelName as any,\n  filters: {\n    $path: 'values',\n    $subSchema: ({ type }) => getFacetConfig(type).schema,\n    $context: {\n      facetId: 'facet'\n    }\n  }\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { Result } from '@empathyco/x-types';\nimport { getDisplayClickTagging, getTaggingInfoFromUrl } from '../../mappers/url.utils';\nimport { PlatformResult } from '../../types/models/result.model';\n\n/**\n * Default implementation for the ResultSchema.\n *\n * @public\n */\nexport const resultSchema = createMutableSchema<PlatformResult, Result>({\n  id: '__id',\n  images: '__images',\n  name: '__name',\n  url: '__url',\n  identifier: {\n    value: '__externalId'\n  },\n  rating: {\n    value: () => null\n  },\n  price: {\n    value: '__prices.current.value',\n    originalValue: ({ __prices: rawPrices }) =>\n      rawPrices.previous?.value ?? rawPrices.current.value,\n    futureValue: ({ __prices: rawPrices }) => rawPrices.future?.value ?? rawPrices.current.value,\n    hasDiscount: ({ __prices: rawPrices }) =>\n      rawPrices.current.value < (rawPrices.previous?.value ?? rawPrices.current.value)\n  },\n  type: () => 'Default',\n  modelName: () => 'Result',\n  isWishlisted: () => false,\n  tagging: {\n    $path: 'tagging',\n    $subSchema: {\n      add2cart: ({ add2cart }) => getTaggingInfoFromUrl(add2cart),\n      checkout: ({ checkout }) => getTaggingInfoFromUrl(checkout),\n      click: ({ click }) => getTaggingInfoFromUrl(click),\n      displayClick: ({ displayClick }) => getDisplayClickTagging(displayClick)\n    }\n  }\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { PartialResult } from '@empathyco/x-types';\nimport { PlatformPartialResult } from '../../types/models/partials.model';\nimport { resultSchema } from './result.schema';\n\n/**\n * Default implementation for the PartialResultsSchema.\n *\n * @public\n */\nexport const partialResultsSchema = createMutableSchema<PlatformPartialResult, PartialResult>({\n  query: 'term',\n  results: {\n    $path: 'content',\n    $subSchema: resultSchema\n  },\n  totalResults: 'numFound'\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { Promoted } from '@empathyco/x-types';\nimport { getTaggingInfoFromUrl } from '../../mappers/url.utils';\nimport { PlatformPromoted } from '../../types/models/promoted.model';\n\n/**\n * Default implementation for the PromotedSchema.\n *\n * @public\n */\nexport const promotedSchema = createMutableSchema<PlatformPromoted, Promoted>({\n  id: 'id',\n  url: 'url',\n  title: 'title',\n  image: 'image_url',\n  position: 'position',\n  modelName: () => 'Promoted',\n  tagging: {\n    query: ({ tagging }) => getTaggingInfoFromUrl(tagging?.query ?? '')\n  }\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { Redirection } from '@empathyco/x-types';\nimport { getTaggingInfoFromUrl } from '../../mappers/url.utils';\nimport { PlatformRedirection } from '../../types/models/redirection.model';\n\n/**\n * Default implementation for the RedirectionSchema.\n *\n * @public\n */\nexport const redirectionSchema = createMutableSchema<PlatformRedirection, Redirection>({\n  id: 'id',\n  url: 'url',\n  modelName: () => 'Redirection',\n  tagging: {\n    click: ({ tagging }) => getTaggingInfoFromUrl(tagging?.click ?? '')\n  }\n});\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { SearchResponse } from '@empathyco/x-types';\nimport { PlatformSearchResponse } from '../../types/responses/search-response.model';\nimport { searchResponseSchema } from '../../schemas/responses/search-response.schema';\n\n/**\n * Default implementation for the SearchResponseMapper.\n *\n * @public\n */\nexport const searchResponseMapper = schemaMapperFactory<PlatformSearchResponse, SearchResponse>(\n  searchResponseSchema\n);\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { SearchResponse } from '@empathyco/x-types';\nimport { getTaggingInfoFromUrl } from '../../mappers/url.utils';\nimport { PlatformSearchResponse } from '../../types/responses/search-response.model';\nimport { bannerSchema } from '../models/banner.schema';\nimport { facetSchema } from '../models/facet.schema';\nimport { partialResultsSchema } from '../models/partial-results.schema';\nimport { promotedSchema } from '../models/promoted.schema';\nimport { redirectionSchema } from '../models/redirection.schema';\nimport { resultSchema } from '../models/result.schema';\n\n/**\n * Default implementation for the SearchResponseSchema.\n *\n * @public\n */\nexport const searchResponseSchema = createMutableSchema<PlatformSearchResponse, SearchResponse>({\n  results: {\n    $path: 'catalog.content',\n    $subSchema: resultSchema\n  },\n  facets: {\n    $path: 'catalog.facets',\n    $subSchema: facetSchema\n  },\n  totalResults: 'catalog.numFound',\n  spellcheck: 'catalog.spellchecked',\n  banners: {\n    $path: 'banner.content',\n    $subSchema: bannerSchema\n  },\n  promoteds: {\n    $path: 'promoted.content',\n    $subSchema: promotedSchema\n  },\n  redirections: {\n    $path: 'direct.content',\n    $subSchema: redirectionSchema\n  },\n  partialResults: {\n    $path: 'catalog.partials',\n    $subSchema: partialResultsSchema\n  },\n  queryTagging: ({ catalog }) => getTaggingInfoFromUrl(catalog?.tagging?.query)\n});\n","import { endpointAdapterFactory } from '@empathyco/x-adapter';\nimport { SearchRequest, SearchResponse } from '@empathyco/x-types';\nimport { searchRequestMapper } from '../mappers/requests/search-request.mapper';\nimport { searchResponseMapper } from '../mappers/responses/search-response.mapper';\n\n/**\n * Default adapter for the search endpoint.\n *\n * @public\n */\nexport const searchEndpointAdapter = endpointAdapterFactory<SearchRequest, SearchResponse>({\n  endpoint:\n    'https://api.{extraParams.env(.)}empathy.co/search/v1/query/{extraParams.instance}/search',\n  requestMapper: searchRequestMapper,\n  responseMapper: searchResponseMapper,\n  defaultRequestOptions: {\n    id: 'search',\n    parameters: {\n      internal: true\n    }\n  }\n});\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { PopularSearchesRequest } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { popularSearchesRequestSchema } from '../../schemas/requests/popular-searches-request.schema';\n// eslint-disable-next-line max-len\nimport { PlatformPopularSearchesRequest } from '../../types/requests/popular-searches-request.model';\n\n/**\n * Default implementation for the PopularSearchesRequestMapper.\n *\n * @public\n */\nexport const popularSearchesRequestMapper = schemaMapperFactory<\n  PopularSearchesRequest,\n  PlatformPopularSearchesRequest\n>(popularSearchesRequestSchema);\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { PopularSearchesRequest } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { PlatformPopularSearchesRequest } from '../../types/requests/popular-searches-request.model';\n\n/**\n * Default implementation for the PopularSearchesRequestSchema.\n *\n * @public\n */\nexport const popularSearchesRequestSchema = createMutableSchema<\n  PopularSearchesRequest,\n  PlatformPopularSearchesRequest\n>({\n  start: 'start',\n  rows: 'rows',\n  extraParams: 'extraParams'\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { Suggestion } from '@empathyco/x-types';\nimport { PlatformSuggestion } from '../../types/models/suggestion.model';\n\n/**\n * Default implementation for the SuggestionSchema.\n *\n * @public\n */\nexport const suggestionSchema = createMutableSchema<PlatformSuggestion, Suggestion>({\n  query: ({ title_raw, keywords }) => title_raw ?? keywords,\n  key: ({ title_raw, keywords }) => title_raw ?? keywords,\n  modelName: (_, $context) =>\n    $context?.requestParameters?.query ? 'QuerySuggestion' : 'PopularSearch',\n  facets: () => [],\n  isCurated: () => false\n});\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { PopularSearchesResponse } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { popularSearchesResponseSchema } from '../../schemas/responses/popular-searches-response.schema';\n// eslint-disable-next-line max-len\nimport { PlatformPopularSearchesResponse } from '../../types/responses/popular-searches-response.model';\n\n/**\n * Default implementation for the PopularSearchesResponseMapper.\n *\n * @public\n */\nexport const popularSearchesResponseMapper = schemaMapperFactory<\n  PlatformPopularSearchesResponse,\n  PopularSearchesResponse\n>(popularSearchesResponseSchema);\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { PopularSearchesResponse } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { PlatformPopularSearchesResponse } from '../../types/responses/popular-searches-response.model';\nimport { suggestionSchema } from '../models/suggestion.schema';\n\n/**\n * Default implementation for the PopularSearchesResponseSchema.\n *\n * @public\n */\nexport const popularSearchesResponseSchema = createMutableSchema<\n  PlatformPopularSearchesResponse,\n  PopularSearchesResponse\n>({\n  suggestions: {\n    $path: 'topTrends.content',\n    $subSchema: suggestionSchema\n  }\n});\n","import { endpointAdapterFactory } from '@empathyco/x-adapter';\nimport { PopularSearchesRequest, PopularSearchesResponse } from '@empathyco/x-types';\nimport { popularSearchesRequestMapper } from '../mappers/requests/popular-searches-request.mapper';\n// eslint-disable-next-line max-len\nimport { popularSearchesResponseMapper } from '../mappers/responses/popular-searches-response.mapper';\n\n/**\n * Default adapter for the popular searches endpoint.\n *\n * @public\n */\nexport const popularSearchesEndpointAdapter = endpointAdapterFactory<\n  PopularSearchesRequest,\n  PopularSearchesResponse\n>({\n  endpoint:\n    'https://api.{extraParams.env(.)}empathy.co/search/v1/query/{extraParams.instance}/empathize',\n  requestMapper: popularSearchesRequestMapper,\n  responseMapper: popularSearchesResponseMapper,\n  defaultRequestOptions: {\n    id: 'popular-searches',\n    parameters: {\n      internal: true\n    }\n  }\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { RecommendationsRequest } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { PlatformRecommendationsRequest } from '../../types/requests/recommendations-request.model';\n\n/**\n * Default implementation for the RecommendationsRequestSchema.\n *\n * @public\n */\nexport const recommendationsRequestSchema = createMutableSchema<\n  RecommendationsRequest,\n  PlatformRecommendationsRequest\n>({\n  start: 'start',\n  rows: 'rows',\n  origin: 'origin',\n  extraParams: 'extraParams'\n});\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { RecommendationsRequest } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { recommendationsRequestSchema } from '../../schemas/requests/recommendations-request.schema';\n// eslint-disable-next-line max-len\nimport { PlatformRecommendationsRequest } from '../../types/requests/recommendations-request.model';\n\n/**\n * Default implementation for the RecommendationsRequestMapper.\n *\n * @public\n */\nexport const recommendationsRequestMapper = schemaMapperFactory<\n  RecommendationsRequest,\n  PlatformRecommendationsRequest\n>(recommendationsRequestSchema);\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { RecommendationsResponse } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { recommendationsResponseSchema } from '../../schemas/responses/recommendations-response.schema';\n// eslint-disable-next-line max-len\nimport { PlatformRecommendationsResponse } from '../../types/responses/recommendations-response.model';\n\n/**\n * Default implementation for the RecommendationsResponseMapper.\n *\n * @public\n */\nexport const recommendationsResponseMapper = schemaMapperFactory<\n  PlatformRecommendationsResponse,\n  RecommendationsResponse\n>(recommendationsResponseSchema);\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { RecommendationsResponse } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { PlatformRecommendationsResponse } from '../../types/responses/recommendations-response.model';\nimport { resultSchema } from '../models/result.schema';\n\n/**\n * Default implementation for the RecommendationsResponseSchema.\n *\n * @public\n */\nexport const recommendationsResponseSchema = createMutableSchema<\n  PlatformRecommendationsResponse,\n  RecommendationsResponse\n>({\n  results: {\n    $path: 'topclicked.content',\n    $subSchema: resultSchema\n  }\n});\n","import { endpointAdapterFactory } from '@empathyco/x-adapter';\nimport { RecommendationsRequest, RecommendationsResponse } from '@empathyco/x-types';\nimport { recommendationsRequestMapper } from '../mappers/requests/recommendations-request.mapper';\n// eslint-disable-next-line max-len\nimport { recommendationsResponseMapper } from '../mappers/responses/recommendations-response.mapper';\n\n/**\n * Default adapter for the recommendations' endpoint.\n *\n * @public\n */\nexport const recommendationsEndpointAdapter = endpointAdapterFactory<\n  RecommendationsRequest,\n  RecommendationsResponse\n>({\n  endpoint:\n    'https://api.{extraParams.env(.)}empathy.co/search/v1/query/{extraParams.instance}/topclicked',\n  requestMapper: recommendationsRequestMapper,\n  responseMapper: recommendationsResponseMapper,\n  defaultRequestOptions: {\n    id: 'recommendations',\n    parameters: {\n      internal: true\n    }\n  }\n});\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { NextQueriesRequest } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { nextQueriesRequestSchema } from '../../schemas/requests/next-queries-request.schema';\nimport { PlatformNextQueriesRequest } from '../../types/requests/next-queries-request.model';\n\n/**\n * Default implementation for the NextQueriesRequestMapper.\n *\n * @public\n */\nexport const nextQueriesRequestMapper = schemaMapperFactory<\n  NextQueriesRequest,\n  PlatformNextQueriesRequest\n>(nextQueriesRequestSchema);\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { NextQueriesRequest } from '@empathyco/x-types';\nimport { PlatformNextQueriesRequest } from '../../types/requests/next-queries-request.model';\n\n/**\n * Default implementation for the NextQueriesRequestSchema.\n *\n * @public\n */\nexport const nextQueriesRequestSchema = createMutableSchema<\n  NextQueriesRequest,\n  PlatformNextQueriesRequest\n>({\n  query: 'query',\n  extraParams: 'extraParams'\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { IdentifierResultsResponse } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { PlatformIdentifierResultsResponse } from '../../types/responses/identifier-results-response.model';\nimport { resultSchema } from '../models/result.schema';\n\n/**\n * Default implementation for the IdentifierResultsResponseSchema.\n *\n * @public\n */\nexport const identifierResultsResponseSchema = createMutableSchema<\n  PlatformIdentifierResultsResponse,\n  IdentifierResultsResponse\n>({\n  results: {\n    $path: 'catalog.content',\n    $subSchema: resultSchema\n  }\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { NextQuery } from '@empathyco/x-types';\nimport { PlatformNextQuery } from '../../types/models/next-query.model';\n\n/**\n * Default implementation for the NextQuerySchema.\n *\n * @public\n */\nexport const nextQuerySchema = createMutableSchema<PlatformNextQuery, NextQuery>({\n  query: 'query',\n  results: () => [],\n  facets: () => [],\n  modelName: () => 'NextQuery',\n  totalResults: () => 0,\n  isCurated: ({ source }) => source === 'CURATED'\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { NextQueriesResponse } from '@empathyco/x-types';\nimport { PlatformNextQueriesResponse } from '../../types/responses/next-queries-response.model';\nimport { nextQuerySchema } from '../models/next-query.schema';\n\n/**\n * Default implementation for the NextQueriesResponseSchema.\n *\n * @public\n */\nexport const nextQueriesResponseSchema = createMutableSchema<\n  PlatformNextQueriesResponse,\n  NextQueriesResponse\n>({\n  nextQueries: {\n    $path: 'data.nextqueries',\n    $subSchema: nextQuerySchema\n  }\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { QuerySuggestionsResponse } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { PlatformQuerySuggestionsResponse } from '../../types/responses/query-suggestions-response.model';\nimport { suggestionSchema } from '../models/suggestion.schema';\n\n/**\n * Default implementation for the QuerySuggestionsResponseSchema.\n *\n * @public\n */\nexport const querySuggestionsResponseSchema = createMutableSchema<\n  PlatformQuerySuggestionsResponse,\n  QuerySuggestionsResponse\n>({\n  suggestions: {\n    $path: 'topTrends.content',\n    $subSchema: suggestionSchema\n  }\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { RelatedTag } from '@empathyco/x-types';\nimport { PlatformRelatedTag } from '../../types/models/related-tag.model';\n\n/**\n * Default implementation for the RelatedTagSchema.\n *\n * @public\n */\nexport const relatedTagSchema = createMutableSchema<PlatformRelatedTag, RelatedTag>({\n  query: 'query',\n  tag: 'tag',\n  modelName: () => 'RelatedTag',\n  isCurated: ({ source }) => source === 'CURATED'\n});\n","import { createMutableSchema, Schema } from '@empathyco/x-adapter';\nimport { RelatedTagsResponse } from '@empathyco/x-types';\nimport { PlatformRelatedTagsResponse } from '../../types/responses/related-tags-response.model';\nimport { relatedTagSchema } from '../models/related-tag.schema';\n\n/**\n * Default implementation for the RelatedTagsResponseSchema.\n *\n * @public\n */\nexport const relatedTagsResponseSchema = createMutableSchema(<\n  Schema<PlatformRelatedTagsResponse, RelatedTagsResponse>\n>{\n  relatedTags: {\n    $path: 'data.relatedtags',\n    $subSchema: relatedTagSchema\n  }\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { SemanticQuery } from '@empathyco/x-types';\nimport { PlatformSemanticQuery } from '../../types';\n\n/**\n * Default implementation for the SemanticQuery schema.\n *\n * @public\n */\nexport const semanticQuerySchema = createMutableSchema<PlatformSemanticQuery, SemanticQuery>({\n  query: 'query',\n  modelName: () => 'SemanticQuery',\n  distance: 'distance'\n});\n","import { createMutableSchema, Schema } from '@empathyco/x-adapter';\nimport { SemanticQueriesResponse } from '@empathyco/x-types';\nimport { semanticQuerySchema } from '../models/semantic-query.schema';\n// eslint-disable-next-line max-len\nimport { PlatformSemanticQueriesResponse } from '../../types/responses/semantic-queries-response.model';\n\n/**\n * Default implementation for the SemanticQueriesResponseSchema.\n *\n * @public\n */\nexport const semanticQueriesResponseSchema = createMutableSchema(<\n  Schema<PlatformSemanticQueriesResponse, SemanticQueriesResponse>\n>{\n  semanticQueries: {\n    $path: 'data.candidates',\n    $subSchema: semanticQuerySchema\n  }\n});\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { NextQueriesResponse } from '@empathyco/x-types';\nimport { nextQueriesResponseSchema } from '../../schemas/responses';\nimport { PlatformNextQueriesResponse } from '../../types/responses/next-queries-response.model';\n\n/**\n * Default implementation for the NextQueriesResponseMapper.\n *\n * @public\n */\nexport const nextQueriesResponseMapper = schemaMapperFactory<\n  PlatformNextQueriesResponse,\n  NextQueriesResponse\n>(nextQueriesResponseSchema);\n","import { endpointAdapterFactory } from '@empathyco/x-adapter';\nimport { NextQueriesRequest, NextQueriesResponse } from '@empathyco/x-types';\nimport { nextQueriesRequestMapper } from '../mappers/requests/next-queries-request.mapper';\nimport { nextQueriesResponseMapper } from '../mappers/responses/next-queries-response.mapper';\n\n/**\n * This endpoint does not support pagination in the request.\n *\n * @public\n */\nexport const nextQueriesEndpointAdapter = endpointAdapterFactory<\n  NextQueriesRequest,\n  NextQueriesResponse\n>({\n  endpoint: 'https://api.{extraParams.env(.)}empathy.co/nextqueries/{extraParams.instance}',\n  requestMapper: nextQueriesRequestMapper,\n  responseMapper: nextQueriesResponseMapper,\n  defaultRequestOptions: {\n    id: 'next-queries',\n    parameters: {\n      internal: true\n    }\n  }\n});\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { RelatedTagsRequest } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { relatedTagsRequestSchema } from '../../schemas/requests/related-tags-request.schema';\nimport { PlatformRelatedTagsRequest } from '../../types/requests/related-tags-request.model';\n\n/**\n * Default implementation for the RelatedTagsRequestMapper.\n *\n * @public\n */\nexport const relatedTagsRequestMapper = schemaMapperFactory<\n  RelatedTagsRequest,\n  PlatformRelatedTagsRequest\n>(relatedTagsRequestSchema);\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { RelatedTagsRequest } from '@empathyco/x-types';\nimport { PlatformRelatedTagsRequest } from '../../types/requests/related-tags-request.model';\n\n/**\n * Default implementation for the RelatedTagsRequestSchema.\n *\n * @public\n */\nexport const relatedTagsRequestSchema = createMutableSchema<\n  RelatedTagsRequest,\n  PlatformRelatedTagsRequest\n>({\n  query: 'query',\n  extraParams: 'extraParams'\n});\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { RelatedTagsResponse } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { relatedTagsResponseSchema } from '../../schemas/responses/related-tags-response.schema';\nimport { PlatformRelatedTagsResponse } from '../../types/responses/related-tags-response.model';\n\n/**\n * Default implementation for the RelatedTagsResponseMapper.\n *\n * @public\n */\nexport const relatedTagsResponseMapper = schemaMapperFactory<\n  PlatformRelatedTagsResponse,\n  RelatedTagsResponse\n>(relatedTagsResponseSchema);\n","import { endpointAdapterFactory } from '@empathyco/x-adapter';\nimport { RelatedTagsRequest, RelatedTagsResponse } from '@empathyco/x-types';\nimport { relatedTagsRequestMapper } from '../mappers/requests/related-tags-request.mapper';\nimport { relatedTagsResponseMapper } from '../mappers/responses/related-tags-response.mapper';\n\n/**\n * This endpoint does not support pagination in the request.\n *\n * @public\n */\nexport const relatedTagsEndpointAdapter = endpointAdapterFactory<\n  RelatedTagsRequest,\n  RelatedTagsResponse\n>({\n  endpoint: 'https://api.{extraParams.env(.)}empathy.co/relatedtags/{extraParams.instance}',\n  requestMapper: relatedTagsRequestMapper,\n  responseMapper: relatedTagsResponseMapper,\n  defaultRequestOptions: {\n    id: 'related-tags',\n    parameters: {\n      internal: true\n    }\n  }\n});\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { IdentifierResultsRequest } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { identifierResultsRequestSchema } from '../../schemas/requests/identifier-results-request.schema';\n// eslint-disable-next-line max-len\nimport { PlatformIdentifierResultsRequest } from '../../types/requests/identifier-results-request.model';\n\n/**\n * Default mapper for IdentifierResultsRequest.\n *\n * @public\n */\nexport const identifierResultsRequestMapper = schemaMapperFactory<\n  IdentifierResultsRequest,\n  PlatformIdentifierResultsRequest\n>(identifierResultsRequestSchema);\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { IdentifierResultsRequest } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { PlatformIdentifierResultsRequest } from '../../types/requests/identifier-results-request.model';\n\n/**\n * Default implementation for the IdentifierResultsRequestSchema.\n *\n * @public\n */\nexport const identifierResultsRequestSchema = createMutableSchema<\n  IdentifierResultsRequest,\n  PlatformIdentifierResultsRequest\n>({\n  query: 'query',\n  origin: 'origin',\n  start: 'start',\n  rows: 'rows',\n  extraParams: 'extraParams'\n});\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { IdentifierResultsResponse } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { identifierResultsResponseSchema } from '../../schemas/responses/identifier-results-response.schema';\n// eslint-disable-next-line max-len\nimport { PlatformIdentifierResultsResponse } from '../../types/responses/identifier-results-response.model';\n\n/**\n * Default implementation for the IdentifierResultsResponseMapper.\n *\n * @public\n */\nexport const identifierResultsResponseMapper = schemaMapperFactory<\n  PlatformIdentifierResultsResponse,\n  IdentifierResultsResponse\n>(identifierResultsResponseSchema);\n","import { endpointAdapterFactory } from '@empathyco/x-adapter';\nimport { IdentifierResultsRequest, IdentifierResultsResponse } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { identifierResultsRequestMapper } from '../mappers/requests/identifier-results-request.mapper';\n// eslint-disable-next-line max-len\nimport { identifierResultsResponseMapper } from '../mappers/responses/identifier-results-response.mapper';\n\n/**\n * Default adapter for the identifier results endpoint.\n *\n * @public\n */\nexport const identifierResultsEndpointAdapter = endpointAdapterFactory<\n  IdentifierResultsRequest,\n  IdentifierResultsResponse\n>({\n  endpoint:\n    'https://api.{extraParams.env(.)}empathy.co/search/v1/query/{extraParams.instance}/skusearch',\n  requestMapper: identifierResultsRequestMapper,\n  responseMapper: identifierResultsResponseMapper,\n  defaultRequestOptions: {\n    id: 'identifier-results',\n    parameters: {\n      internal: true\n    }\n  }\n});\n","import { endpointAdapterFactory } from '@empathyco/x-adapter';\nimport { TaggingRequest } from '@empathyco/x-types';\nimport { taggingRequestMapper } from '../mappers/requests/tagging-request.mapper';\n\n/**\n * Default adapter for the tagging endpoint.\n *\n * @public\n */\nexport const taggingEndpointAdapter = endpointAdapterFactory<TaggingRequest, void>({\n  endpoint: ({ url }) => url,\n  requestMapper: taggingRequestMapper,\n  defaultRequestOptions: {\n    id: 'tagging',\n    cancelable: false,\n    properties: { keepalive: true }\n  }\n});\n","import { Mapper } from '@empathyco/x-adapter';\nimport { TaggingRequest } from '@empathyco/x-types';\n\n/**\n * Default implementation for the TaggingRequestMapper.\n *\n * @param params - The tagging request params.\n * @returns The tagging request params.\n *\n * @public\n */\nexport const taggingRequestMapper: Mapper<TaggingRequest, any> = ({ params }: TaggingRequest) =>\n  params;\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { QuerySuggestionsRequest } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { querySuggestionsRequestSchema } from '../../schemas/requests/query-suggestions-request.schema';\n// eslint-disable-next-line max-len\nimport { PlatformQuerySuggestionsRequest } from '../../types/requests/query-suggestions-request.model';\n\n/**\n * Default implementation for the QuerySuggestionsRequestMapper.\n *\n * @public\n */\nexport const querySuggestionsRequestMapper = schemaMapperFactory<\n  QuerySuggestionsRequest,\n  PlatformQuerySuggestionsRequest\n>(querySuggestionsRequestSchema);\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { QuerySuggestionsRequest } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { PlatformQuerySuggestionsRequest } from '../../types/requests/query-suggestions-request.model';\n\n/**\n * Default implementation for the QuerySuggestionsRequestSchema.\n *\n * @public\n */\nexport const querySuggestionsRequestSchema = createMutableSchema<\n  QuerySuggestionsRequest,\n  PlatformQuerySuggestionsRequest\n>({\n  query: 'query',\n  start: 'start',\n  rows: 'rows',\n  extraParams: 'extraParams'\n});\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { QuerySuggestionsResponse } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { querySuggestionsResponseSchema } from '../../schemas/responses/query-suggestions-response.schema';\n// eslint-disable-next-line max-len\nimport { PlatformQuerySuggestionsResponse } from '../../types/responses/query-suggestions-response.model';\n\n/**\n * Default implementation for the QuerySuggestionsResponseMapper.\n *\n * @public\n */\nexport const querySuggestionsResponseMapper = schemaMapperFactory<\n  PlatformQuerySuggestionsResponse,\n  QuerySuggestionsResponse\n>(querySuggestionsResponseSchema);\n","import { endpointAdapterFactory } from '@empathyco/x-adapter';\nimport { QuerySuggestionsRequest, QuerySuggestionsResponse } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { querySuggestionsRequestMapper } from '../mappers/requests/query-suggestions-request.mapper';\n// eslint-disable-next-line max-len\nimport { querySuggestionsResponseMapper } from '../mappers/responses/query-suggestions-response.mapper';\n\n/**\n * Default adapter for the query suggestions endpoint.\n *\n * @public\n */\nexport const querySuggestionsEndpointAdapter = endpointAdapterFactory<\n  QuerySuggestionsRequest,\n  QuerySuggestionsResponse\n>({\n  endpoint:\n    'https://api.{extraParams.env(.)}empathy.co/search/v1/query/{extraParams.instance}/empathize',\n  requestMapper: querySuggestionsRequestMapper,\n  responseMapper: querySuggestionsResponseMapper,\n  defaultRequestOptions: {\n    id: 'query-suggestions',\n    parameters: {\n      internal: true\n    }\n  }\n});\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { SemanticQueriesRequest } from '@empathyco/x-types';\nimport { PlatformSemanticQueriesRequest } from '../../types';\n// eslint-disable-next-line max-len\nimport { semanticQueriesRequestSchema } from '../../schemas/requests/semantic-queries-request.schema';\n\n/**.\n * Default implementation for the SemanticQueriesRequestMapper\n *\n * @public\n */\nexport const semanticQueriesRequestMapper = schemaMapperFactory<\n  SemanticQueriesRequest,\n  PlatformSemanticQueriesRequest\n>(semanticQueriesRequestSchema);\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { SemanticQueriesRequest } from '@empathyco/x-types';\nimport { PlatformSemanticQueriesRequest } from '../../types';\n\n/**\n * Default implementation for the SemanticQueriesRequestSchema.\n *\n * @public\n */\nexport const semanticQueriesRequestSchema = createMutableSchema<\n  SemanticQueriesRequest,\n  PlatformSemanticQueriesRequest\n>({\n  q: 'query',\n  extraParams: 'extraParams'\n});\n","import { schemaMapperFactory } from '@empathyco/x-adapter';\nimport { SemanticQueriesResponse } from '@empathyco/x-types';\n// eslint-disable-next-line max-len\nimport { PlatformSemanticQueriesResponse } from '../../types/responses/semantic-queries-response.model';\nimport { semanticQueriesResponseSchema } from '../../schemas';\n\n/**\n * Default implementation for the SemanticQueriesResponseMapper.\n *\n * @public\n */\nexport const semanticQueriesResponseMapper = schemaMapperFactory<\n  PlatformSemanticQueriesResponse,\n  SemanticQueriesResponse\n>(semanticQueriesResponseSchema);\n","/* eslint-disable max-len */\nimport { searchEndpointAdapter } from './endpoint-adapters/search.endpoint-adapter';\nimport { PlatformAdapter } from './types/platform-adapter.types';\nimport { popularSearchesEndpointAdapter } from './endpoint-adapters/popular-searches.endpoint-adapter';\nimport { recommendationsEndpointAdapter } from './endpoint-adapters/recommendations.endpoint-adapter';\nimport { nextQueriesEndpointAdapter } from './endpoint-adapters/next-queries.endpoint-adapter';\nimport { relatedTagsEndpointAdapter } from './endpoint-adapters/related-tags.endpoint-adapter';\nimport { identifierResultsEndpointAdapter } from './endpoint-adapters/identifier-results.endpoint-adapter';\nimport { taggingEndpointAdapter } from './endpoint-adapters/tagging.endpoint-adapter';\nimport { querySuggestionsEndpointAdapter } from './endpoint-adapters/query-suggestions.endpoint-adapter';\nimport { semanticQueriesEndpointAdapter } from './endpoint-adapters/semantic-queries.endpoint-adapter';\n/* eslint-enable max-len */\n\n/**\n * Default implementation for the PlatformAdapter.\n *\n * @public\n */\nexport const platformAdapter: PlatformAdapter = {\n  search: searchEndpointAdapter,\n  popularSearches: popularSearchesEndpointAdapter,\n  recommendations: recommendationsEndpointAdapter,\n  nextQueries: nextQueriesEndpointAdapter,\n  querySuggestions: querySuggestionsEndpointAdapter,\n  relatedTags: relatedTagsEndpointAdapter,\n  identifierResults: identifierResultsEndpointAdapter,\n  tagging: taggingEndpointAdapter,\n  semanticQueries: semanticQueriesEndpointAdapter\n};\n","import { endpointAdapterFactory } from '@empathyco/x-adapter';\nimport { SemanticQueriesResponse, SemanticQueriesRequest } from '@empathyco/x-types';\nimport { semanticQueriesRequestMapper } from '../mappers/requests/semantic-queries-request.mapper';\n// eslint-disable-next-line max-len\nimport { semanticQueriesResponseMapper } from '../mappers/responses/semantic-queries-response.mapper';\n\n/**\n * Default adapter for the semantic queries endpoint.\n *\n * @public\n */\nexport const semanticQueriesEndpointAdapter = endpointAdapterFactory<\n  SemanticQueriesRequest,\n  SemanticQueriesResponse\n>({\n  endpoint:\n    'https://api.{extraParams.env(.)}empathy.co/semantics-api/search_single/{extraParams.instance}',\n  requestMapper: semanticQueriesRequestMapper,\n  responseMapper: semanticQueriesResponseMapper,\n  defaultRequestOptions: {\n    id: 'semantic-queries'\n  }\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { Result } from '@empathyco/x-types';\nimport { AlgonomyResult } from '../responses.types';\n\nexport const algonomyResultSchema = createMutableSchema<AlgonomyResult, Result>({\n  id: 'id',\n  name: 'name',\n  url: 'clickUrl',\n  images: ({ imageId }) => [imageId],\n  identifier: {\n    value: 'id'\n  },\n  rating: {\n    value: 'rating'\n  },\n  price: {\n    value: ({ priceCents, salePriceCents }: AlgonomyResult) => salePriceCents ?? priceCents,\n    originalValue: 'priceCents',\n    futureValue: () => 0,\n    hasDiscount: ({ priceCents, salePriceCents }) => salePriceCents < priceCents\n  },\n  type: () => 'Default',\n  modelName: () => 'Result',\n  description: 'description',\n  brand: 'brand',\n  categoryId: 'categoryId',\n  categoryName: 'categoryName',\n  numReviews: 'numReviews',\n  releaseDate: 'releaseDate'\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { Banner } from '@empathyco/x-types';\nimport { AlgonomyLink } from '../responses.types';\n\n/**\n * Default implementation for the PromotedSchema.\n *\n * @public\n */\nexport const algonomyBannerSchema = createMutableSchema<AlgonomyLink, Banner>({\n  id: 'id',\n  url: 'url',\n  title: ({ title }) => title ?? '',\n  image: ({ image_url }) => image_url ?? '',\n  modelName: () => 'Banner'\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { Promoted } from '@empathyco/x-types';\nimport { AlgonomyLink } from '../responses.types';\n\n/**\n * Default implementation for the PromotedSchema.\n *\n * @public\n */\nexport const algonomyPromotedSchema = createMutableSchema<AlgonomyLink, Promoted>({\n  id: 'id',\n  url: 'url',\n  title: ({ title }) => title ?? '',\n  image: ({ image_url }) => image_url ?? '',\n  position: () => 0,\n  modelName: () => 'Promoted'\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { Redirection } from '@empathyco/x-types';\nimport { AlgonomyLink } from '../responses.types';\n\n/**\n * Default implementation for the RedirectionSchema.\n *\n * @public\n */\nexport const algonomyRedirectionSchema = createMutableSchema<AlgonomyLink, Redirection>({\n  id: 'id',\n  url: 'url',\n  modelName: () => 'Redirection'\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { SimpleFilter } from '@empathyco/x-types';\nimport { AlgonomyFilter } from '../../responses.types';\n\n/**\n * Default implementation for the SimpleFilterSchema.\n *\n * @public\n */\nexport const algonomySimpleFilterSchema = createMutableSchema<AlgonomyFilter, SimpleFilter>({\n  facetId: (_, $context) => $context?.facetId as string,\n  label: 'value',\n  id: 'filter',\n  totalResults: 'count',\n  selected: () => false,\n  modelName: () => 'SimpleFilter'\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { SimpleFacet } from '@empathyco/x-types';\nimport { AlgonomyFacet } from '../responses.types';\nimport { algonomySimpleFilterSchema } from './filters/simple-filter.schema';\n\n/**\n * Default implementation for the FacetSchema.\n *\n * @public\n */\nexport const algonomyFacetSchema = createMutableSchema<AlgonomyFacet, SimpleFacet>({\n  id: 'facet',\n  label: 'facet',\n  // TODO: Don't see any other models from the algonomy's facets\n  modelName: () => 'SimpleFacet',\n  filters: {\n    $path: 'values',\n    $subSchema: algonomySimpleFilterSchema,\n    $context: {\n      facetId: 'facet'\n    }\n  }\n});\n","import { createMutableSchema, MutableSchema, schemaMapperFactory } from '@empathyco/x-adapter';\nimport { SearchResponse } from '@empathyco/x-types';\nimport { AlgonomySearchResponse } from '../responses.types';\nimport { algonomyResultSchema } from './result.schema';\nimport { algonomyBannerSchema } from './banner.schema';\nimport { algonomyPromotedSchema } from './promoteds.schema';\nimport { algonomyRedirectionSchema } from './redirection.schema';\nimport { algonomyFacetSchema } from './facets.schema';\n\nconst placementMapper = <T, K>(placementProperty: Array<T>, schema: MutableSchema<T, K>): K[] => {\n  return placementProperty.map(element => schemaMapperFactory(schema)(element, {}));\n};\n\n/**\n * Typing for the mutable schema is set to 'any' in the algonomy side due to type recursion\n * complexity cousing problems.\n * Setting it manually in the mapping functions.\n */\n// TODO: I'm assuming that there's always just 1 placement inside placements\nexport const algonomySearchResponseSchema = createMutableSchema<any, SearchResponse>({\n  results: ({ placements }: AlgonomySearchResponse) =>\n    placementMapper(placements[0]?.docs, algonomyResultSchema),\n  facets: ({ placements }: AlgonomySearchResponse) =>\n    placementMapper(placements[0]?.facets, algonomyFacetSchema),\n  totalResults: ({ placements }) => placements[0]?.numFound,\n  spellcheck: ({ placements }: AlgonomySearchResponse) => placements[0]?.spellchecked ?? '',\n  banners: ({ placements }: AlgonomySearchResponse) =>\n    placementMapper(placements[0]?.links.banner, algonomyBannerSchema),\n  promoteds: ({ placements }: AlgonomySearchResponse) =>\n    placementMapper(placements[0]?.links.sponsored, algonomyPromotedSchema),\n  redirections: ({ placements }: AlgonomySearchResponse) =>\n    placementMapper(placements[0]?.links.directlink, algonomyRedirectionSchema),\n  // TODO: implement a way of taking your tagging url and separate the url and params\n  queryTagging: ({ placements }: AlgonomySearchResponse) => ({\n    url: placements[0].searchTrackingUrl,\n    params: {}\n  })\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { isHierarchicalFilter, SearchRequest } from '@empathyco/x-types';\nimport { reduce } from '@empathyco/x-utils';\nimport { AlgonomySearchRequest } from './requests.types';\n\n/**\n * Default implementation for the SearchRequestSchema.\n *\n * @public\n */\nexport const algonomySearchRequestSchema = createMutableSchema<\n  SearchRequest,\n  AlgonomySearchRequest\n>({\n  query: 'query',\n  // TODO: what's the equivalent of placement in x-components? How is the placement generated?\n  placement: ({ extraParams }) => (extraParams?.placement as string) ?? 'search_page.find',\n  start: ({ start }) => start ?? 0,\n  rows: ({ rows }) => rows ?? 0,\n  sort: 'sort',\n  filter: mapFilters,\n  lang: ({ extraParams }) => (extraParams?.lang as string) ?? 'en',\n  extraParams: 'extraParams'\n});\n\n/**\n * Converts the filters to the shape the Platform's API is expecting.\n *\n * @param filters - The filters from our internal request.\n * @example\n * ```ts\n * const filters = {\n *     offer: [\n *     {\n *       facetId: 'offer',\n *       modelName: 'SimpleFilter',\n *       id: 'price:[0 TO 10]',\n *       selected: true,\n *       label: 'In Offer'\n *     } as SimpleFilter\n *   ],\n *     categoryPaths: [\n *     {\n *       facetId: 'categoryPaths',\n *       id: 'categoryIds:ffc61e1e9__be257cb26',\n *       label: 'Fragrance',\n *       modelName: 'HierarchicalFilter',\n *       parentId: 'categoryIds:ffc61e1e9',\n *       selected: true,\n *       totalResults: 1\n *     },\n *     {\n *       facetId: 'categoryPaths',\n *       id: 'categoryIds:ffc61e1e9__fa5ef54f2',\n *       label: 'Fragrance',\n *       modelName: 'HierarchicalFilter',\n *       parentId: 'categoryIds:ffc61e1e9',\n *       selected: true,\n *       totalResults: 1\n *     },\n *     {\n *       children: ['categoryIds:ffc61e1e9__be257cb26', 'categoryIds:ffc61e1e9__fa5ef54f2'],\n *       facetId: 'categoryPaths',\n *       id: 'categoryIds:ffc61e1e9',\n *       label: 'Personal Care',\n *       modelName: 'HierarchicalFilter',\n *       parentId: null,\n *       selected: true,\n *       totalResults: 1\n *     }]\n * };\n *\n * const mappedFilters = mapFilters({ filters });\n * // mappedFilters is [\n * //      'price:[0 TO 10]',\n * //        'categoryIds:ffc61e1e9__be257cb26',\n * //        'categoryIds:ffc61e1e9__fa5ef54f2'\n * //      ];\n *\n * ```\n * @returns The filters ready for the API.\n */\nfunction mapFilters({ filters }: SearchRequest): string[] {\n  return reduce(\n    filters,\n    (accumulator, _, filters) => [\n      ...accumulator,\n      ...filters\n        .filter(\n          filter =>\n            !isHierarchicalFilter(filter) ||\n            !filters.some(child => isHierarchicalFilter(child) && child.parentId === filter.id)\n        )\n        .map(filter => filter.id.toString())\n    ],\n    [] as string[]\n  );\n}\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { QuerySuggestionsRequest } from '@empathyco/x-types';\nimport { AlgonomyQuerySuggestionsRequest } from './requests.types';\n\nexport const algonomyQuerySuggestionsRequestSchema = createMutableSchema<\n  QuerySuggestionsRequest,\n  AlgonomyQuerySuggestionsRequest\n>({\n  query: 'query',\n  start: ({ start }) => start ?? 0,\n  rows: ({ rows }) => rows ?? 0,\n  lang: ({ extraParams }) => (extraParams?.lang as string) ?? 'en',\n  extraParams: 'extraParams'\n});\n","import { createMutableSchema } from '@empathyco/x-adapter';\nimport { Suggestion } from '@empathyco/x-types';\nimport { AlgonomySuggestion } from '../responses.types';\n\nexport const algonomySuggestionSchema = createMutableSchema<AlgonomySuggestion, Suggestion>({\n  query: 'terms',\n  key: 'id',\n  modelName: (_, $context) =>\n    // TODO: If there are other types of suggestions aside from query suggestions,\n    //  change the right side of the ternary\n    $context?.requestParameters?.query ? 'QuerySuggestion' : 'QuerySuggestion',\n  facets: () => [],\n  isCurated: () => false\n});\n","import { createMutableSchema, schemaMapperFactory } from '@empathyco/x-adapter';\nimport { QuerySuggestionsResponse, Suggestion } from '@empathyco/x-types';\nimport { AlgonomyQuerySuggestionsResponse, AlgonomySuggestion } from '../responses.types';\nimport { algonomySuggestionSchema } from './suggestion.schema';\n\nconst mapAlgonomySuggestions = (suggestions: AlgonomySuggestion[]): Suggestion[] => {\n  return suggestions.map(suggestion =>\n    schemaMapperFactory(algonomySuggestionSchema)(suggestion, {})\n  );\n};\n\nexport const algonomyQuerySuggestionsResponseSchema = createMutableSchema<\n  AlgonomyQuerySuggestionsResponse,\n  QuerySuggestionsResponse\n>({\n  suggestions: response => {\n    const algonomySuggestions = Array.isArray(response) ? response : response.suggestions;\n\n    return mapAlgonomySuggestions(algonomySuggestions);\n  }\n});\n","import {\n  platformAdapter,\n  PlatformRecommendationsRequest,\n  recommendationsRequestSchema\n} from '@empathyco/x-adapter-platform';\nimport { RecommendationsRequest } from '@empathyco/x-types';\nimport { endpointAdapterFactory, schemaMapperFactory } from '@empathyco/x-adapter';\nimport { algonomySearchResponseSchema } from './algonomy/responses/search/searchResponse.schema';\nimport { algonomySearchRequestSchema } from './algonomy/requests/search.schema';\nimport { algonomyQuerySuggestionsRequestSchema } from './algonomy/requests/query-suggestion.schema';\n// eslint-disable-next-line max-len\nimport { algonomyQuerySuggestionsResponseSchema } from './algonomy/responses/query-suggestion/query-suggestion.schema';\n\nexport const adapter = platformAdapter;\n\nadapter.search = endpointAdapterFactory({\n  endpoint: 'https://{extraParams.env}.richrelevance.com/rrserver/api/find/v1/{extraParams.apiKey}',\n  requestMapper: schemaMapperFactory(algonomySearchRequestSchema),\n  responseMapper: schemaMapperFactory(algonomySearchResponseSchema),\n  defaultRequestOptions: {\n    id: 'search',\n    parameters: {\n      internal: true\n    }\n  }\n});\n\nadapter.querySuggestions = endpointAdapterFactory({\n  endpoint:\n    // eslint-disable-next-line max-len\n    'https://{extraParams.env}.richrelevance.com/rrserver/api/find/v1/autocomplete/{extraParams.apiKey}',\n  requestMapper: schemaMapperFactory(algonomyQuerySuggestionsRequestSchema),\n  responseMapper: schemaMapperFactory(algonomyQuerySuggestionsResponseSchema)\n});\n\n/* Code sample about how to extend the result mapper with more fields. */\n\ndeclare module '@empathyco/x-types' {\n  export interface Result {\n    description: string;\n    brand: string;\n    categoryId: string[];\n    categoryName: string;\n    numReviews: number;\n    releaseDate: Date;\n  }\n}\n\nrecommendationsRequestSchema.$override<\n  RecommendationsRequest,\n  Partial<PlatformRecommendationsRequest>\n>({\n  // TODO Top clicked demo endpoint breaks if it receives the scope parameter\n  extraParams: ({ extraParams: { scope, ...extraParams } = {} }) => extraParams\n});\n","import { InstallXOptions } from '@empathyco/x-components';\nimport { I18n } from '@empathyco/x-archetype-utils';\nimport App from '../App.vue';\nimport * as messages from '../i18n/messages';\nimport store from '../store';\nimport { adapter } from '../adapter/adapter';\nimport { useDevice } from '../composables/use-device.composable';\n\nconst device = useDevice();\nexport const installXOptions: InstallXOptions = {\n  adapter,\n  store,\n  app: App,\n  xModules: {\n    facets: {\n      config: {\n        filtersStrategyForRequest: 'leaves-only'\n      }\n    },\n    semanticQueries: {\n      config: {\n        threshold: 50,\n        maxItemsToRequest: 10\n      }\n    }\n  },\n  async installExtraPlugins({ vue, snippet }) {\n    const i18n = await I18n.create({\n      locale: snippet.uiLang,\n      device: (snippet.device as string) ?? device.deviceName.value,\n      fallbackLocale: 'en',\n      messages\n    });\n    vue.use(i18n);\n    vue.prototype.$setLocale = i18n.setLocale.bind(i18n);\n    vue.prototype.$setLocaleDevice = i18n.setDevice.bind(i18n);\n\n    return {\n      i18n: i18n.vueI18n\n    };\n  }\n};\n","import { XInstaller } from '@empathyco/x-components';\nimport Vue from 'vue';\nimport { installXOptions } from './x-components/plugin.options';\n\ndeclare global {\n  interface Window {\n    __enableVueDevtools__?: boolean;\n  }\n}\n\nVue.config.productionTip = false;\nVue.config.devtools = window.__enableVueDevtools__ ?? false;\n\nnew XInstaller(installXOptions).init();\n","import { forEach, isFunction } from '@empathyco/x-utils';\nimport Vue, { PluginObject, VueConstructor } from 'vue';\nimport { XBus } from '@empathyco/x-bus';\nimport { XPlugin } from '../../plugins/x-plugin';\nimport { XPluginOptions } from '../../plugins/x-plugin.types';\nimport { NormalisedSnippetConfig, SnippetConfig, XAPI } from '../api/api.types';\nimport { BaseXAPI } from '../api/base-api';\nimport { WireMetadata, XEventsTypes } from '../../wiring/index';\nimport { bus } from '../../plugins/x-bus';\nimport { InitWrapper, InstallXOptions, VueConstructorPartialArgument } from './types';\n\ndeclare global {\n  interface Window {\n    InterfaceX?: XAPI;\n    initX?: (() => SnippetConfig) | SnippetConfig;\n  }\n}\n\n/**\n * The purpose of this class is to offer a quick way to initialize the XComponents in a setup\n * project. It allows to receive all the options in {@link InstallXOptions} which is an extension\n * of {@link XPluginOptions} with all the options for the plugin and some options more.\n *\n * This class does multiple things:\n * 1. Install the {@link XPlugin} with the {@link XPluginOptions}.\n * 2. Creates the public {@link XAPI} and add it to global window.\n * 3. Creates the Vue Application for the customer project.\n *\n * The steps 2 & 3 are optional and depends on the options passed in {@link InstallXOptions}.\n *\n * @example The way to use this class is the next:\n *    1. Create the installer passing in the {@link InstallXOptions}. This only save the options:\n *\n * ```\n *        const installer = new XInstaller(installXOptions)\n * ```\n *\n *    2. Initialize passing the {@link SnippetConfig}. This installs the plugin and creates the App.\n *       There are 3 different ways to do this:\n *\n *        2.1 Using the created installer:\n *\n * ```\n *            installer.init(snippetConfig)\n * ```\n *\n *        2.2 If the API option is enabled (`createAPI` is `true` in {@link InstallXOptions}, or\n *            is not present as the default value is `true`) then this init step can be done with\n *            the Public API:\n *\n * ```\n *            window.InterfaceX.init(snippetConfig)\n * ```\n *\n *        2.3 When the script of the project build is loaded it searches for a global `initX`\n *            variable that the customer must have in their website. This variable can be a\n *            function that returns the {@link SnippetConfig} or an object that contains the\n *            {@link SnippetConfig} itself:\n *\n * ```\n *            window.initX = function() {\n *                 return {\n *                   instance,\n *                   env,\n *                   scope,\n *                   lang,\n *                   uiLang,\n *                   currency,\n *                   consent,\n *                   documentDirection\n *                 };\n *              };\n * ```\n *\n * ```\n *            window.initX = {\n *                 instance,\n *                 env,\n *                 scope,\n *                 lang,\n *                 uiLang,\n *                 currency,\n *                 consent,\n *                 documentDirection\n *               };\n * ```\n *\n * @public\n */\nexport class XInstaller {\n  private api?: XAPI;\n\n  /**\n   * The configuration coming from the snippet {@link SnippetConfig}.\n   *\n   * @internal\n   */\n  protected snippetConfig?: NormalisedSnippetConfig;\n\n  /**\n   * Receives the {@link InstallXOptions} and merges it with the default fallback options. Also\n   * creates the public {@link XAPI}.\n   *\n   * @remarks Auto initializes the Vue application if window.initX is defined as a function or\n   * object specifying the {@link SnippetConfig | snippet config}.\n   *\n   *\n   * @param options - The {@link InstallXOptions}.\n   *\n   * @public\n   */\n  public constructor(protected readonly options: InstallXOptions) {\n    this.createAPI();\n  }\n\n  /**\n   * Creates the public {@link XAPI} using the `api` option from {@link InstallXOptions}. If this\n   * `api` option is not passed, then a default {@link BaseXAPI} is created. To disable the API\n   * creation the value `false` must be passed in the `api` option.\n   *\n   * @internal\n   */\n  protected createAPI(): void {\n    const { api } = this.options;\n    if (api !== false) {\n      this.api = api ?? new BaseXAPI();\n      this.api.setInitCallback(this.init.bind(this));\n      this.api.setSnippetConfigCallback(this.updateSnippetConfig.bind(this));\n      window.InterfaceX = this.api;\n    }\n  }\n\n  /**\n   * Retrieves the {@link SnippetConfig | snippet config} it is defined in the window.initX.\n   *\n   * @returns The snippet config if it is defined or undefined otherwise.\n   *\n   * @internal\n   */\n  private retrieveSnippetConfig(): SnippetConfig | undefined {\n    if (typeof window.initX === 'function') {\n      return window.initX();\n    } else if (typeof window.initX === 'object') {\n      return window.initX;\n    }\n  }\n\n  /**\n   * Receives the {@link SnippetConfig | snippet config} or retrieves it from window.initX and\n   * installs the plugin and initializes the Vue application.\n   *\n   * @param snippetConfig - The {@link SnippetConfig} that receives from snippet integration.\n   *\n   * @returns If {@link SnippetConfig | snippet config} is passed or configured in window.initX,\n   * returns an object with the {@link XAPI}, the {@link @empathyco/x-bus#XBus}, the {@link XPlugin}\n   * and the Vue App used in the application. Else, a rejected promise is returned.\n   *\n   * @public\n   */\n  init(snippetConfig: SnippetConfig): Promise<InitWrapper>;\n  init(): Promise<InitWrapper | void>;\n  async init(snippetConfig = this.retrieveSnippetConfig()): Promise<InitWrapper | void> {\n    if (snippetConfig) {\n      this.snippetConfig = this.normaliseSnippetConfig(snippetConfig);\n      const bus = this.createBus();\n      const pluginOptions = this.getPluginOptions();\n      const plugin = this.installPlugin(pluginOptions, bus);\n      const extraPlugins = await this.installExtraPlugins(bus);\n      const app = this.createApp(extraPlugins);\n      this.api?.setBus(bus);\n\n      return {\n        api: this.api,\n        app,\n        bus,\n        plugin\n      };\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Creates the {@link XPluginOptions} object.\n   *\n   * @returns The {@link XPluginOptions} object.\n   *\n   * @internal\n   */\n  protected getPluginOptions(): XPluginOptions {\n    const { adapter, store, initialXModules, xModules, __PRIVATE__xModules } = this.options;\n    return {\n      adapter,\n      store,\n      xModules,\n      initialXModules,\n      __PRIVATE__xModules\n    };\n  }\n\n  /**\n   * This method returns the bus instance to be used in the {@link XPlugin} and in the {@link XAPI}.\n   * It returns the `bus` parameter in the {@link InstallXOptions} or if not provided, then\n   * creates a new instance of {@link @empathyco/x-bus#XPriorityBus | bus}.\n   *\n   * @returns XBus - The bus instance.\n   *\n   * @internal\n   */\n  protected createBus(): XBus<XEventsTypes, WireMetadata> {\n    return this.options.bus ?? bus;\n  }\n\n  /**\n   * This method returns the VueConstructor to use to create the App instance.\n   * It returns the `vue` parameter in the {@link InstallXOptions} or if not provided, then\n   * returns the default Vue.\n   *\n   * @remarks The purpose of this option is mainly the testing. In a test we can use this option\n   * to pass the local vue instance created by `createLocalVue` method.\n   *\n   * @returns VueConstructor - The vue constructor to create the App instance.\n   *\n   * @internal\n   */\n  protected getVue(): VueConstructor {\n    return this.options.vue ?? Vue;\n  }\n\n  /**\n   * Creates and install the Vue Plugin. If `plugin` parameter is passed in the\n   * {@link InstallXOptions}, then it is used. If not, then a new instance of {@link XPlugin} is\n   * created and installed.\n   *\n   * @param pluginOptions - The {@link XPluginOptions} to passed as parameter to the install method\n   * of the plugin.\n   * @param bus - The {@link @empathyco/x-bus#XBus} to be used to create the XPlugin.\n   *\n   * @returns PluginObject<XPluginOption> - The plugin instance.\n   * @internal\n   */\n  protected installPlugin(\n    pluginOptions: XPluginOptions,\n    bus: XBus<XEventsTypes, WireMetadata>\n  ): PluginObject<XPluginOptions> {\n    const plugin = this.options.plugin ?? new XPlugin(bus);\n    const vue = this.getVue();\n    vue.use(plugin, pluginOptions);\n    return plugin;\n  }\n\n  /**\n   * Install more plugins to Vue defined by the user.\n   *\n   * @param bus - The events bus used in the application.\n   * @returns The arguments from the plugins installation to be used in Vue's constructor.\n   * @internal\n   */\n  protected installExtraPlugins(\n    bus: XBus<XEventsTypes, WireMetadata>\n  ): Promise<VueConstructorPartialArgument> {\n    const vue = this.getVue();\n    return Promise.resolve(\n      this.options.installExtraPlugins?.({ vue, snippet: this.snippetConfig!, bus })\n    );\n  }\n\n  /**\n   * In the case that the `app` parameter is present in the {@link InstallXOptions}, then a new Vue\n   * application is created using that app.\n   *\n   * @param extraPlugins - Vue plugins initialisation data.\n   * @returns The Created Vue application or undefined if not created.\n   *\n   * @internal\n   */\n  protected createApp(extraPlugins: VueConstructorPartialArgument): Vue | undefined {\n    if (this.options.app !== undefined) {\n      const vue = this.getVue();\n      const app = new vue({\n        ...extraPlugins,\n        ...this.options.vueOptions,\n        provide: {\n          snippetConfig: (this.snippetConfig = vue.observable(this.snippetConfig))\n        },\n        store: this.options.store,\n        el: this.getMountingTarget(this.options.domElement),\n        render: h => h(this.options.app)\n      });\n      this.options.onCreateApp?.(app);\n      return app;\n    }\n  }\n\n  protected normaliseSnippetConfig(snippetConfig: SnippetConfig): NormalisedSnippetConfig;\n  protected normaliseSnippetConfig(snippetConfig: Partial<SnippetConfig>): Partial<SnippetConfig>;\n  /**\n   * Transforms the snippet configuration.\n   * - If `lang` is provided and `uiLang` is not, it sets `uiLang=lang`.\n   *\n   * @param snippetConfig - The snippet config to normalise.\n   * @returns The normalised version of the given snippet config.\n   * @internal\n   */\n  protected normaliseSnippetConfig(\n    snippetConfig: SnippetConfig | Partial<SnippetConfig>\n  ): NormalisedSnippetConfig | Partial<SnippetConfig> {\n    if (snippetConfig.lang) {\n      snippetConfig.uiLang ??= snippetConfig.lang;\n    }\n    return snippetConfig;\n  }\n\n  /**\n   * It returns the HTML element to mount the Vue Application. If the `domElement` parameter in\n   * the {@link InstallXOptions} is an Element or an element selector, then this will be used.\n   * The `domElement` can also be a function with the {@link SnippetConfig} as parameter which\n   * returns an Element or element selector to use.\n   * If it is not present, a new <div> Element is created and appended to the body.\n   *\n   * @param domElement - {@link InstallXOptions.domElement | Element, string or function} Used\n   * to mount the Vue Application.\n   *\n   * @returns The Element to use as mounting target for the Vue Application.\n   * @internal\n   */\n  protected getMountingTarget(domElement?: InstallXOptions['domElement']): Element {\n    if (isFunction(domElement)) {\n      domElement = domElement(this.snippetConfig!);\n    }\n    if (typeof domElement === 'string') {\n      const target = document.querySelector(domElement);\n      if (!target) {\n        throw Error(\n          `XComponents app couldn't be mounted: Element \"${domElement}\" couldn't be found`\n        );\n      }\n      return target;\n    }\n    return domElement ?? document.body.appendChild(document.createElement('div'));\n  }\n\n  /**\n   * It updates all the provided properties from the current snippet config.\n   *\n   * @param newSnippetConfig - All the properties to be updated in the {@link SnippetConfig}.\n   *\n   * @internal\n   */\n  protected updateSnippetConfig(newSnippetConfig: Partial<SnippetConfig>): void {\n    if (!this.snippetConfig) {\n      return;\n    }\n    forEach(this.normaliseSnippetConfig(newSnippetConfig), (name, value) => {\n      this.getVue().set(this.snippetConfig!, name, value);\n    });\n  }\n}\n"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","emptyObject","freeze","isArray","Array","isUndef","v","isDef","isTrue","isPrimitive","value","isFunction","isObject","obj","_toString","prototype","toString","isPlainObject","call","isValidArrayIndex","val","n","parseFloat","String","Math","floor","isFinite","isPromise","then","catch","JSON","stringify","toNumber","isNaN","makeMap","str","expectsLowerCase","map","create","list","split","toLowerCase","isReservedAttribute","remove$2","arr","item","len","index","indexOf","splice","hasOwnProperty","hasOwn","cached","fn","cache","camelizeRE","camelize","replace","_","toUpperCase","capitalize","charAt","slice","hyphenateRE","hyphenate","bind","Function","ctx","boundFn","a","l","apply","_length","toArray","start","ret","extend","to","_from","toObject","res","noop","b","no","identity","looseEqual","isObjectA","isObjectB","isArrayA","isArrayB","every","e","Date","getTime","keysA","keys","keysB","looseIndexOf","once","called","this","hasChanged","x","y","SSR_ATTR","ASSET_TYPES","LIFECYCLE_HOOKS","config","optionMergeStrategies","silent","productionTip","devtools","performance","errorHandler","warnHandler","ignoredElements","keyCodes","isReservedTag","isReservedAttr","isUnknownElement","getTagNamespace","parsePlatformTagName","mustUseProp","async","_lifecycleHooks","isReserved","charCodeAt","def","enumerable","writable","configurable","bailRE","RegExp","concat","source","hasProto","inBrowser","window","UA","navigator","userAgent","isIE","test","isIE9","isEdge","isIOS","_isServer","isFF","match","nativeWatch","watch","supportsPassive","opts","get","addEventListener","isServerRendering","undefined","global","env","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","isNative","Ctor","_Set","hasSymbol","Symbol","ownKeys","Set","set","has","add","clear","currentInstance","getCurrentInstance","proxy","setCurrentInstance","vm","_scope","off","on","VNode","tag","data","children","text","elm","context","componentOptions","asyncFactory","ns","fnContext","fnOptions","fnScopeId","componentInstance","parent","raw","isStatic","isRootInsert","isComment","isCloned","isOnce","asyncMeta","isAsyncPlaceholder","createEmptyVNode","node","createTextVNode","cloneVNode","vnode","cloned","uid$2","pendingCleanupDeps","Dep","_pending","id","subs","addSub","sub","push","removeSub","depend","info","addDep","notify","filter","s","update","targetStack","pushTarget","popTarget","pop","arrayProto","arrayMethods","forEach","method","original","args","_i","inserted","result","ob","__ob__","observeArray","dep","arrayKeys","getOwnPropertyNames","NO_INIITIAL_VALUE","shouldObserve","toggleObserving","mockDep","Observer","shallow","mock","vmCount","__proto__","defineReactive","observe","ssrMockReactivity","isExtensible","__v_skip","isRef","customSetter","property","getter","setter","childOb","dependArray","newVal","isReadonly","max","_isVue","del","reactive","makeReactive","shallowReactive","isReactive","isShallow","__v_isShallow","__v_isReadonly","RefFlag","__v_isRef","ref$1","rawValue","ref","createRef","proxyWithRefUnwrap","oldValue","rawToReadonlyFlag","rawToShallowReadonlyFlag","readonly","existingFlag","existingProxy","getPrototypeOf","defineReadonlyProperty","createReadonly","computed","getterOrOptions","debugOptions","onlyGetter","watcher","Watcher","lazy","effect","dirty","evaluate","WATCHER","WATCHER_CB","WATCHER_GETTER","WATCHER_CLEANUP","activeEffectScope","INITIAL_WATCHER_VALUE","cb","options","doWatch","_a","_b","immediate","deep","_c","flush","onTrack","onTrigger","cleanup","instance","type","invokeWithErrorHandling","forceTrigger","isMultiSource","some","traverse","_isDestroyed","onCleanup","baseGetter_1","onStop","noRecurse","run","active","newValue","post","queueWatcher","_isMounted","buffer","_preWatchers","$once","teardown","EffectScope","detached","effects","cleanups","scopes","currentEffectScope","stop","fromParent","last","provide","resolveProvided","existing","_provided","parentProvides","$parent","inject","defaultValue","treatDefaultAsFactory","provides","normalizeEvent","name","passive","capture","createFnInvoker","fns","invoker","updateListeners","oldOn","remove","createOnceHandler","cur","old","event","params","mergeVNodeHook","hookKey","hook","oldHook","wrappedHook","merged","checkProp","hash","altKey","preserve","normalizeChildren","normalizeArrayChildren","isTextNode","nestedIndex","lastIndex","shift","_isVList","renderList","render","iterator","next","done","renderSlot","fallbackRender","props","bindObject","nodes","scopedSlotFn","$scopedSlots","$slots","slot","$createElement","resolveFilter","resolveAsset","$options","isKeyNotMatch","expect","actual","checkKeyCodes","eventKeyCode","builtInKeyCode","eventKeyName","builtInKeyName","mappedKeyCode","bindObjectProps","asProp","isSync","_loop_1","attrs","domProps","camelizedKey","hyphenatedKey","$event","renderStatic","isInFor","_staticTrees","tree","markStatic","staticRenderFns","_renderProxy","markOnce","markStaticNode","bindObjectListeners","ours","resolveScopedSlots","hasDynamicKeys","contentHashKey","$stable","$key","bindDynamicKeys","baseObj","values","prependModifier","symbol","installRenderHelpers","_o","_n","_s","_l","_t","_q","_m","_f","_k","_v","_e","_u","_g","_d","_p","resolveSlots","slots","child","default","name_1","name_2","isWhitespace","normalizeScopedSlots","ownerVm","scopedSlots","normalSlots","prevScopedSlots","hasNormalSlots","isStable","_normalized","$hasNormal","key_1","normalizeScopedSlot","key_2","proxyNormalSlot","normalized","initSetup","setup","_setupContext","_attrsProxy","syncSetupProxy","$attrs","listeners","_listenersProxy","$listeners","_slotsProxy","syncSetupSlots","initSlotsProxy","emit","$emit","expose","exposed","createSetupContext","setupResult","_props","_setupState","__sfc","_setupProxy","from","prev","changed","defineProxyAttr","currentRenderingInstance","ensureCtor","comp","base","__esModule","toStringTag","getFirstComponentChild","createElement$1","normalizationType","alwaysNormalize","is","simpleNormalizeChildren","$vnode","pre","createComponent","applyNS","style","class","registerDeepBindings","_createElement","force","h","handleError","err","hooks","errorCaptured","globalHandleError","handler","_handled","logError","console","error","timerFunc","isUsingMicroTask","callbacks","pending","flushCallbacks","copies","Promise","p_1","resolve","setTimeout","MutationObserver","setImmediate","counter_1","observer","textNode_1","document","createTextNode","characterData","nextTick","_resolve","hookName","onMounted","mergeLifecycleHook","injectHook","defineComponent","seenObjects","_traverse","seen","isA","isFrozen","depId","target$1","uid$1","expOrFn","isRenderWatcher","scope","_vm","_watcher","user","sync","before","deps","newDeps","depIds","newDepIds","expression","path","segments","parsePath","cleanupDeps","tmp","_isBeingDestroyed","add$1","$on","remove$1","$off","createOnceHandler$1","_target","onceHandler","updateComponentListeners","oldListeners","activeInstance","setActiveInstance","prevActiveInstance","isInInactiveTree","_inactive","activateChildComponent","direct","_directInactive","$children","callHook$1","deactivateChildComponent","setContext","handlers","j","_hasHookEvent","queue","activatedChildren","waiting","flushing","currentFlushTimestamp","getNow","now","performance_1","createEvent","timeStamp","sortCompareFn","flushSchedulerQueue","sort","activatedQueue","updatedQueue","callActivatedHooks","callUpdatedHooks","resolveInject","provideKey","provideDefault","FunctionalRenderContext","contextVm","_this","_original","isCompiled","_compiled","needNormalization","injections","_scopeId","cloneAndMarkFunctionalResult","renderContext","clone","mergeProps","getComponentName","__name","_componentTag","componentVNodeHooks","init","hydrating","keepAlive","mountedNode","prepatch","_isComponent","_parentVnode","inlineTemplate","createComponentInstanceForVnode","$mount","oldVnode","propsData","parentVnode","renderChildren","newScopedSlots","oldScopedSlots","hasDynamicScopedSlot","needsForceUpdate","_renderChildren","prevVNode","_vnode","prevListeners","_parentListeners","propKeys","_propKeys","propOptions","validateProp","$forceUpdate","updateChildComponent","insert","destroy","$destroy","hooksToMerge","baseCtor","_base","cid","factory","errorComp","resolved","owner","owners","loading","loadingComp","owners_1","sync_1","timerLoading_1","timerTimeout_1","forceRender_1","renderCompleted","clearTimeout","reject_1","reason","res_1","component","delay","timeout","resolveAsyncComponent","createAsyncPlaceholder","resolveConstructorOptions","model","prop","callback","transformModel","extractPropsFromVNodeData","functional","vnodes","createFunctionalComponent","nativeOn","abstract","toMerge","_merged","mergeHook","installComponentHooks","f1","f2","warn","strats","mergeData","recursive","toVal","fromVal","mergeDataOrFn","parentVal","childVal","instanceData","defaultData","dedupeHooks","mergeAssets","parent_1","methods","defaultStrat","mergeOptions","normalizeProps","normalizeInject","dirs","directives","normalizeDirectives$1","extends","mixins","mergeField","strat","warnMissing","assets","camelizedId","PascalCaseId","absent","booleanIndex","getTypeIndex","Boolean","stringIndex","getType","getPropDefaultValue","prevShouldObserve","functionTypeCheckRE","isSameType","expectedTypes","sharedPropertyDefinition","sourceKey","initState","propsOptions","isRoot","initProps$1","initMethods","_data","getData","initData","watchers","_computedWatchers","isSSR","userDef","computedWatcherOptions","defineComputed","initComputed$1","createWatcher","initWatch","shouldCache","createComputedGetter","createGetterInvoker","$watch","uid","super","superOptions","modifiedOptions","modified","latest","sealed","sealedOptions","resolveModifiedOptions","extendOptions","components","Vue","_init","initExtend","Super","SuperId","cachedCtors","_Ctor","Sub","constructor","Comp","initProps","initComputed","mixin","use","_getComponentName","matches","pattern","pruneCache","keepAliveInstance","entry","pruneCacheEntry","current","_uid","vnodeComponentOptions","initInternalComponent","_self","$root","$refs","initLifecycle","_events","initEvents","parentData","initRender","initInjections","provideOption","provided","initProvide","el","initMixin$1","dataDef","propsDef","$set","$delete","stateMixin","hookRE","i_1","cbs","eventsMixin","_update","prevEl","$el","prevVnode","restoreActiveInstance","__patch__","__vue__","wrapper","lifecycleMixin","$nextTick","_render","renderMixin","patternTypes","KeepAlive","include","exclude","Number","cacheVNode","vnodeToCache","keyToCache","parseInt","created","destroyed","mounted","updated","builtInComponents","configDef","util","delete","observable","plugin","installedPlugins","_installedPlugins","unshift","install","initUse","initMixin","definition","initAssetRegisters","initGlobalAPI","ssrContext","version","acceptValue","isEnumeratedAttr","isValidContentEditableValue","isBooleanAttr","xlinkNS","isXlink","getXlinkProp","isFalsyAttrValue","genClassForVnode","parentNode","childNode","mergeClassData","staticClass","dynamicClass","stringifyClass","renderClass","stringified","stringifyArray","stringifyObject","namespaceMap","svg","math","isHTMLTag","isSVG","unknownElementCache","isTextInputType","nodeOps","createElement","tagName","multiple","setAttribute","createElementNS","namespace","createComment","insertBefore","newNode","referenceNode","removeChild","appendChild","nextSibling","setTextContent","textContent","setStyleScope","scopeId","registerRef","isRemoval","refValue","$refsValue","isFor","refInFor","_isString","_isRef","refs","includes","setSetupRef","emptyNode","sameVnode","typeA","typeB","sameInputType","createKeyToOldIdx","beginIdx","endIdx","updateDirectives","oldDir","dir","isCreate","isDestroy","oldDirs","normalizeDirectives","newDirs","dirsWithInsert","dirsWithPostpatch","oldArg","arg","callHook","componentUpdated","callInsert","emptyModifiers","modifiers","getRawDirName","setupDef","rawName","join","baseModules","updateAttrs","inheritAttrs","oldAttrs","_v_attr_proxy","setAttr","removeAttributeNS","removeAttribute","isInPre","baseSetAttr","convertEnumeratedValue","setAttributeNS","__ieph","blocker_1","stopImmediatePropagation","removeEventListener","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","klass","RANGE_TOKEN","CHECKBOX_RADIO_TOKEN","useMicrotaskFix","attachedTimestamp_1","original_1","_wrapper","currentTarget","ownerDocument","updateDOMListeners","event_1","change","normalizeEvents","svgContainer","events","updateDOMProps","oldProps","childNodes","_value","strCur","shouldUpdateValue","innerHTML","firstChild","checkVal","composing","notInFocus","activeElement","isNotInFocusAndDirty","_vModifiers","number","trim","isDirtyWithModifiers","parseStyleText","cssText","propertyDelimiter","normalizeStyleData","normalizeStyleBinding","staticStyle","bindingStyle","emptyStyle","cssVarRE","importantRE","setProp","setProperty","normalizedName","normalize","vendorNames","capName","updateStyle","oldStaticStyle","oldStyleBinding","normalizedStyle","oldStyle","newStyle","checkChild","styleData","getStyle","whitespaceRE","addClass","classList","getAttribute","removeClass","tar","resolveTransition","css","autoCssTransition","enterClass","enterToClass","enterActiveClass","leaveClass","leaveToClass","leaveActiveClass","hasTransition","TRANSITION","ANIMATION","transitionProp","transitionEndEvent","animationProp","animationEndEvent","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","raf","requestAnimationFrame","nextFrame","addTransitionClass","transitionClasses","removeTransitionClass","whenTransitionEnds","expectedType","getTransitionInfo","propCount","ended","end","onEnd","transformRE","styles","getComputedStyle","transitionDelays","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationDurations","animationTimeout","hasTransform","delays","durations","toMs","enter","toggleDisplay","_leaveCb","cancelled","transition","_enterCb","nodeType","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","duration","transitionNode","isAppear","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","explicitEnterDuration","expectsCSS","userWantsControl","getHookArgumentsLength","show","pendingNode","isValidDuration","leave","rm","beforeLeave","afterLeave","leaveCancelled","delayLeave","explicitLeaveDuration","performLeave","invokerFns","_enter","patch","backend","modules","removeNode","createElm","insertedVnodeQueue","parentElm","refElm","nested","ownerArray","isReactivated","initComponent","innerNode","activate","reactivateComponent","setScope","createChildren","invokeCreateHooks","pendingInsert","isPatchable","i_2","ancestor","addVnodes","startIdx","invokeDestroyHook","removeVnodes","ch","removeAndInvokeRemoveHook","i_3","childElm","createRmCb","findIdxInOld","oldCh","i_5","patchVnode","removeOnly","hydrate","newCh","oldKeyToIdx","idxInOld","vnodeToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","updateChildren","postpatch","invokeInsertHook","initial","i_6","isRenderedModule","inVPre","hasChildNodes","childrenMatch","i_7","fullInvoke","isInitialPatch","isRealElement","hasAttribute","oldElm","patchable","i_8","i_9","insert_1","i_10","createPatchFunction","vmodel","trigger","directive","binding","_vOptions","setSelected","getValue","onCompositionStart","onCompositionEnd","prevOptions_1","curOptions_1","o","hasNoMatchingOption","actuallySetSelected","isMultiple","selected","option","selectedIndex","initEvent","dispatchEvent","locateNode","originalDisplay","__vOriginalDisplay","display","unbind","platformDirectives","transitionProps","mode","getRealChild","compOptions","extractTransitionData","placeholder","rawChild","isNotTextNode","isVShowDirective","Transition","hasParentTransition","_leaving","oldRawChild","oldChild","isSameChild","delayedLeave_1","moveClass","TransitionGroup","beforeMount","kept","prevChildren","rawChildren","transitionData","removed","pos","getBoundingClientRect","hasMove","callPendingCbs","recordPosition","applyTranslation","_reflow","body","offsetHeight","moved","el_1","transform","WebkitTransform","transitionDuration","_moveCb","propertyName","_hasMove","cloneNode","newPos","oldPos","dx","left","dy","top","platformComponents","_typeof","_defineProperty","_toConsumableArray","arr2","_arrayWithoutHoles","iter","_iterableToArray","TypeError","_nonIterableSpread","reflectionIsSupported","defineMetadata","getOwnMetadataKeys","copyReflectionMetadata","forwardMetadata","propertyKey","metaKey","metadata","getOwnMetadata","attr","HTMLUnknownElement","HTMLElement","updateComponent","preWatchers","mountComponent","querySelector","query","createDecorator","__decorators__","_len","Ctors","_key","collectDataFromConstructor","Component","originalInit","plainData","$internalHooks","componentFactory","proto","descriptor","superProto","Extended","forwardStaticMembers","shouldIgnore","callee","caller","Original","extendedDescriptor","superDescriptor","registerHooks","reactiveInjectKey","Inject","Provide","k","managed","managedReactive","rv","this_1","produceProvide","reflectMetadataIsSupported","getMetadata","Prop","applyMetadata","Watch","isArrayEmpty","array","arrayToObject","reduce","accumulator","groupItemsBy","groupBy","keyValue","createEmitterArrayFilter","comparator","comparatorFn","newItem","oldItem","newCollection","oldCollection","find","XProvide","componentKey","previousProvide","previousProvideObject","isProvideFunction","getPreviousProvideObject","newProvideObject","getNewProvideObject","assign","XInject","injectKey","privateComponentKey","previousInjectObject","previousInject","newInjectObject","getNewInjectObject","computedToPrivateProperty","computedKey","getComputedProperty","LogLevel","__assign","t","p","__spreadArray","pack","ar","logger","instanceTags","SimpleLogger","commonConsoleLevel","level","commonServerLevel","log","debug","trace","consoleLevel","sendLogToConsole","serverLevel","sendLogToServer","consoleFunctionName","storage","prefix","BrowserStorageService","ttlInMs","prefixedKey","prefixKey","expirableItem","createExpirableItem","serializedItem","setItem","removeExpiredItems","getItem","parse","getItemValue","removeItem","getOwnKeys","removedCount","ttl","currentTimestamp","startsWith","InMemoryStorageService","numberOfRemovedItems","NoElement","extendStatics","setPrototypeOf","__extends","__","__awaiter","thisArg","_arguments","P","generator","reject","fulfilled","step","rejected","__generator","f","g","label","sent","trys","ops","verb","throw","return","op","__values","m","__read","__await","__asyncGenerator","asyncIterator","q","resume","fulfill","settle","__asyncValues","createErrorClass","createImpl","ctorFunc","Error","stack","UnsubscriptionError","_super","errors","message","arrRemove","initialTeardown","empty","Subscription","closed","_parentage","_parentage_1","initialFinalizer","_finalizers","_finalizers_1","finalizer","execFinalizer","_hasParent","_addParent","_removeParent","EMPTY_SUBSCRIPTION","EMPTY","isSubscription","unsubscribe","onUnhandledError","onStoppedNotification","useDeprecatedSynchronousErrorHandling","useDeprecatedNextContext","timeoutProvider","delegate","handle","reportUnhandledError","COMPLETE_NOTIFICATION","createNotification","kind","errorContext","destination","EMPTY_OBSERVER","Subscriber","complete","SafeSubscriber","isStopped","handleStoppedNotification","nextNotification","_next","errorNotification","_error","_complete","_bind","partialObserver","ConsumerObserver","handleUnhandledError","observerOrNext","context_1","notification","subscriber","pipeFromArray","input","subscribe","_subscribe","Observable","operator","isObserver","_trySubscribe","sink","promiseCtor","getPromiseCtor","Symbol_observable","operations","operate","lift","hasLift","liftedSource","createOperatorSubscriber","onNext","onComplete","onError","onFinalize","OperatorSubscriber","shouldUnsubscribe","closed_1","ObjectUnsubscribedError","Subject","subject","AnonymousSubject","_throwIfClosed","currentObservers","observers","hasError","thrownError","_checkFinalizedStatuses","_innerSubscribe","dateTimestampProvider","_bufferSize","_windowTime","_timestampProvider","_infiniteTimeWindow","Infinity","ReplaySubject","_buffer","_trimBuffer","subscription","copy","adjustedBufferSize","scheduler","work","Action","state","intervalProvider","setInterval","clearInterval","AsyncAction","recycleAsyncId","requestAsyncId","_id","_scheduler","_execute","_delay","errorValue","errored","actions","schedulerActionCtor","Scheduler","schedule","SchedulerAction","AsyncScheduler","action","_active","execute","innerFrom","isInteropObservable","obs","promise","isAsyncIterable","fromAsyncIterable","Symbol_iterator","isIterable","iterable","iterable_1","getReader","isReadableStreamLike","readableStream","reader","read","releaseLock","readableStreamLikeToAsyncGenerator","createInvalidObservableTypeError","asyncIterable","asyncIterable_1","process","project","timer","dueTime","intervalOrScheduler","intervalDuration","due","isValidDate","argsOrArgArray","predicate","raceInit","sources","subscriptions","XOn","xEvent","metadataFilteringOptions","originalCreated","componentCreateSubscription","createSubscription","subscriptionMetadata","newEvents","eventArray","$x","pipe","filterMetadataOptions","filteringOptions","eventOptions","eventPayload","XEmit","something","getGetterPath","moduleName","getterName","State","module","$store","Getter","getterPath","getters","getSafePropertyChain","propertyChain","defaultReturn","getChain","callbackFn","reducer","initialValue","mapper","cleanEmpty","pickedObject","objectFilter","isIncluded","getNewAndUpdatedKeys","flatObject","object","flattenedObject","DefaultSessionService","storageService","localStorage","ttlMs","getSessionId","sessionId","SESSION_ID_KEY","size","crypto","getRandomValues","Uint8Array","byte","nanoid","clearSessionId","Behaviour","deepMerge","cloneSourcesProperties","behaviourMap","WeakMap","entries","cloneObjectProperties","mergeBehaviour","targetValue","sourceValue","Replace","DeepMerge","deepMergeBehaviour","mergeObject","devtoolHook","deepCopy","hit","forEachValue","Module","rawModule","runtime","_children","_rawModule","rawState","prototypeAccessors","namespaced","addChild","getChild","hasChild","mutations","forEachChild","forEachGetter","forEachAction","forEachMutation","defineProperties","ModuleCollection","rawRootModule","register","targetModule","newModule","root","getNamespace","this$1","rawChildModule","unregister","isRegistered","Store","plugins","strict","_committing","_actions","_actionSubscribers","_mutations","_wrappedGetters","_modules","_modulesNamespaceMap","_subscribers","_watcherVM","_makeLocalGettersCache","store","dispatch","commit","payload","installModule","resetStoreVM","_devtoolHook","targetState","replaceState","mutation","prepend","subscribeAction","devtoolPlugin","prototypeAccessors$1","genericSubscribe","resetStore","hot","oldVm","wrappedGetters","partial","$$state","enableStrictMode","_withCommit","rootState","parentState","getNestedState","local","noNamespace","_type","_payload","_options","unifyObjectStyle","gettersProxy","splitPos","localType","makeLocalGetters","makeLocalContext","registerMutation","rootGetters","registerAction","rawGetter","registerGetter","_Vue","beforeCreate","vuexInit","applyMixin","all","after","registerModule","preserveState","unregisterModule","hasModule","hotUpdate","newOptions","committing","mapState","normalizeNamespace","states","normalizeMap","getModuleByNamespace","vuex","mapMutations","mapGetters","mapActions","isValidMap","helper","startMessage","collapsed","groupCollapsed","group","endMessage","groupEnd","getFormattedTime","time","pad","getHours","getMinutes","getSeconds","getMilliseconds","num","maxLength","times","createNamespacedHelpers","createLogger","stateBefore","stateAfter","transformer","mutationTransformer","mut","actionFilter","actionTransformer","act","logMutations","logActions","prevState","nextState","formattedTime","formattedMutation","formattedAction","getGettersProxy","cachedGetter","isCacheGetterDefined","modulePath","safeGetters","getterKey","safeGettersProxy","fullPathGetterName","defineGetterProxy","RootXStoreModule","device","empathize","extraParams","facets","historyQueries","identifierResults","nextQueries","popularSearches","queriesPreview","querySuggestions","recommendations","relatedTags","scroll","search","searchBox","semanticQueries","tagging","url","mergeEvents","raceEvent","createTimer","durationInMs","cancelOn","forceOn","timerObservable","notifier","race","wire","filterFn","filterRx","wirePayload","filterTruthyPayload","debounce","timeInMs","durationSelector","normalizeTime","hasValue","lastValue","durationSubscriber","mapWire","toWire","mapFn","restWireParams","restWirePayload","BaseXPriorityQueueNode","priority","BaseXPriorityQueue","isEmpty","pushAndSort","replaceableIndex","findIndex","replaceable","insertAtIndex","peek","at","output","regex","layer","bus","priorities","emitCallbacks","defaultEventPriority","MIN_SAFE_INTEGER","getEventPriority","eventMetadata","flushQueue","matchingKey","pendingFlushId","clearPendingPopsIds","popTimeoutId","emitter","getEmitter","payloadObj","pendingPopsIds","timeoutId","withMetadata","asObservable","emitters","createEmitter","Updated","Changed","FromUrl","User","External","Initialized","Provided","DataReceived","ModuleRegistered","registerStoreEmitters","storeEmitters","storeModule","getGettersProxyFromModule","stateSelector","selector","selectorOptions","isSimpleSelector","normalizeStateSelector","watcherSelector","getXComponentXModuleName","xModule","isXComponent","createXComponentAPIMixin","$location","xComponent","currentComponent","getRootXComponent","aliasAPI","acc","status","historyQueriesWithResults","fullHistoryQueries","isHistoryQueriesEnabled","isEnabled","fromNoResultsWithFilters","searchBoxStatus","inputStatus","isEmpathizeOpen","isOpen","noResults","isNoResults","partialResults","fullQuerySuggestions","suggestions","redirections","results","selectedFilters","selectedRelatedTags","spellcheckedQuery","totalResults","selectedSort","getAliasAPI","busAPI","location","createWireMetadata","getBusAPI","XPlugin","adapter","getInstance","static","wiring","installedXModules","isInstalled","registerXModule","lazyRegisterXModule","pendingXModules","vue","assertXPluginOptionsAreValid","registerStore","applyMixins","registerInitialModules","registerPendingXModules","customizedXModule","customizeXModule","registerStoreModule","registerWiring","restXModule","wiringOptions","xModules","storeModuleOptions","emittersOptions","__PRIVATE__xModules","customizeStoreModule","wires","defaultState","actionsGettersMutations","xModuleState","newActionsGettersMutations","configOptions","configOptionsObject","customizedModule","Vuex","initialXModules","xComponentMixin","createStoreEmitters","wireCommit","createSubscriptionCallback","wireService","service","observablePayload","wireServiceWithoutPayload","commitOrDispatch","mutationOrAction","storeExecutor","observableValue","createWiring","getStateAndGettersFromModule","namespacedWireCommit","getPayload","namespacedWireCommitWithoutPayload","wireCommitWithoutPayload","namespacedWireDispatch","wireDispatch","namespacedWireDispatchWithoutPayload","wireDispatchWithoutPayload","tryOnScopeDispose","onScopeDispose","toValue","unref","isClient","toRef","toRef$1","customRef","unrefElement","elRef","plain","defaultWindow","useEventListener","stopWatch","options2","flatMap","listener","useSupported","isMounted","useMounted","useMediaQuery","isSupported","matchMedia","mediaQuery","removeListener","addListener","watchEffect","getMapVue2Compat","useWindowSize","initialWidth","initialHeight","listenOrientation","includeScrollbar","width","height","innerWidth","innerHeight","documentElement","clientWidth","clientHeight","tryOnMounted","isStringEmpty","toKebabCase","getSortedByWidthDevices","resolver","generateKey","getKey","_loadData","memoized","load","useMemoize","devices","aWidth","bWidth","detectTouchable","maxTouchPoints","GlobalXBus","handleXEventSubscription","eventName","SnippetCallbacks","eventListeners","snippetConfig","callbackReturn","__vue_script__","createOrigin","feature","namespacedDebounce","timingOperator","timeSelector","createNamespacedTimeWireOperator","BaseXAPI","isXInitialized","addProductToCart","productId","setBus","setInitCallback","initCallback","setSnippetConfigCallback","snippetCallback","setSnippetConfig","close","numberFormatKeys","msg","isString","isNull","parseArgs","locale","looseClone","merge","arguments$1","i18n","__i18n","VueI18n","localeMessages","messages","resource","mergeLocaleMessage","_i18n","_i18nWatcher","watchI18nData","rootI18n","$i18n","formatter","fallbackLocale","formatFallbackMessages","silentTranslationWarn","silentFallbackWarn","pluralizationRules","preserveDirectiveContent","localeMessages$1","sharedMessages","_localeWatcher","watchLocale","onComponentInstanceCreated","subscribeDataChanging","_subscribing","beforeDestroy","self","unsubscribeDataChanging","destroyVM","interpolationComponent","required","places","onlyHasDefaultPlace","assignChildIndex","createParamsFromPlaces","everyPlace","vnodeHasPlaceAttribute","assignChildPlace","useLegacyPlaces","place","numberComponent","format","parts","_ntp","part","assert","oldVNode","_locale","localeEqual","_localeMessage","getLocaleMessage","_vt","ref$2","choice","parseValue","tc","makeParams","installed","$t","_getMessages","$tc","_tc","$te","_te","$d","$n","BaseFormatter","_caches","interpolate","tokens","position","char","isClosed","RE_TOKEN_LIST_VALUE","RE_TOKEN_NAMED_VALUE","compiled","token","compile","pathStateMachine","ws","ident","eof","else","literalValueRE","getPathCharType","formatSubPath","exp","trimmed","I18nPath","_cache","newChar","typeMap","subPathDepth","maybeUnescapeQuote","nextChar","parse$1","getPathValue","paths","availabilities","htmlTagMatcher","linkKeyMatcher","linkKeyPrefixMatcher","bracketsMatcher","defaultModifiers","upper","toLocaleUpperCase","lower","toLocaleLowerCase","substr","defaultFormatter","dateTimeFormats","numberFormats","_formatter","_modifiers","_missing","missing","_root","_sync","_fallbackRoot","fallbackRoot","_formatFallbackMessages","_silentTranslationWarn","_silentFallbackWarn","_dateTimeFormatters","_numberFormatters","_path","_dataListeners","_componentInstanceCreatedListener","componentInstanceCreatedListener","_preserveDirectiveContent","_warnHtmlInMessage","warnHtmlInMessage","_postTranslation","postTranslation","getChoiceIndex","choicesLength","thisPrototype","_choice","_choicesLength","abs","min","_exist","_checkLocaleMessage","_initVM","availableLocales","newI18n","_getDateTimeFormats","_getNumberFormats","_localeChainCache","fallback","orgLevel","_warnDefault","interpolateMode","missingRet","parsedArgs","_isFallbackRoot","_isSilentFallbackWarn","_isSilentFallback","_isSilentTranslationWarn","_interpolate","host","visitedLinkStack","pathRet","_link","idx","link","linkKeyPrefixMatches","linkPrefix","formatterName","linkPlaceholder","translated","_translate","_createMessageContext","_list","_named","named","_appendItemToChain","chain","blocks","follow","_appendLocaleToChain","_appendBlockToChain","block","_getLocaleChain","defaults","predefined","count","fetchChoice","choices","te","setLocaleMessage","getDateTimeFormat","setDateTimeFormat","_clearDateTimeFormat","mergeDateTimeFormat","_localizeDateTime","formats","Intl","DateTimeFormat","getNumberFormat","setNumberFormat","_clearNumberFormat","mergeNumberFormat","_getNumberFormatter","NumberFormat","numberFormat","formatToParts","intlDefined","dateTimeFormat","I18n","currentMessages","getCurrentMessages","vueI18n","getMessageWithDotsInKey","pathParts","newLocale","changeMessages","newDevice","rawMessages","areLazyMessages","taggingXStoreModule","sessionTTLMs","queryTaggingDebounceMs","clickedResultStorageKey","clickedResultStorageTTLMs","consent","queryTaggingInfo","setConsent","setQueryTaggingInfo","setTaggingConfig","taggingConfig","track","taggingInfo","taggingInfos","session","taggingEmitters","ConsentChanged","SearchTaggingReceived","ResultURLTrackingEnabled","DefaultPDPAddToCartService","localStorageService","sessionStorageService","sessionStorage","storeResultClicked","storageId","getStorageId","moveToSessionStorage","trackAddToCart","add2cart","href","pathName","getPathName","RESULT_CLICKED_ID_KEY","showWarningMessage","urlObject","URL","origin","pathname","moduleDebounce","wireSessionServiceWithoutPayload","wirePDPAddToCartService","storeClickedResultWire","moveClickedResultToSessionWire","trackAddToCartFromSessionStorage","clearSessionWire","trackQueryWire","trackResultClickedWire","createTrackWire","trackBannerClickedWire","ignoreInModules","taggingXModule","ConsentProvided","PDPIsLoaded","SearchTaggingChanged","TaggingConfigProvided","UserClickedAResult","UserClickedResultAddToCart","trackAddToCartWire","UserClickedPDPAddToCart","UserClickedABanner","UserClickedADisplayResult","trackDisplayClickedWire","displayFamily","displayOriginalQuery","Tagging","activeConsent","emitEvents","_isIE","modifiersRE","nonEventNameCharsRE","names","extractEventOptions","eventDescriptor","modifier","isActive","activated","deactivated","_listeners","initialUrlState","page","setQuery","createRelatedTagsQueryGetter","getRelatedTags","concatRelatedTag","partialQuery","relatedTagQuery","isNotDefaultValue","defaultValues","urlXStoreModule","initialExtraParams","urlParams","paramKey","paramValue","setRelatedTags","relatedTag","setFilters","newFilters","setPage","setSort","setInitialExtraParams","setScroll","replaceableParams","shouldPushUrl","newParams","oldParams","urlEmitters","PushableUrlStateUpdated","ReplaceableUrlStateUpdated","setUrlRelatedTags","setUrlQuery","setUrlPage","setUrlSort","setParams","setUrlScroll","urlXModule","ParamsLoadedFromUrl","UserAcceptedAQuery","UserClearedQuery","SelectedRelatedTagsChanged","SelectedFiltersForRequestChanged","setUrlFilters","PageChanged","SortChanged","ExtraParamsChanged","ExtraParamsInitialized","UserScrolledToElement","UrlHandler","urlLoaded","isPagePersisted","managedParamsNames","getUrlKey","paramName","updateUrlWithPush","newUrlParams","updateUrl","history","pushState","updateUrlWithReplace","onPageShow","persisted","extra","parseUrlParams","detectLocation","currentUrl","previousUrl","isNavigatingFromPdp","navigationEntries","getEntriesByType","navigationType","useFallbackStrategy","navigation","fallbackNavigationType","TYPE_BACK_FORWARD","TYPE_NAVIGATE","isNavigatingInSpa","isSpa","urlSearchParams","searchParams","urlKey","urlValue","getAll","parseUrlParam","historyMethod","deleteUrlParameters","setUrlParameters","title","filteredParams","sortParams","urlParamKey","append","param1","param2","GlobalEvents","extraParamsXStoreModule","extraParamsEmitters","setExtraParams","extraParamsXModule","UserChangedExtraParams","ExtraParamsProvided","ExtraParamsLoadedFromUrl","ExtraParams","storeExtraParams","SnippetConfigExtraParams","newExtraParams","excludedExtraParams","useDevice","devicesFlags","orientation","isTouchable","deviceName","windowSize","deviceWidth","isDevice","otherDeviceWidth","isCurrentDevice","getDeviceFlags","screen","screenOrientation","angle","lockOrientation","lock","unlockOrientation","unlock","useScreenOrientation","getOrientation","isTouchableRef","getIsTouchable","getDeviceName","createUseDevice","mobile","tablet","desktop","large","EUR","USD","App","open","documentDirection","currencyFormat","currencies","currency","queriesPreviewInfo","syncLang","uiLang","$setLocale","syncDevice","$setLocaleDevice","MainModal","import","RequestError","response","toJson","ok","fetchHttpClient","endpoint","cancelable","parameters","properties","sendParamsInBody","signal","abortAndGetNewAbortSignal","flatParameters","arrayItemValue","buildUrl","bodyParameters","fetch","requestAbortControllers","abort","AbortController","identityMapper","STRING_PARAMETERS","HEAD_OR_TAIL","STRING_PARAMETER_CONTENT","endpointAdapterFactory","endpointAdapter","request","requestEndpoint","requestOptions","rawEndpoint","httpClient","requestMapper","responseMapper","defaultRequestOptions","string","_match","propertyToReplace","head","tail","getEndpoint","requestParameters","extendedOptions","mutableSchemasInternalMethods","createMutableSchema","schema","$replace","newSchema","isInternalMethod","$override","$extends","includeInternalMethods","serialize","indentation","repeat","schemaMapperFactory","mapSchema","$subSchema","$path","$context","rawContext","subSource","extendedContext","subSchema","applySubSchemaTransformer","isHierarchicalFilter","modelName","searchRequestSchema","rows","filters","parentId","searchRequestMapper","getTaggingInfoFromUrl","taggingUrl","Map","param","fromEntries","extractUrlParameters","bannerSchema","image","click","hierarchicalFilterSchema","facetId","numberFilterSchema","range","simpleFilterSchema","editableNumberFilterSchema","getFacetConfig","typeConfigs","hierarchical","facetSchema","resultSchema","images","identifier","rating","price","originalValue","__prices","rawPrices","previous","futureValue","future","hasDiscount","isWishlisted","checkout","displayClick","displayTaggingUrl","displayClickTagging","displayClickTaggingParams","displayId","getDisplayClickTagging","partialResultsSchema","promotedSchema","redirectionSchema","searchResponseMapper","spellcheck","banners","promoteds","queryTagging","catalog","searchEndpointAdapter","internal","popularSearchesRequestMapper","suggestionSchema","title_raw","keywords","isCurated","popularSearchesResponseMapper","popularSearchesEndpointAdapter","recommendationsRequestSchema","recommendationsRequestMapper","recommendationsResponseMapper","recommendationsEndpointAdapter","nextQueriesRequestMapper","identifierResultsResponseSchema","nextQuerySchema","nextQueriesResponseSchema","querySuggestionsResponseSchema","relatedTagSchema","relatedTagsResponseSchema","semanticQuerySchema","distance","semanticQueriesResponseSchema","nextQueriesResponseMapper","nextQueriesEndpointAdapter","relatedTagsRequestMapper","relatedTagsResponseMapper","relatedTagsEndpointAdapter","identifierResultsRequestMapper","identifierResultsResponseMapper","identifierResultsEndpointAdapter","taggingEndpointAdapter","keepalive","querySuggestionsRequestMapper","querySuggestionsResponseMapper","querySuggestionsEndpointAdapter","semanticQueriesRequestMapper","semanticQueriesResponseMapper","platformAdapter","algonomyResultSchema","imageId","priceCents","salePriceCents","description","brand","categoryId","categoryName","numReviews","releaseDate","algonomyBannerSchema","image_url","algonomyPromotedSchema","algonomyRedirectionSchema","algonomySimpleFilterSchema","algonomyFacetSchema","placementMapper","placementProperty","element","algonomySearchResponseSchema","placements","docs","numFound","spellchecked","links","banner","sponsored","directlink","searchTrackingUrl","algonomySearchRequestSchema","placement","lang","algonomyQuerySuggestionsRequestSchema","algonomySuggestionSchema","algonomyQuerySuggestionsResponseSchema","algonomySuggestions","suggestion","installXOptions","app","filtersStrategyForRequest","threshold","maxItemsToRequest","snippet","setLocale","setDevice","__enableVueDevtools__","createAPI","api","updateSnippetConfig","InterfaceX","retrieveSnippetConfig","initX","normaliseSnippetConfig","createBus","pluginOptions","getPluginOptions","installPlugin","extraPlugins","installExtraPlugins","createApp","getVue","vueOptions","getMountingTarget","domElement","onCreateApp","newSnippetConfig"],"mappings":"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"}